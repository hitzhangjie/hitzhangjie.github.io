<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raft on</title><link>/tags/raft/</link><description>Recent content in Raft on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sun, 05 Sep 2021 00:47:15 +0800</lastBuildDate><atom:link href="/tags/raft/index.xml" rel="self" type="application/rss+xml"/><item><title>如何使用raft算法开发强一致kv存储系统</title><link>/blog/2021-09-04-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raft%E5%BC%80%E5%8F%91%E5%BC%BA%E4%B8%80%E8%87%B4kv%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 05 Sep 2021 00:47:15 +0800</pubDate><guid>/blog/2021-09-04-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raft%E5%BC%80%E5%8F%91%E5%BC%BA%E4%B8%80%E8%87%B4kv%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid><description>本文内容 # 本文结合etcd源码来进行介绍，etcd/contrib/raftexample提供了一个基于etcd/raft实现的kv存储系统。从该示例出发，我们来看一看如何基于raft算法开发一个强一致的kv存储系统。
看完本文的源码分析后，上手一个raft强一致系统开发就不是什么难事了。
ps：假定读者已经阅读并理解了raft论文，这里有我的批注版的In Search of an Understandable Consensus Algorithm.pdf，读起来可能会好理解点。
etcd/raft # etcd服务端程序入口：see 源码
启动过程中区分当前节点类型：根据data-dir目录下的目录名member/proxy/empty来区分，然后启动etcd实例或者proxy； 启动etcd服务节点：startEtcd这个函数，逻辑主要包括启动供集群节点间通信的rafthttp服务，以及供客户端请求的服务； 启动etcd proxy：startProxy这个函数，逻辑主要是启动etcd代理； etcd哪些部分值得学习：
etcd proxy从项目功能上来说虽然很重要，但是从学习角度来说没那么有价值，不看这个； etcd server从项目功能上来说是核心，但是我们也没有必要学习所有的请求处理逻辑，重点是关注读写操作时如何基于raft实现强一致； raft：这部分是raft算法的核心实现，从理解raft论文到算法工程化需要额外做出巨大的优化，这些知识点往往是通用的，重点掌握； raft部分：
pb协议： raft peers的通信协议，see 源码； raft算法中提到核心的几个rpc就是Vote、AppendEntries，但是工程中需要考虑更多，详见上述pb中的enum MessageType； 上述pb中的message Message类型定义了rpc通信过程中的请求/响应，不同rpc通过MessageType type字段区分； 状态机： raft实现数据一致性是通过replicated log（复制日志）实现的，这里的replicated log有时也称为WAL（write ahead log）； raft算法中，每个节点raftnode可能处于以下状态中的一种：follower、candidate、precandidate、leader； raft算法中，每个节点的状态可以通过一个状态机来建模； 了解了这些基础知识之后，我们结合etcd/contrib/raftexample来解释下raft如何选举，以及leader遇到写操作如何保证数据强一致。
etcd/raft如何进行leader选举 # newRaftNode newRaftNode，see 源码，这个函数包括创建一个var rc raftNode，然后rc.startRaft()，这个函数包含非常重要的几个部分：
startNode，see 源码，这个主要是建立好raftnode启动时的一些初始状态转换，有一个for事件循环处理，如改变raftnode的状态：tick函数、step函数，以及一些message的处理等等； serveRaft： serveChannels：see 源码 startNode:</description></item><item><title>分布式系统工程师roadmap</title><link>/blog/2021-07-01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88roadmap/</link><pubDate>Fri, 02 Jul 2021 12:45:38 +0800</pubDate><guid>/blog/2021-07-01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88roadmap/</guid><description>如何成为一名资深的分布式系统工程师，需要补齐哪些理论基础，又需要哪些工程方面的锻炼？本文原文见 Henry Robinson 的文章 distributed systems theory for the distributed systems engineer，我觉得是一个很不错的roadmap，沿着这个脉络半年下来，还是很有收获的……继续:)
1 掌握分布式背后的相关理论 # 可能会有人甩出很多论文，FLP论文、Paxos论文、Raft论文、拜占庭将军相关的论文&amp;hellip;相关的论文可以摆出很多，但是论文是有一定深度的，是非常严谨的论述，对于攻读PhD的同学有帮助，但是对于一名从事分布式系统工程的同学真的有必要全部掌握吗？应该看多少论文，毕竟经过了那么多年的发展、沉淀呢？ 作为一名分布式系统工程师，搞明白需要掌握哪些理论，比单纯了解有哪些论文更重要。
2 First Steps # 下面的4个文集很好地介绍了构建一个分布式系统要面临的挑战，它们共同概述了分布式系统工程师必须克服的一些技术上的困难，并为后面章节中更详细的说明奠定了基础。
Distributed Systems for Fun and Profit，介绍了分布式系统的基础知识，包括时间在分布式系统中扮演的角色、不同的复制策略等； Notes on distributed systems for young bloods，不是纯理论介绍，在理论和实践中做到了一个不错的平衡，为后续更深入学习打好基础； A Note on Distributed Systems，一篇很经典的论文，解释了分布式系统中为什么不能总把远程交互对象当做本地的对象，让读者理解分布式场景中的问题和挑战； The fallacies of distributed computing，分布式计算的8个谬论，为分布式系统设计人员设计系统打下基础； 我们需要了解两个重要属性的含义，“safety”和“liveness”：
safety，该属性表示不会有坏的事情发生，如API不会返回不一致的value、集群中不会同时选出两个leader等； liveness，该属性表示好的事情最终会发生，如API最终会返回一个结果、磁盘写操作最终会完成等； 3 Failure and Time # 分布式系统工程师面对的一些困难，其实可以归结为下面2个原因：
Processes may fail There&amp;rsquo;s no good way to tell that they have done so 即，分布式系统中的任意进程可能会出现故障，但是其他进程又没有可靠的方式来感知这个进程出现了故障。</description></item></channel></rss>