<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.63b6b8ff933309fcc94a30e21d69932290c8643fa1a32893f5681778c776ed3e51c237a1acd00b42426b3bf780c351b4a6ce75b3b659915ef0dd610b2e027a8c.css integrity="sha512-Y7a4/5MzCfzJSjDiHWmTIpDIZD+hoyiT9WgXeMd27T5RwjehrNALQkJrO/eAw1G0ps51s7ZZkV7w3WELLgJ6jA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>x64汇编开发介绍 - MySpace</title><meta name=description content="最近在工作和学习中发现，其实汇编是非常重要的，即便现在高级语言已经非常方便了，但是了解汇编对于深入理解计算机系统，以及一些高深的知识点是不可或缺的。举几个例子，比如说Linux操作系统有一个系统调用函数叫Fork我们都知道Fork的返回值在子进程中是0，在父进程中是非0，那这个是如何实现的呢？对于不了解汇编的人也很难有能力去阅读Linux操作系统源码，只能道听途说了解到个大概原因。再比如接下来要讲的gomonkey测试框架实现的一些指令patching操作，这些都是与汇编操作分不开的。甚至你想了解下上下文切换开销，你都需要深入了解下指令执行周期等等的问题。
不懂汇编，不妨碍你开发上层应用，但是对你的深度就是一道坎，你很难跨国这个鸿沟去窥探更底层的一些原理。
有感而发，今天就回顾下intel官方开发发布的x64汇编知识，做一个简单的回顾，也为后面研究gomonkey指令patching等等做一些准备和铺垫。
介绍 # 大家使用x86汇编来写一些对性能比较敏感的程序嗯，这个情况已经持续很多年了嗯，但是现在32位机器应逐渐被64位机器取代了，对应的汇编代码也发生了变化。这篇文章主要就是介绍x64汇编的，如果不了解x86汇编也没什么大碍，当然了解的话理解起来会更简单一点。
x64是一个通用的名字，它表示的是对Intel以及AMD 32位指令集架构的一个64位扩展。AMD首先引入了x64指令集，最初叫x86-64，后面又改成了AMD64。Intel呢，将其支持64位指令集的架构称之为IA-32e，后面又改成了EMT64。这两个版本之间有一点细微的不兼容的地方，但是大部分指令在两个版本上都可以很好的工作，相关的细节可以参考Intel开发手册Intel 64 And IA-32 Architectures Software Developer&amp;rsquo;s Manuals，以及AMD64架构的技术文档。我们将这两个版本的交集部分称之为x64。不要将x64与64位Intel Itanium架构（称之为IA-64）混为一谈。
这篇文章没有涉及硬件相关的细节，如caches、分支预测，以及其他高级话题。文章最后会给出一些这些领域的参考手册供了解更多。
汇编语言，往往会用来编写对性能要求比较苛刻的程序或其中的一部分。但是对大部分普通程序员来说，与其让其写汇编，还不如写cc++然后配上一个好的编译器来的实在，后者编译器优化的性能可能比其写出的汇编代码质量更高。汇编语言对于调试代码也是有用的，有时一个编译器可能生成了一些不正确的汇编指令，通过调试器在程序中单步调试可以帮助定位到问题的原因。代码优化器，有时也会犯错。汇编的另外一个用途，你可以用它来研究没有源码的程序。反汇编让你能够改变、修复现有的可执行程序（推荐下几个工具hopper or cutter）。如果你想了解或者调查为什么某种编程语言比较慢，其他的比较快之类的问题，汇编也是你的好帮手。最后吧，掌握汇编知识，对于诊断一些恶意软件，也是必不可少的技能。
架构 # 当要去学习特定平台的汇编时，首先应该学习的是，该平台的寄存器集合。
通用架构 # 64位寄存器允许容纳更大的尺寸的数据，或者是地址，所以我们定义的更多的类型，将1个字节byte定义成8bits，将1个字word定义成16bits，将一个双字double word定义成32bits，将一个四字quadword定义成64位，将一个八字double quadword定义成128bits。关于字节序的问题，Intel是小端字节序，意味着低有效位存储在内存的低地址中。
上图显示了16个64bits的通用目的寄存器，前8个被命名成rax、rbx、rcx、rdx、rbp、rsi、rdi、rsp，这个命名和历史原因有关系，后面8个被命名成了r8~r15。如果前8个自己存器名，将字符r换成e，就变成了对应的地位的32位寄存器，比如rax的低32位是eax。类似地，如果想访问低16位，就直接把前缀去掉，如AX就是访问的rax的低16位，如果低8位呢，那就是AL了，AH就是次低8位（8~15位）。新加的8个寄存器r8~r15可以用类似的方式来访问低位数据，如r8（qword），r8d（lower dword），r8w（lowest word）、r8b（lowest byte MASM风格，intel风格是r8l）。注意没有r8h这种表示法。
使用REX操作码前缀去访问新添加的这8个通用寄存器的字节时，有一些限制，不能像访问之前的8个通用寄存器一样通过AH、BH、CH、DH来访问，并且一次只能访问一个（如R11B），但是可以使用AL、BL、CL、DL，为啥来，因为它就是强制要求将AH、BH、CH、DH转换成BPL、SPL、DIL、SIL来使用。
64位指令指针寄存器RIP，指向下一条要执行的指令的低质，并且支持64位平坦内存模型，当前操作系统中的内存地址布局将在后面提及。
栈指针寄存器RSP，指向当前刚push进栈的元素空间地址，也就是栈顶了，栈从高地址向低地址方向增长。栈用来存储调用例程（函数）的返回值、传递参数，或者用以支持ABI中的调用惯例（如保存调用方现场）。
RFLAGS寄存器，用来存储一些标识信息，它用来标识一些操作的结果（如是否溢出、运算结果的正负等）或者控制处理器的执行。这在x86 32位寄存器EFLAGS中就已经形成了这些，现在在以前基础上又添加了高32位，用来预留支持扩展，当前是没有使用的。下表列出了最常使用的一些flags。大多数其他flags是用于操作系统级别的任务。
   Symbol Bit Name Set if&amp;hellip;     CF 0 Carry Operation generated a carry or borrow   PF 2 Parity Last byte has even number of 1&amp;rsquo;s, else 0   AF 4 Adjust Denotes Binary Coded Decimal in-byte carry   ZF 6 Zero Result was 0   SF 7 Sign Most significant bit of result is 1   OF 11 Overflow Overflow on signed operation         DF 10 Direction Direction string instructions operate (increment or decrement)   ID 21 Identification Changeability denotes presence of CPUID instruction    浮点运算单元（FPU，Floating Point Unit）包含了8个寄存器FPR0-FPR7，还有状态寄存器、控制寄存器，以及其他的几个寄存器。FPR0-7这几个寄存器，每个都可以存储下表中列出的数据类型的值。浮点操作遵从IEEE 754标准。注意，大多数c/c++编译器支持32位和64位的float、double数据类型，但是没有支持80位的浮点数据类型，但是汇编是支持的。这8个寄存器和另外8个MMX？寄存器实际上是共享的同一组物理寄存器。"><link rel=canonical href=/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="x64汇编开发介绍"><meta property="og:description" content="最近在工作和学习中发现，其实汇编是非常重要的，即便现在高级语言已经非常方便了，但是了解汇编对于深入理解计算机系统，以及一些高深的知识点是不可或缺的。举几个例子，比如说Linux操作系统有一个系统调用函数叫Fork我们都知道Fork的返回值在子进程中是0，在父进程中是非0，那这个是如何实现的呢？对于不了解汇编的人也很难有能力去阅读Linux操作系统源码，只能道听途说了解到个大概原因。再比如接下来要讲的gomonkey测试框架实现的一些指令patching操作，这些都是与汇编操作分不开的。甚至你想了解下上下文切换开销，你都需要深入了解下指令执行周期等等的问题。
不懂汇编，不妨碍你开发上层应用，但是对你的深度就是一道坎，你很难跨国这个鸿沟去窥探更底层的一些原理。
有感而发，今天就回顾下intel官方开发发布的x64汇编知识，做一个简单的回顾，也为后面研究gomonkey指令patching等等做一些准备和铺垫。
介绍 # 大家使用x86汇编来写一些对性能比较敏感的程序嗯，这个情况已经持续很多年了嗯，但是现在32位机器应逐渐被64位机器取代了，对应的汇编代码也发生了变化。这篇文章主要就是介绍x64汇编的，如果不了解x86汇编也没什么大碍，当然了解的话理解起来会更简单一点。
x64是一个通用的名字，它表示的是对Intel以及AMD 32位指令集架构的一个64位扩展。AMD首先引入了x64指令集，最初叫x86-64，后面又改成了AMD64。Intel呢，将其支持64位指令集的架构称之为IA-32e，后面又改成了EMT64。这两个版本之间有一点细微的不兼容的地方，但是大部分指令在两个版本上都可以很好的工作，相关的细节可以参考Intel开发手册Intel 64 And IA-32 Architectures Software Developer&rsquo;s Manuals，以及AMD64架构的技术文档。我们将这两个版本的交集部分称之为x64。不要将x64与64位Intel Itanium架构（称之为IA-64）混为一谈。
这篇文章没有涉及硬件相关的细节，如caches、分支预测，以及其他高级话题。文章最后会给出一些这些领域的参考手册供了解更多。
汇编语言，往往会用来编写对性能要求比较苛刻的程序或其中的一部分。但是对大部分普通程序员来说，与其让其写汇编，还不如写cc++然后配上一个好的编译器来的实在，后者编译器优化的性能可能比其写出的汇编代码质量更高。汇编语言对于调试代码也是有用的，有时一个编译器可能生成了一些不正确的汇编指令，通过调试器在程序中单步调试可以帮助定位到问题的原因。代码优化器，有时也会犯错。汇编的另外一个用途，你可以用它来研究没有源码的程序。反汇编让你能够改变、修复现有的可执行程序（推荐下几个工具hopper or cutter）。如果你想了解或者调查为什么某种编程语言比较慢，其他的比较快之类的问题，汇编也是你的好帮手。最后吧，掌握汇编知识，对于诊断一些恶意软件，也是必不可少的技能。
架构 # 当要去学习特定平台的汇编时，首先应该学习的是，该平台的寄存器集合。
通用架构 # 64位寄存器允许容纳更大的尺寸的数据，或者是地址，所以我们定义的更多的类型，将1个字节byte定义成8bits，将1个字word定义成16bits，将一个双字double word定义成32bits，将一个四字quadword定义成64位，将一个八字double quadword定义成128bits。关于字节序的问题，Intel是小端字节序，意味着低有效位存储在内存的低地址中。
上图显示了16个64bits的通用目的寄存器，前8个被命名成rax、rbx、rcx、rdx、rbp、rsi、rdi、rsp，这个命名和历史原因有关系，后面8个被命名成了r8~r15。如果前8个自己存器名，将字符r换成e，就变成了对应的地位的32位寄存器，比如rax的低32位是eax。类似地，如果想访问低16位，就直接把前缀去掉，如AX就是访问的rax的低16位，如果低8位呢，那就是AL了，AH就是次低8位（8~15位）。新加的8个寄存器r8~r15可以用类似的方式来访问低位数据，如r8（qword），r8d（lower dword），r8w（lowest word）、r8b（lowest byte MASM风格，intel风格是r8l）。注意没有r8h这种表示法。
使用REX操作码前缀去访问新添加的这8个通用寄存器的字节时，有一些限制，不能像访问之前的8个通用寄存器一样通过AH、BH、CH、DH来访问，并且一次只能访问一个（如R11B），但是可以使用AL、BL、CL、DL，为啥来，因为它就是强制要求将AH、BH、CH、DH转换成BPL、SPL、DIL、SIL来使用。
64位指令指针寄存器RIP，指向下一条要执行的指令的低质，并且支持64位平坦内存模型，当前操作系统中的内存地址布局将在后面提及。
栈指针寄存器RSP，指向当前刚push进栈的元素空间地址，也就是栈顶了，栈从高地址向低地址方向增长。栈用来存储调用例程（函数）的返回值、传递参数，或者用以支持ABI中的调用惯例（如保存调用方现场）。
RFLAGS寄存器，用来存储一些标识信息，它用来标识一些操作的结果（如是否溢出、运算结果的正负等）或者控制处理器的执行。这在x86 32位寄存器EFLAGS中就已经形成了这些，现在在以前基础上又添加了高32位，用来预留支持扩展，当前是没有使用的。下表列出了最常使用的一些flags。大多数其他flags是用于操作系统级别的任务。
   Symbol Bit Name Set if&mldr;     CF 0 Carry Operation generated a carry or borrow   PF 2 Parity Last byte has even number of 1&rsquo;s, else 0   AF 4 Adjust Denotes Binary Coded Decimal in-byte carry   ZF 6 Zero Result was 0   SF 7 Sign Most significant bit of result is 1   OF 11 Overflow Overflow on signed operation         DF 10 Direction Direction string instructions operate (increment or decrement)   ID 21 Identification Changeability denotes presence of CPUID instruction    浮点运算单元（FPU，Floating Point Unit）包含了8个寄存器FPR0-FPR7，还有状态寄存器、控制寄存器，以及其他的几个寄存器。FPR0-7这几个寄存器，每个都可以存储下表中列出的数据类型的值。浮点操作遵从IEEE 754标准。注意，大多数c/c++编译器支持32位和64位的float、double数据类型，但是没有支持80位的浮点数据类型，但是汇编是支持的。这8个寄存器和另外8个MMX？寄存器实际上是共享的同一组物理寄存器。"><meta property="og:url" content="/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/"><meta property="og:site_name" content="MySpace"><meta property="article:published_time" content="2020-08-20T20:27:19+08:00"><meta property="article:modified_time" content="2020-08-20T20:27:19+08:00"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="MySpace"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@hitzhangjie"><meta name=twitter:creator content="@hitzhangjie"><meta name=twitter:title content="x64汇编开发介绍"><meta name=twitter:description content><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="x64汇编开发介绍"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":["https://twitter.com/hitzhangjie","https://www.linkedin.com/in/hitzhangjie/","https://github.com/hitzhangjie"],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"MySpace","description":"MySpace is a hitzhangjie\u0027s personal space, for blogs, books, journey, thinkings.","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/","url":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/","name":"x64汇编开发介绍","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2020-08-20T20:27:19CET","dateModified":"2020-08-20T20:27:19CET","breadcrumb":{"@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/"]}]},{"@type":"BreadcrumbList","@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/blog2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"x64汇编开发介绍","description":"","isPartOf":{"@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/"},"mainEntityOfPage":{"@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/"},"datePublished":"2020-08-20T20:27:19CET","dateModified":"2020-08-20T20:27:19CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/person/1"},"image":{"@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/2020-08-20-x64%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E4%BB%8B%E7%BB%8D/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"x64汇编开发介绍"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=607868a58d7101001829a8df&product=sop" async></script><style>[alt~=sharing]{border:0;box-shadow:none}div#st-1{text-align:unset}div#st-1 .st-btn{height:24px;padding:0 4px}div#st-1 .st-btn>img{top:4.2px}div#st-2 .st-btn{height:24px;padding:0 4px}div#st-2 .st-btn>img{top:4.2px}</style></head><body class="blog single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=MySpace>MySpace</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>MySpace</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/books/>Books</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/journey/introduction>Journey</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://twitter.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-lg-none">Twitter</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Tag List</h3><ol><li><a href=/tags/intel/>intel</a></li><li><a href=/tags/assembly/>assembly</a></li><li><a href=/tags/x64/>x64</a></li></ol></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#介绍>介绍</a></li><li><a href=#架构>架构</a><ul><li><a href=#通用架构>通用架构</a></li><li><a href=#simd架构>SIMD架构</a></li></ul></li><li><a href=#工具>工具</a><ul><li><a href=#assemblers>assemblers</a></li><li><a href=#cc-compilers>c/c++ compilers</a></li></ul></li><li><a href=#指令基础>指令基础</a><ul><li><a href=#寻址模式>寻址模式</a></li><li><a href=#指令集>指令集</a></li></ul></li><li><a href=#操作系统>操作系统</a></li><li><a href=#调用约定>调用约定</a><ul><li><a href=#heading></a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考内容>参考内容</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>x64汇编开发介绍</h1><div style=display:flex><div>分享:&nbsp;&nbsp;</div><div><div class=sharethis-inline-share-buttons></div></div></div><hr><p class=lead></p><p>最近在工作和学习中发现，其实汇编是非常重要的，即便现在高级语言已经非常方便了，但是了解汇编对于深入理解计算机系统，以及一些高深的知识点是不可或缺的。举几个例子，比如说Linux操作系统有一个系统调用函数叫Fork我们都知道Fork的返回值在子进程中是0，在父进程中是非0，那这个是如何实现的呢？对于不了解汇编的人也很难有能力去阅读Linux操作系统源码，只能道听途说了解到个大概原因。再比如接下来要讲的gomonkey测试框架实现的一些指令patching操作，这些都是与汇编操作分不开的。甚至你想了解下上下文切换开销，你都需要深入了解下指令执行周期等等的问题。</p><p>不懂汇编，不妨碍你开发上层应用，但是对你的深度就是一道坎，你很难跨国这个鸿沟去窥探更底层的一些原理。</p><p>有感而发，今天就回顾下intel官方开发发布的x64汇编知识，做一个简单的回顾，也为后面研究gomonkey指令patching等等做一些准备和铺垫。</p><h2 id=介绍>介绍 <a href=#%e4%bb%8b%e7%bb%8d class=anchor aria-hidden=true>#</a><a href=#介绍 class=anchor aria-hidden=true>#</a></h2><p>大家使用x86汇编来写一些对性能比较敏感的程序嗯，这个情况已经持续很多年了嗯，但是现在32位机器应逐渐被64位机器取代了，对应的汇编代码也发生了变化。这篇文章主要就是介绍x64汇编的，如果不了解x86汇编也没什么大碍，当然了解的话理解起来会更简单一点。</p><p>x64是一个通用的名字，它表示的是对Intel以及AMD 32位指令集架构的一个64位扩展。AMD首先引入了x64指令集，最初叫x86-64，后面又改成了AMD64。Intel呢，将其支持64位指令集的架构称之为IA-32e，后面又改成了EMT64。这两个版本之间有一点细微的不兼容的地方，但是大部分指令在两个版本上都可以很好的工作，相关的细节可以参考Intel开发手册<a href=http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>Intel 64 And IA-32 Architectures Software Developer&rsquo;s Manuals</a>，以及AMD64架构的技术文档。我们将这两个版本的交集部分称之为x64。不要将x64与64位Intel Itanium架构（称之为IA-64）混为一谈。</p><p>这篇文章没有涉及硬件相关的细节，如caches、分支预测，以及其他高级话题。文章最后会给出一些这些领域的参考手册供了解更多。</p><p>汇编语言，往往会用来编写对性能要求比较苛刻的程序或其中的一部分。但是对大部分普通程序员来说，与其让其写汇编，还不如写cc++然后配上一个好的编译器来的实在，后者编译器优化的性能可能比其写出的汇编代码质量更高。汇编语言对于调试代码也是有用的，有时一个编译器可能生成了一些不正确的汇编指令，通过调试器在程序中单步调试可以帮助定位到问题的原因。代码优化器，有时也会犯错。汇编的另外一个用途，你可以用它来研究没有源码的程序。反汇编让你能够改变、修复现有的可执行程序（推荐下几个工具hopper or cutter）。如果你想了解或者调查为什么某种编程语言比较慢，其他的比较快之类的问题，汇编也是你的好帮手。最后吧，掌握汇编知识，对于诊断一些恶意软件，也是必不可少的技能。</p><h2 id=架构>架构 <a href=#%e6%9e%b6%e6%9e%84 class=anchor aria-hidden=true>#</a><a href=#架构 class=anchor aria-hidden=true>#</a></h2><p>当要去学习特定平台的汇编时，首先应该学习的是，该平台的寄存器集合。</p><h3 id=通用架构>通用架构 <a href=#%e9%80%9a%e7%94%a8%e6%9e%b6%e6%9e%84 class=anchor aria-hidden=true>#</a><a href=#通用架构 class=anchor aria-hidden=true>#</a></h3><p>64位寄存器允许容纳更大的尺寸的数据，或者是地址，所以我们定义的更多的类型，将1个字节byte定义成8bits，将1个字word定义成16bits，将一个双字double word定义成32bits，将一个四字quadword定义成64位，将一个八字double quadword定义成128bits。关于字节序的问题，Intel是小端字节序，意味着低有效位存储在内存的低地址中。</p><p><img src=https://software.intel.com/content/dam/develop/external/us/en/images/29529-figure-1-181178.jpg alt=通用架构></p><p>上图显示了16个64bits的通用目的寄存器，前8个被命名成rax、rbx、rcx、rdx、rbp、rsi、rdi、rsp，这个命名和历史原因有关系，后面8个被命名成了r8~r15。如果前8个自己存器名，将字符r换成e，就变成了对应的地位的32位寄存器，比如rax的低32位是eax。类似地，如果想访问低16位，就直接把前缀去掉，如AX就是访问的rax的低16位，如果低8位呢，那就是AL了，AH就是次低8位（8~15位）。新加的8个寄存器r8~r15可以用类似的方式来访问低位数据，如r8（qword），r8d（lower dword），r8w（lowest word）、r8b（lowest byte MASM风格，intel风格是r8l）。注意没有r8h这种表示法。</p><p>使用REX操作码前缀去访问新添加的这8个通用寄存器的字节时，有一些限制，不能像访问之前的8个通用寄存器一样通过AH、BH、CH、DH来访问，并且一次只能访问一个（如R11B），但是可以使用AL、BL、CL、DL，为啥来，因为它就是强制要求将AH、BH、CH、DH转换成BPL、SPL、DIL、SIL来使用。</p><p>64位指令指针寄存器RIP，指向下一条要执行的指令的低质，并且支持64位平坦内存模型，当前操作系统中的内存地址布局将在后面提及。</p><p>栈指针寄存器RSP，指向当前刚push进栈的元素空间地址，也就是栈顶了，栈从高地址向低地址方向增长。栈用来存储调用例程（函数）的返回值、传递参数，或者用以支持ABI中的调用惯例（如保存调用方现场）。</p><p>RFLAGS寄存器，用来存储一些标识信息，它用来标识一些操作的结果（如是否溢出、运算结果的正负等）或者控制处理器的执行。这在x86 32位寄存器EFLAGS中就已经形成了这些，现在在以前基础上又添加了高32位，用来预留支持扩展，当前是没有使用的。下表列出了最常使用的一些flags。大多数其他flags是用于操作系统级别的任务。</p><table><thead><tr><th style=text-align:left>Symbol</th><th style=text-align:left>Bit</th><th style=text-align:left>Name</th><th style=text-align:left>Set if&mldr;</th></tr></thead><tbody><tr><td style=text-align:left>CF</td><td style=text-align:left>0</td><td style=text-align:left>Carry</td><td style=text-align:left>Operation generated a carry or borrow</td></tr><tr><td style=text-align:left>PF</td><td style=text-align:left>2</td><td style=text-align:left>Parity</td><td style=text-align:left>Last byte has even number of 1&rsquo;s, else 0</td></tr><tr><td style=text-align:left>AF</td><td style=text-align:left>4</td><td style=text-align:left>Adjust</td><td style=text-align:left>Denotes Binary Coded Decimal in-byte carry</td></tr><tr><td style=text-align:left>ZF</td><td style=text-align:left>6</td><td style=text-align:left>Zero</td><td style=text-align:left>Result was 0</td></tr><tr><td style=text-align:left>SF</td><td style=text-align:left>7</td><td style=text-align:left>Sign</td><td style=text-align:left>Most significant bit of result is 1</td></tr><tr><td style=text-align:left>OF</td><td style=text-align:left>11</td><td style=text-align:left>Overflow</td><td style=text-align:left>Overflow on signed operation</td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>DF</td><td style=text-align:left>10</td><td style=text-align:left>Direction</td><td style=text-align:left>Direction string instructions operate (increment or decrement)</td></tr><tr><td style=text-align:left>ID</td><td style=text-align:left>21</td><td style=text-align:left>Identification</td><td style=text-align:left>Changeability denotes presence of CPUID instruction</td></tr></tbody></table><p>浮点运算单元（FPU，Floating Point Unit）包含了8个寄存器FPR0-FPR7，还有状态寄存器、控制寄存器，以及其他的几个寄存器。FPR0-7这几个寄存器，每个都可以存储下表中列出的数据类型的值。浮点操作遵从IEEE 754标准。注意，大多数c/c++编译器支持32位和64位的float、double数据类型，但是没有支持80位的浮点数据类型，但是汇编是支持的。这8个寄存器和另外8个MMX？寄存器实际上是共享的同一组物理寄存器。</p><table><thead><tr><th style=text-align:left>Data Type</th><th style=text-align:left>Length</th><th style=text-align:left>Precision (bits)</th><th style=text-align:left>Decimal digits Precision</th><th style=text-align:left>Decimal Range</th></tr></thead><tbody><tr><td style=text-align:left>Single Precision</td><td style=text-align:left>32</td><td style=text-align:left>24</td><td style=text-align:left>7</td><td style=text-align:left>1.18<em>10^-38 to 3.40</em>10^38</td></tr><tr><td style=text-align:left>Double Precision</td><td style=text-align:left>64</td><td style=text-align:left>53</td><td style=text-align:left>15</td><td style=text-align:left>2.23 <em>10^-308 to 1.79</em>10^308</td></tr><tr><td style=text-align:left>Extended Precision</td><td style=text-align:left>80</td><td style=text-align:left>64</td><td style=text-align:left>19</td><td style=text-align:left>3.37<em>10^-4932 to 1.18</em>10^4932</td></tr></tbody></table><p>有几个8位指令支持二进制编码的十进制（BCD），浮点寄存器支持的奇特格式还提供了一种80位，17位的BCD类型。</p><blockquote><p>不确定是否翻译有误，原文：Binary Coded Decimal (BCD) is supported by a few 8-bit instructions, and an oddball format supported on the floating point registers gives an 80 bit, 17 digit BCD type.</p></blockquote><p>这16个128bits的XMM寄存器（比x86多了8个）后面会有更详细介绍。</p><p>还有就是，段寄存器（在x64下大多数没有用）、控制寄存器、内存管理寄存器、调试寄存器、虚拟化寄存器、性能寄存器（跟踪记录各种类型的内部参数，如cache命中、miss，分支预测命中、miss，微码执行，定时等等）。最突出的性能相关的操作码就是RDTSC，它是用来技术处理器时钟周期的，经常通过它来测量一小段代码的执行耗时。通常c库里面提供的函数gettimeofday是比较耗时间的，所以在高频使用的时候会有性能问题，一般在网络框架里面做定时器、时间测量相关的任务，是会通过RDTSC来推送系统时间进而推算耗时的（在我的文章libmill定时器中也有提及，hitzhangjie.gitbook.io/libmill）。</p><p>更多其他细节信息，可以参考全5卷 &ldquo;Intel 64 And IA-32 Architectures Software Developer&rsquo;s Manuals&rdquo;，可以从这里免费下载，http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html。</p><h3 id=simd架构>SIMD架构 <a href=#simd%e6%9e%b6%e6%9e%84 class=anchor aria-hidden=true>#</a><a href=#simd架构 class=anchor aria-hidden=true>#</a></h3><p>单指令多数据（SIMD）指令对多条数据并行执行一条命令，这是汇编例程的常用用法。 MMX和SSE命令（分别使用MMX和XMM寄存器）支持SIMD操作，该操作可并行处理多达八段数据。例如，可以使用MMX在一条指令中将八个字节与另外八个字节相加。</p><p>八个64位MMX寄存器MMX0-MMX7是FPR0-7的别名，这意味着任何将FPR和MMX混合起来操作的代码都必须小心，不要覆盖所需的值。 MMX指令对整数类型进行操作，允许对MMX寄存器中的值并行执行字节，字和双字操作。大多数MMX指令以“P”开头表示“packed”。算术，移位/旋转，比较，例如：PCMPGTB表示“比较packed的的有符号1字节整数是否大于”。</p><p>16个128位XMM寄存器允许每条指令对四个单精度或两个双精度值进行并行运算。一些指令还适用于压缩字节，字，双字和四字整数。这些称为流式SIMD扩展（SSE）的指令具有多种形式：SSE，SSE2，SSE3，SSSE3，SSE4，以及在本文印制之时可能还会更多。英特尔已经宣布了这些扩展，称为英特尔®高级矢量扩展（Intel®AVX），具有新的256位宽数据路径。 SSE指令包含对浮点和整数类型的移动，算术，比较，重排和拆包以及按位运算。指令名称包括诸如PMULHUW和RSQRTPS之类的。最后，SSE引入了一些有关内存预取（出于性能）和内存屏障（出于多线程安全）的指令。</p><p>下表列出了一些命令集，操作的寄存器类型，并行操作的项目数以及项目类型。例如，使用SSE3和128位XMM寄存器，您可以并行处理2个（必须为64位）浮点值，或者并行处理16个（必须为字节大小）整数值。</p><p>为了找到给定芯片支持的技术，有一条CPUID指令返回特定于处理器的信息。</p><table><thead><tr><th style=text-align:left>Technology</th><th style=text-align:left>Register size/type</th><th style=text-align:left>Item type</th><th style=text-align:left>Items in Parallel</th></tr></thead><tbody><tr><td style=text-align:left>MMX</td><td style=text-align:left>64 MMX</td><td style=text-align:left>Integer</td><td style=text-align:left>8, 4, 2, 1</td></tr><tr><td style=text-align:left>SSE</td><td style=text-align:left>64 MMX</td><td style=text-align:left>Integer</td><td style=text-align:left>8,4,2,1</td></tr><tr><td style=text-align:left>SSE</td><td style=text-align:left>128 XMM</td><td style=text-align:left>Float</td><td style=text-align:left>4</td></tr><tr><td style=text-align:left>SSE2/SSE3/SSSE3&mldr;</td><td style=text-align:left>64 MMX</td><td style=text-align:left>Integer</td><td style=text-align:left>2,1</td></tr><tr><td style=text-align:left>SSE2/SSE3/SSSE3&mldr;</td><td style=text-align:left>128 XMM</td><td style=text-align:left>Float</td><td style=text-align:left>2</td></tr><tr><td style=text-align:left>SSE2/SSE3/SSSE3&mldr;</td><td style=text-align:left>128 XMM</td><td style=text-align:left>Integer</td><td style=text-align:left>16,8,4,2,1</td></tr></tbody></table><h2 id=工具>工具 <a href=#%e5%b7%a5%e5%85%b7 class=anchor aria-hidden=true>#</a><a href=#工具 class=anchor aria-hidden=true>#</a></h2><h3 id=assemblers>assemblers <a href=#assemblers class=anchor aria-hidden=true>#</a><a href=#assemblers class=anchor aria-hidden=true>#</a></h3><p>互联网搜索显示了具有x64功能的汇编程序，例如Netwide汇编程序NASM，在NASM基础上重写的YASM，快速的Flat Assembler FASM和传统的Microsoft MASM。甚至还有一个免费的用于x86和x64程序集的IDE，称为WinASM。每个汇编程序对其他汇编程序的宏和语法都有不同的支持，并不是完全兼容的。</p><p>对于以下示例，我使用平台SDK中免费提供的MASM的64位版本ML64.EXE。对于以下示例，请注意，MASM语法的格式为：“指令 目标操作数或地址，源操作数或地址”，有些汇编器中的语法中的源操作、目的操作的顺序是反着的。请参考对应汇编器的语法说明。</p><h3 id=cc-compilers>c/c++ compilers <a href=#cc-compilers class=anchor aria-hidden=true>#</a><a href=#cc-compilers class=anchor aria-hidden=true>#</a></h3><p>C/C++编译器通常允许使用内联汇编将汇编嵌入代码中，但是Microsoft Visual Studio C/C++为x64代码删除了该汇编，这可能简化了代码优化器的工作。剩下两个选择：使用单独的汇编文件和外部汇编器，或使用头文件“ intrn.h”中的内在函数（请参见Birtolo和MSDN）。其他编译器具有类似的选项。</p><p>使用启发式的理由：</p><ul><li>x64中不支持内联汇编了；</li><li>方便使用，你可以使用变量名，来代替对寄存器的手动分配；</li><li>启发式相比写汇编而言更容易实现跨平台，编译器会针对不同的平台做对应的启发式优化处理；</li><li>配合启发式操作，优化器工作的更好；</li></ul><p>例如，Microsoft Visual Studio 2008就有启发式操作，<code>unsigned short _rotr16(unsigned short_rot16 b, unsigned char c)</code>，这个操作将一个16位操作数b中向右rotate c位，并返回结果。使用c来实现的话，可以这么写<code>unsigned short a1 = (b>>c)|(b&lt;&lt;(16-c))</code>，这个汇编完成后大约是15条指令（debug模式下，如果是release模式下的话也差不太多），但是如果使用启发式操作<code>unsigned short a1 = _rotr16(b,c)</code>的话呢，汇编完成后只有4条指令，你说哪个更牛逼呢？！</p><h2 id=指令基础>指令基础 <a href=#%e6%8c%87%e4%bb%a4%e5%9f%ba%e7%a1%80 class=anchor aria-hidden=true>#</a><a href=#指令基础 class=anchor aria-hidden=true>#</a></h2><h3 id=寻址模式>寻址模式 <a href=#%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f class=anchor aria-hidden=true>#</a><a href=#寻址模式 class=anchor aria-hidden=true>#</a></h3><p>在学习之前，得先了解下寻址模式，寻址模式指明了指令访问寄存器或者内存的方式 ，以下是常见的几种寻址模式：</p><ul><li><p>立即数寻址（immediate）：操作数就在指令中，如<code>ADD EAX, 14 ;将操作数14与32位寄存器EAX中值相加并存储到EAX中</code></p></li><li><p>寄存器寻址（register to register）：操作数就在寄存器中，如<code>ADD R8L, AL ;将AL中的值与R8L中的值相加</code></p></li><li><p>间接寻址（indirect）：就是指令中给出的不是操作数本身，也不是操作数本身所在的地址，而是存储操作数地址的地址，甚至有可能出现多重间址的情况。这样的寻址中允许使用8，16，32位偏移量，或者任何通用目的寄存器来作为基地址或者索引，也允许使用1，2，4，8来对索引进行乘积运算。也可以为其加上段前缀，如FS:, GS:等，但是比较少使用。下面是一个示例，<code>MOV R8W, 1234[8*RAX+RCX] ;将地址8*RAX+RCX+1234处的一个word移动到R8W</code>，这种方式常用来访问结构体数组中的成员，1234往往是数组起始地址，8表示数组元素大小，RAX表示数组索引，RCX表示结构体字段相对结构体起始地址的偏移量。</p><p>这种寻址方式，起始有很多种写法了，下面这些都是等价的。</p><pre><code class=language-bash>MOV     ECX, dword ptr table[RBX][RDI]
MOV     ECX, dword ptr table[RDI][RBX]
MOV     ECX, dword ptr table[RBX+RDI]
MOV     ECX, dword ptr [table+RBX+RDI]
</code></pre><p>这里的dword ptr告诉汇编器如何编码MOV指令。</p></li><li><p>RIP相对寻址：这是x64中新加的寻址模式，它允许访问相对当前指令地址某偏移量出的数据，使得实现位置无关的代码更加容易了。如<code>MOV AL,[RIP] ;RIP指向下一条待执行指令的低质，aka NOP NOP</code>。可是，并不是所有汇编器都支持这种操作，MASM就不支持，但是FASM、YASM支持。MASM隐式地嵌入了RIP相对寻址，如<code>MOV EAX, TABLE ;使用RIP相对寻址来获取表地址</code>。</p></li><li><p>其他比较特殊的寻址：有些操作码使用寄存器的方式比较不一样，例如，有符号整数除操作IDIV，128位操作数RDX:RAX除以一个64位的操作数，会将商存储到RAX中，将余数存储到RDX中。</p></li></ul><h3 id=指令集>指令集 <a href=#%e6%8c%87%e4%bb%a4%e9%9b%86 class=anchor aria-hidden=true>#</a><a href=#指令集 class=anchor aria-hidden=true>#</a></h3><p>下表列出了一些比较常见的指令，其中*表示改指令有多个操作码，*表示后缀的意思：</p><table><thead><tr><th style=text-align:left>Opcode</th><th style=text-align:left>Meaning</th><th style=text-align:left>Opcode</th><th style=text-align:left>Meaning</th></tr></thead><tbody><tr><td style=text-align:left>MOV</td><td style=text-align:left>Move to/from/between memory and registers</td><td style=text-align:left>AND/OR/XOR/NOT</td><td style=text-align:left>Bitwise operations</td></tr><tr><td style=text-align:left>CMOV*</td><td style=text-align:left>Various conditional moves</td><td style=text-align:left>SHR/SAR</td><td style=text-align:left>Shift right logical/arithmetic</td></tr><tr><td style=text-align:left>XCHG</td><td style=text-align:left>Exchange</td><td style=text-align:left>SHL/SAL</td><td style=text-align:left>Shift left logical/arithmetic</td></tr><tr><td style=text-align:left>BSWAP</td><td style=text-align:left>Byte swap</td><td style=text-align:left>ROR/ROL</td><td style=text-align:left>Rotate right/left</td></tr><tr><td style=text-align:left>PUSH/POP</td><td style=text-align:left>Stack usage</td><td style=text-align:left>RCR/RCL</td><td style=text-align:left>Rotate right/left through carry bit</td></tr><tr><td style=text-align:left>ADD/ADC</td><td style=text-align:left>Add/with carry</td><td style=text-align:left>BT/BTS/BTR</td><td style=text-align:left>Bit test/and set/and reset</td></tr><tr><td style=text-align:left>SUB/SBC</td><td style=text-align:left>Subtract/with carry</td><td style=text-align:left>JMP</td><td style=text-align:left>Unconditional jump</td></tr><tr><td style=text-align:left>MUL/IMUL</td><td style=text-align:left>Multiply/unsigned</td><td style=text-align:left>JE/JNE/JC/JNC/J*</td><td style=text-align:left>Jump if equal/not equal/carry/not carry/ many others</td></tr><tr><td style=text-align:left>DIV/IDIV</td><td style=text-align:left>Divide/unsigned</td><td style=text-align:left>LOOP/LOOPE/LOOPNE</td><td style=text-align:left>Loop with ECX</td></tr><tr><td style=text-align:left>INC/DEC</td><td style=text-align:left>Increment/Decrement</td><td style=text-align:left>CALL/RETCall</td><td style=text-align:left>subroutine/return</td></tr><tr><td style=text-align:left>NEG</td><td style=text-align:left>Negate</td><td style=text-align:left>NOP</td><td style=text-align:left>No operation</td></tr><tr><td style=text-align:left>CMP</td><td style=text-align:left>Compare</td><td style=text-align:left>CPUID</td><td style=text-align:left>CPU information</td></tr></tbody></table><p>一个常见的指令就是LOOP指令，它将RCX，ECX或者CX的值减去1，然后如果结果不是0的话，就执行跳转，下面是个示例：</p><pre><code class=language-asm>   XOR	EAX, EAX	; zero out eax
   MOV 	ECX, 10 	; loop 10 times
Label:			; this is a label in assembly
   INX 	EAX   	; increment eax
   LOOP 	Label		; decrement ECX, loop if not 0
</code></pre><p>不太常见的操作码可实现字符串操作，重复指令前缀，端口I / O指令，标志设置/清除/测试，浮点操作（通常以F开头，并支持move from一个整数、move to一个整数，算术，比较，先验，代数移入/移出）以及控制功能），用于多线程和性能问题的缓存和内存操作码等。英特尔®64和IA-32体系结构软件开发人员手册第2卷分为两部分，详细介绍了每个操作码。</p><h2 id=操作系统>操作系统 <a href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f class=anchor aria-hidden=true>#</a><a href=#操作系统 class=anchor aria-hidden=true>#</a></h2><p>从理论上讲，64位系统允许寻址2^64字节的数据，但是当前没有芯片允许访问所有16 EB字节（18,446,744,073,709,551,616字节）。例如，AMD体系结构仅使用地址的低48位，并且48至63位必须是47位的副本，否则处理器会引发异常。因此，地址为0到00007FFFFFFFFFFF，从FFFF800000000000到FFFFFFFFFFFFFFFF，总共有256 TB（281,474,976,710,656字节）的可用虚拟地址空间。另一个缺点是，要寻址所有64位内存，需要更多的页表供OS存储，需要使用宝贵的内存。请注意，这些是虚拟地址，而不是物理地址。</p><p>结果，许多操作系统使用此空间的上半部分，从顶部开始，然后向下扩展；而用户程序则使用下半部分，从底部开始，然后向上扩展。当前的Windows *版本使用44位寻址（16 TB = 17,592,186,044,416字节）。结果地址如下图所示。由于地址是由OS分配的，因此结果地址对用户程序而言不太重要，但是用户地址和内核地址之间的区别对于调试很有用。</p><p><img src=https://software.intel.com/content/dam/develop/external/us/en/images/29530-figure-2-181178.jpg alt=内存寻址></p><p>最后一个与OS相关的问题与多线程编程有关，但是此主题太大，无法在此处讨论。唯一要提到的是，有内存屏障操作码可帮助保护共享资源不受破坏。</p><h2 id=调用约定>调用约定 <a href=#%e8%b0%83%e7%94%a8%e7%ba%a6%e5%ae%9a class=anchor aria-hidden=true>#</a><a href=#调用约定 class=anchor aria-hidden=true>#</a></h2><p>每种架构都有自己的例程（函数）调用的一些约束，操作系统与对应架构的CPU打交道都必须要考虑如何传递对应的参数、如何获取返回值的问题，这里的具体到某个平台的约束，就称为调用约定。</p><p>常见的x64调用约定是用于C样式函数调用的Microsoft 64调用约定（请参阅MSDN，Chen和Pietrek）。在Linux下，也将其称为应用程序二进制接口（ABI）。</p><p>请注意，此处涉及的调用约定与x64 Linux系统上使用的约定不同：对于Microsoft x64调用约定，附加的寄存器空间使fastcall成为唯一的调用约定（在x86下有很多：stdcall，thiscall，fastcall，cdecl等）。与C / C ++样式函数接口的规则：</p><ul><li>RCX, RDX, R8, R9 are used for integer and pointer arguments in that order left to right.</li><li>XMM0, 1, 2, and 3 are used for floating point arguments.</li><li>Additional arguments are pushed on the stack left to right.</li><li>Parameters less than 64 bits long are not zero extended; the high bits contain garbage.</li><li>It is the caller&rsquo;s responsibility to allocate 32 bytes of &ldquo;shadow space&rdquo; (for storing RCX, RDX, R8, and R9 if needed) before calling the function.</li><li>It is the caller&rsquo;s responsibility to clean the stack after the call.</li><li>Integer return values (similar to x86) are returned in RAX if 64 bits or less.</li><li>Floating point return values are returned in XMM0.</li><li>Larger return values (structs) have space allocated on the stack by the caller, and RCX then contains a pointer to the return space when the callee is called. Register usage for integer parameters is then pushed one to the right. RAX returns this address to the caller.</li><li>The stack is 16-byte aligned. The &ldquo;call&rdquo; instruction pushes an 8-byte return value, so the all non-leaf functions must adjust the stack by a value of the form 16n+8 when allocating stack space.</li><li>Registers RAX, RCX, RDX, R8, R9, R10, and R11 are considered volatile and must be considered destroyed on function calls.</li><li>RBX, RBP, RDI, RSI, R12, R14, R14, and R15 must be saved in any function using them.</li><li>Note there is no calling convention for the floating point (and thus MMX) registers.</li><li>Further details (varargs, exception handling, stack unwinding) are at Microsoft&rsquo;s site.</li></ul><p>我们再看下Linux man手册，这里整理了两张调用约定相关的表: https://man7.org/linux/man-pages/man2/syscall.2.html，读后可以加深我们对调用约定 or ABI的认识。</p><pre><code>
## 示例

### MessageBox

前面讲这么多，现在用上面讲过的内容来写一个demo展示下x64汇编的使用，第一个demo是一个x64独立可运行的程序，运行之后会弹出一个Windows MessageBox。

```asm
; Sample x64 Assembly Program
; Chris Lomont 2009 www.lomont.org
extrn ExitProcess: PROC   ; external functions in system libraries
extrn MessageBoxA: PROC
.data
caption db '64-bit hello!', 0
message db 'Hello World!', 0
.code
Start PROC
  sub    rsp,28h      ; shadow space, aligns stack
  mov    rcx, 0       ; hWnd = HWND_DESKTOP
  lea    rdx, message ; LPCSTR lpText
  lea    r8,  caption ; LPCSTR lpCaption
  mov    r9d, 0       ; uType = MB_OK
  call   MessageBoxA  ; call MessageBox API function
  mov    ecx, eax     ; uExitCode = MessageBox(...)
  call ExitProcess
Start ENDP
End
</code></pre><p>将上述汇编程序保存为hello.asm，然后使用ML64进行编译，在Microsoft Windows x64 SDK中有这个程序的，这么编译：</p><pre><code class=language-bash> ml64 hello.asm /link /subsystem:windows /defaultlib:kernel32.lib /defaultlib:user32.lib /entry:Start
</code></pre><p>执行完成后会构建出一个可执行程序（已经链接好库函数、启动代码了），运行这个程序hello.exe，就会看到弹出一个消息窗口。</p><h3 id=heading><a href=#heading class=anchor aria-hidden=true>#</a><a href=#heading class=anchor aria-hidden=true>#</a></h3><p>第二个示例，是在Visual Studio 2008这个IDE中，在C/C++文件中引用一个x64汇编文件中的代码，还记得Visual Studio后续删除了对支持内联汇编的支持吧。好。</p><ul><li>Create a new empty C++ console project. Create a function you&rsquo;d like to port to assembly, and call it from main.</li><li>To change the default 32-bit build, select Build/Configuration Manager.</li><li>Under Active Platform, select New&mldr;</li><li>Under Platform, select x64. If it does not appear figure out how to add the 64-bit SDK tools and repeat.</li><li>Compile and step into the code. Look under Debug/Windows/Disassembly to see the resulting code and interface needed for your assembly function.</li><li>Create an assembly file, and add it to the project. It defaults to a 32 bit assembler which is fine.</li><li>Open the assembly file properties, select all configurations, and edit the custom build step.</li><li>Put command line<pre><code class=language-bash>ml64.exe /DWIN_X64 /Zi /c /Cp /Fl /Fo $(IntDir)\$(InputName).obj $(InputName).asm j:w
</code></pre></li></ul><p>ok，下面开始，我们先写一个c++文件，如下，main里面会调用两个函数CombineC、CombineA先后打印出计算的结果，实际上我们准备让CombineA和CombineC实现完全一致的逻辑，区别就是CombineA是在外部的汇编文件中实现的。</p><pre><code class=language-c>// C++ code to demonstrate x64 assembly file linking
#include &lt;iostream&gt;
using namespace std;
double CombineC(int a, int b, int c, int d, int e, double f)
{
     return (a+b+c+d+e)/(f+1.5);
}

// NOTE: 这里必须加上extern &quot;C&quot;来阻止C++ name mangling，否则连接的时候会出现符号解析错误
extern &quot;C&quot; double CombineA(int a, int b, int c, int d, int e, double f);

int main(void)
{
     cout &lt;&lt; &quot;CombineC: &quot; &lt;&lt; CombineC(1,2,3,4, 5, 6.1) &lt;&lt; endl;
     cout &lt;&lt; &quot;CombineA: &quot; &lt;&lt; CombineA(1,2,3,4, 5, 6.1) &lt;&lt; endl;
     return 0;
}
</code></pre><p>好的，下面继续写汇编文件：</p><p>file: CombineA.asm</p><pre><code>.code
PUBLIC CombineA
CombineA PROC
   ADD    ECX, DWORD PTR [RSP+28H] ; add overflow parameter to first parameter
   ADD    ECX, R9D                 ; add other three register parameters
   ADD    ECX, R8D                 ;
   ADD    ECX, EDX                 ;
   MOVD   XMM0, ECX                ; move doubleword ECX into XMM0
   CVTDQ2PD  XMM0, XMM0            ; convert doubleword to floating point
   MOVSD  XMM1, realVal            ; load 1.5
   ADDSD  XMM1, MMWORD PTR [RSP+30H]  ; add parameter
   DIVSD  XMM0, XMM1               ; do division, answer in xmm0
   RET                             ; return
CombineA ENDP
End
</code></pre><p>编译并运行上述程序，会发现输出了两次1.97368，第一次是CombineC的运算结果，第二次就是汇编实现的CombineA的运算结果</p><h2 id=总结>总结 <a href=#%e6%80%bb%e7%bb%93 class=anchor aria-hidden=true>#</a><a href=#总结 class=anchor aria-hidden=true>#</a></h2><p>这是对x64汇编编程的必要的简要介绍。下一步是浏览《英特尔®64和IA-32架构软件开发人员手册》。第1卷包含体系结构的详细信息，如果您知道汇编的话，这是一个很好的开始。其他地方是汇编书籍或在线汇编教程。为了了解代码的执行方式，指导您在调试器中逐步执行代码，查看反汇编，直到您可以阅读汇编代码以及您喜欢的语言为止，这对您很有帮助。对于C / C ++编译器，调试版本比发行版本更容易阅读，因此请确保从此处开始。最后，阅读masm32.com上的论坛以获取大量材料。</p><h2 id=参考内容>参考内容 <a href=#%e5%8f%82%e8%80%83%e5%86%85%e5%ae%b9 class=anchor aria-hidden=true>#</a><a href=#参考内容 class=anchor aria-hidden=true>#</a></h2><ul><li>原文地址: https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html</li><li>NASM: http://www.nasm.us/</li><li>YASM: http://www.tortall.net/projects/yasm/</li><li>Flat Assembler (FASM): http://www.flatassembler.net/</li><li>&ldquo;Intel® 64 and IA-32 Architectures Software Developer&rsquo;s Manuals,&rdquo; available online at http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</li><li>&ldquo;Compiler Intrinsics&rdquo;, available online at http://msdn.microsoft.com/en-us/library/26td21ds.aspx</li><li>Matt Pietrek, &ldquo;Everything You Need To Know To Start Programming 64-Bit Windows Systems&rdquo;, available online at http://msdn.microsoft.com/en-us/magazine/cc300794.aspx, 2009.</li><li>Intel® 64 and IA-32 Architectures Software Developer Manuals</li></ul><div class=edit-page><a href=https://github.com/hitzhangjie/myspace/blob/master/content/blog/2020-08-20-x64%e6%b1%87%e7%bc%96%e5%bc%80%e5%8f%91%e4%bb%8b%e7%bb%8d.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div><div class="docs-navigation d-flex justify-content-between"><a href=/blog/2020-08-23-monkey_patching_in_go/><div class="card my-1"><div class="card-body py-2">&larr; Monkey Patching in Go</div></div></a><a class=ms-auto href=/blog/2020-08-19-go%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E6%B5%8B%E8%AF%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/><div class="card my-1"><div class="card-body py-2">选择合适的测试框架 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div><div class=col-lg-8 align=right><p><font size=-1>站点构建版本：v</font></p></div></div></div></footer><script src=/js/bootstrap.min.fdbe9b9ba88a036135318f3c721784d684ac9e3280fe282cc80d7d49f7f9c82780cd54228c1608685a230c09984300d7946fc471734d566fcebc148b65bd16db.js integrity="sha512-/b6bm6iKA2E1MY88cheE1oSsnjKA/igsyA19Sff5yCeAzVQijBYIaFojDAmYQwDXlG/EcXNNVm/OvBSLZb0W2w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.b64f1e7517e5839396950ceee4ef937fbbd3ff20aa1fdd261ce87fa457863404f35a6e5239dd57b20b37f39c2401b933deeef60af180195b16941c88f10e948d.js integrity="sha512-tk8edRflg5OWlQzu5O+Tf7vT/yCqH90mHOh/pFeGNATzWm5SOd1Xsgs385wkAbkz3u72CvGAGVsWlByI8Q6UjQ==" crossorigin=anonymous defer></script>
<script src=/main.min.f16ffd9b364013a1df84be9cd7a45c470cb48639766bf5551e05bba845fe4ab150cb6436de43609bfed9af47c23bd5e395e9a10b932fa6fb2c4ee8f6cc78d7a3.js integrity="sha512-8W/9mzZAE6HfhL6c16RcRwy0hjl2a/VVHgW7qEX+SrFQy2Q23kNgm/7Zr0fCO9XjlemhC5MvpvssTuj2zHjXow==" crossorigin=anonymous defer></script>
<script src=/index.min.4f5da6d5d5039814b7640914dc6d7af9b1826b54a2e8027123e345920f33e3dab6f98ed3b275444c8e3ce3de9faa12475d34fad04a0140d0a99b28e75bc5267c.js integrity="sha512-T12m1dUDmBS3ZAkU3G16+bGCa1Si6AJxI+NFkg8z49q2+Y7TsnVETI48496fqhJHXTT60EoBQNCpmyjnW8UmfA==" crossorigin=anonymous defer></script></body></html>