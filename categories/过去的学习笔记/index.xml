<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>过去的学习笔记 on</title><link>/categories/%E8%BF%87%E5%8E%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><description>Recent content in 过去的学习笔记 on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 03 Jan 2019 16:07:00 +0800</lastBuildDate><atom:link href="/categories/%E8%BF%87%E5%8E%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>设计工具Mermaid</title><link>/blog/2019-01-03-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7mermaid/</link><pubDate>Thu, 03 Jan 2019 16:07:00 +0800</pubDate><guid>/blog/2019-01-03-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7mermaid/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Mermaid语法和使用，用以在markdown文档中绘制各类图表。
Mermaid # 1 Flow Chart # graph LR A[Hard edge] --&amp;gt;B(Round edge) B --&amp;gt; C{Decision} C --&amp;gt;|One| D[Result one] C --&amp;gt;|Two| E[Result two] 2 Sequence Diagram # sequenceDiagram participant Alice participant Bob Alice-&amp;gt;&amp;gt;John: Hello John, how are you? loop Healthcheck John-&amp;gt;&amp;gt;John: Fight against hypochondria end Note right of John: Rational thoughts&amp;lt;br/&amp;gt;prevail... John--&amp;gt;&amp;gt;Alice: Great! John-&amp;gt;&amp;gt;Bob: How about you? Bob--&amp;gt;&amp;gt;John: Jolly good! 3 Gantt Diagram # gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 4 Class Diagram # classDiagram Class01 &amp;lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .</description></item><item><title>gdb调试常用操作</title><link>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sun, 28 May 2017 23:56:48 +0800</pubDate><guid>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是gdb调试的常用操作。
### execute and trace step by step help &amp;lt;topic/cmd&amp;gt; list list - : list lines before last printed list + : list lines after last printed list 3 list 3,7 list filename:3,7 list function list filename:function list *address n/ni/next : next s/si/step : next exactly rni : reverse ni, see also mozilla rr sni : reverse si, see also mozilla rr r/run start finish : finish current function bt/backtrace : look stack frame and parameters f/frame 2 : select stack frame i/info locals : show local vars p/print var/expression : print var value set var varname=value ### breakpoints display var undisplay varNum b/break lineNum/function b/break lineNum/function [if expression] delete breakpoints : delete all breakpoints delete breakpoints bpNum : delete specified breakpoint disable breakpoints bpNum enable breakpoints bpNum c/continue info breakpoints ### watchpoints x/7b baseAddress : print mem data watch varName/expression i/info watchpoints ### backtrace segmentation faults generally are caused by addresses of memory spaces.</description></item><item><title>Linux桌面发行版分享</title><link>/blog/2016-05-07-linux%E6%A1%8C%E9%9D%A2%E5%8F%91%E8%A1%8C%E7%89%88%E4%BD%93%E9%AA%8C/</link><pubDate>Sat, 07 May 2016 00:23:47 +0800</pubDate><guid>/blog/2016-05-07-linux%E6%A1%8C%E9%9D%A2%E5%8F%91%E8%A1%8C%E7%89%88%E4%BD%93%E9%AA%8C/</guid><description>Linux桌面发行版分享 # 这是一篇写在2016年的文章一直在我的个人笔记里，感觉当时很多想法今天依然成立，所 以拿出来继续分享下。某些信息可能已经有过时，相关的部分我在备注里进行了标注，
0.体验Linux发行版 # 今天安装了Ubuntu 16.04 LTS，本来准备一直用Fedora的，但是我的笔记本上安装的还是 Fedora 21版本，但是当前最新的已经更新到了Fedora 24,今天刚刚发布了Beta版本。此 前我对Fedora 23 GA以及Fedora 24 Alpha版本进行了简单的测试，实在是不喜欢KDE 5！
怎么说呢，其实看上去KDE 5挺漂亮的，应该将来也会有不错的发展，但是考虑到KDE 5刚 出来的时间还不够长，其中很多在KDE 4里面方便实用的功能在KDE 5中还没有被开发出来 ，而我又是一个倾向于“工欲善其事，必先利其器”的同学，让我这样把一个未充分完善好 的桌面环境当做自己的主力系统，我实在难以接受！对于GNOME 3，我就不做任何评论了 ，我宁可用Ubuntu Unity也不用GNOME 3！
可能有人说，没必要一直跟着更新啊，继续实用Fedora 21也可以啊！？此话当然不假， 可是一个失去后续更新支持的版本，我想还是要继续跟进新版本要更好。其实我现在配置 的已经相当棒了，有的软件源里面的程序存在某些小问题，瑕不掩瑜的，我也对其源代码 进行了部分修改，以为自己所用，因为这部分工作还是相当多、相当细的，如果继续跟进 新的发行版，而软件源里面的软件包可能还没有修改过来，或者不符合我的需要，又要进 行重复性的工作，我觉得这个工作量还是蛮大的，至少现在我没有那么充足的时间。
Fedora发行版每6个月更新一次，CentOS 7可以支持10年，我本来也计划使用CentOS的， 但是CentOS对稳定性的追求，也使得很多软件包不能被加入其软件源，有些我很喜欢的工 具，安装、配置起来就会比较麻烦，dpkg、alien、rpmrebuild甚至修改源代码这些可能 都要用到，以配置出一个趁手的系统环境。半年前，我在另一台三星的笔记本安装了 CentOS 7，配置完成之后，堪称完美，那个时候时间多啊，折腾的时间也挺长的；现在时 间没有那么充裕了，我在这台thinkpad上安装了CentOS 7.2，前后也就折腾了一天，不打 算折腾了。
最后，我选择了Ubuntu 16.04 LTS版本，可以支持5年，而我本身也想重新比较一下 Ubuntu、Fedora这两大发行版，为什么呢？因为对这两款发行版，我都有向当长的使用时 间，现在也积累了很多的经验，前不久我碰巧又看到了一个各大发行版性能对比的文章， 其中Debian系列的性能要明显优于RHEL系列，原因我暂时也不是特别清楚，这也是激发我 重新选择Ubuntu的原因之一。我希望在使用过程中，重新比较一下Ubuntu和Fedora这两大 发行版的差异，例如包管理工具的差异、软件包中的配置文件的差异、系统管理方面的差 异，此外呢，我也希望能够对其性能上的差异进行一下更深的认识。
1.系统安装过程 # 系统安装过程，应该说是驾轻就熟了，下载一个Ubuntu 16.04 LTS的ISO文件，然后使用 Unetbootin制作一个可以引导系统安装的U盘。U盘要格式化成FAT32格式，且要根据需要 预留一定的存储空间，以供安装过程中释放文件使用，如果预留空间不足，可能导致安装 失败。
制作完成安装U盘之后，插入电脑，关闭BIOS中的UEFI引导模式，然后从USB HDD启动安装 即可。安装的时候手动分区，最好能够把那些第三方软件包给安装上，这样省的后续安装 ，省心。我是深有体会，之前安装音频、视频播放器的时候，安装解码库浪费了很多时间 。安装过程中有个别地方需要设置一下，例如用户名、密码、语言、地区、时间等等的。
注意，Ubuntu在安装过程中不会对root用户的密码进行设置，并且默认将新建的用户加入 wheel组中！但是在Fedora安装过程中，会对root密码进行设置，然后再创建一个新用户 ，并允许选择是否将该用户加入wheel组中，还可以指定uid、gid等。这是一个区别，需 要注意一下，安装完成之后，需要通过“passwd root”对密码进行重新设定。</description></item><item><title>Linux内核文档索引</title><link>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</link><pubDate>Fri, 24 Oct 2014 00:10:00 +0800</pubDate><guid>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。
============================================================================= Fri Sep 18 12:23:06 CST 2014 # Documentation/
[1] zorro.txt zorro bus ii\iiioZorro II is the name of the general purpose expansion bus used by the Amiga 2000 computer. The bus is mainly a buffered extension of the Motorola 68000 bus, with support for bus mastering DMA. The expansion slots use a 100-pin connector and the card form factor is the same as the IBM PC. Zorro II cards implement the Autoconfig protocol for automatic address space assignment (designed before, yet similar to, Plug and Play on the PC).</description></item><item><title>Linux内联汇编基础</title><link>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 01 Oct 2014 00:16:34 +0800</pubDate><guid>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是阅读内核源码《Linux内核源码情景分析》时对内联汇编的一些总结。
1.full template __asm__(assembler template :output operands /* optional */ :input operands /* optional */ :list of clobbered registers /* optional */ ); 2.x86 registers eax,ebx,ecx,edx edi,esi ebp,esp eip eflags 3.linux代码中很多地方都使用了这种形式的汇编语言，嵌入汇编程序的格式如下： __asm__ __volatile__ ( asm statements : outputs : inputs : registers-modified ); asm statements是一组AT&amp;amp;T格式的汇编语言语句，每个语句一行，由\n分隔各行。所有的语句都被包裹在一对双引号内。其中使用的寄存器前面要加两个%%做前缀(%n表示参数,n:数字)；转移指令多是局部转移，因此多使用数字标号。 inputs指明程序的输入参数，每个输入参数都括在一对圆括号内，各参数用逗号分开。每个参数前加一个用双引号括起来的标志，告诉编译器把该参数装入到何处。 可用的标志有： “g”：让编译器决定如何装入它； “a”：装入到ax/eax； “b”：装入到bx/ebx； “c”：装入到cx/ecx； “d”：装入到dx/edx； “D”：装入到di/edi； “S”：装入到si/esi； “q”：a、b、c、d寄存器等； “r”：任一通用寄存器； “i”：整立即数； “I”：0-31 之间的立即数（用于32位移位指令）； “J”：0-63 之间的立即数（用于64 位移位指令）； “N”：0-255 ，之间的立即数（用于out 指令）； “n”：立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”； “p”：有效内存地址； “m”：内存变量； “o”：操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址； “V”：操作数为内存变量，但寻址方式不是偏移量类型； “,”：操作数为内存变量，但寻址方式为自动增量； “X”：操作数可以是任何类型； “f”：浮点数； “t”：第一个浮点寄存器； “u”：第二个浮点寄存器； “G”：标准的80387； % ：浮点常数,该操作数可以和下一个操作数交换位置； “=”：输出； “+”：既是输入又是输出； “&amp;amp;”：改变其值之前写,分配一个独立的寄存器,使得函数返回值和该变量不因为重复使用同一个寄存器,出现数据覆盖； “%”：与下一个操作数之间可互换； “#”：忽略其后的字符，直到逗号； “*”：当优先选择寄存器时，忽略下面的字符； “0”~“9”：指定一个操作数，它既做输入又做输出。通常用“g”； outputs指明程序的输出位置，通常是变量。每个输出变量都括在一对圆括号内，各个输出变量间用逗号隔开。每个输出变量前加一个标志，告诉编译器从何处输出。 可用的标志与输入参数用的标志相同，只是前面加“=”。如“=g”。输出操作数必须是左值，而且必须是只写的。如果一个操作数即做输出又做输 入，那么必须将它们分开：一个只写操作数，一个输入操作数。输入操作数前加一个数字限制（0~9），指出输出操作数的序号，告诉编译器它们必须在同一个物 理位置。两个操作数可以是同一个表达式，也可以是不同的表达式。 registers-modified告诉编译器程序中将要修改的寄存器。每个寄存器都用双引号括起来，并用逗号隔开。如“ax”。如果汇编程 序中引用了某个特定的硬件寄存器，就应该在此处列出这些寄存器，以告诉编译器这些寄存器的值被改变了。如果汇编程序中用某种不可预测的方式修改了内存，应 该在此处加上“memory”。这样以来，在整个汇编程序中，编译器就不会把它的值缓存在寄存器中了。 如: “cc”：你使用的指令会改变CPU的条件寄存器cc； “memory”：你使用的指令会修改内存； __volatile__是可选的，它防止编译器修改该段汇编语句（重排序、重组、删除等）。 输入参数和输出变量按顺序编号，先输出后输入，编号从0开始。程序中用编号代表输入参数和输出变量（加%做前缀）。 输入、输出、寄存器部分都可有可无。如有，顺序不能变；如无，应保留“：”，除非不引起二意性。 看一个在C语言中使用at&amp;amp;t的嵌入汇编程序的例子，c语言中的3个int变量，一般会是三个内存地址。每个操作数的长度则要根据操作系统和编译器来决定，一般32位操作系统为32位，则每个操作数占用4个字节： int i=0, j=1, k=0; __asm__ __volatile__(&amp;quot; pushl %%eax\n //asm statement movl %1, %%eax\n //asm statement addl %2, %%eax\n //asm statement movl %%eax, %0\n //.</description></item><item><title>C++核心知识点总结</title><link>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2014 08:00:00 +0800</pubDate><guid>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是C++编程里的一些知识要点。
============================================================================= Sun Sep 7 16:50:05 CST 2014 ============================================================================= 为了开启c++11的某些特性，需要在g++编译时添加参数：-std=c++0x。 c++语言里面，除了char类型被明确规定为占1个字节之外，其他的数据类型都没有指定其 具体的尺寸，这样做的原因是，在不同的编译器实现中，编译器会根据运行平台的特点， 自动为各个类型指定所占用的字节数，以使得编译后的程序能够尽可能适应运行平台。这 样做的好处是，使得编写的c++程序，不仅能够适应现在的机器结构，也能适应将来的机 器结构，实在是高明！ c++11标准中变量的初始化方式有3种，这3中初始化方式是等价的： type varname = varvalue; type varname (varvalue); type varname {varvalue}; auto varname = varvalue; 变量auto会根据初始化时初值varvalue的类新，自动指定varname的类型； decltype(varname)可以获取变量varname的类型，例如可以这样使用： newvar； 这样变量newvar与新变量oldvar是相同的类型，decltype主要是用于模板中根据模板参数 的类型创建其他相同变量。 c++中有专门的字符串类string，需要包含头文件string。 cout输出时追加endl的作用不仅仅是输出换行符，考虑一下缓冲机制就明白了，在终端中 ，缓冲一般是采用行缓冲，因此在cout中追加endl不仅输出了换行符，还进行了行缓冲， 从而确保信息被输出到cout上。 如果在通过cout输出某些信息时不在末尾追加endl，如果输出信息中没有换行符做结尾， 那么信息就不会输出到终端上，因为终端采用行缓冲，不碰到换行符或者待输出信息没有 超过缓冲区的长度，信息不会被输出到终端上。 std::cout，std是一个命名空间，c++标准库中的所有东西都包含在std这个命名空间中， cout指定了设备是输出设备，c++中常用的cin\cout\cerr就等效于c中的 stdin\stdout\stderr。 常量类型 整型常量，常用的包括十进制、八进制、十六进制，分别如123,0234,0xffff；整型常量 可以在末尾追加合适的字符表示该常量应该用什么类型进行存储： u/U表示unsigned； l/L表示long； ll/LL表示long long； 浮点常量，常用的包括float、double、long double，浮点常量的形式包括3.1415、 3.14e23，其中e表示10的多少次方，浮点常量默认是用一个double类型进行存储，也可以 在浮点常量的末尾追加字符表示使用什么类型进行存储，例如： f/F表示float类型； l/L表示long double类型； 什么都不加，即采用默认的double类型； 在c++ shell中的测试结果显示，double表示8字节，long double表示16字节，这个跟编 译器有关。 字符常量、字符串常量'x',&amp;quot;xxxxx&amp;quot;，注意一些特殊的转义字符，例如： \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \a alert (beep) \' single quote (') \&amp;quot; double quote (&amp;quot;) \?</description></item><item><title>Unix环境高级编程</title><link>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 11 Jun 2014 08:00:00 +0800</pubDate><guid>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Unix环境高级编程里的一些知识要点。
# Advanced Programming in Unix Environment ############################################################################ Mon Jun 9 09:22:41 CST 2014 ############################################################################ M1 Unix基础知识 1. man man 1)user commands 2)system calls 3)c library functions 4)devices and special files 5)file formats and conventions 6)games 7)miscellanea 8)system admistration tools and daemons 2. c return values 1)return 0, 正常结束 2)return 1-255，表示错误代码 3. 工作目录 char *getcwd(char *buf, size_t size); int chdir(char *path); 4. libc与glibc的关系 libc是泛指c库，glibc是gnu组织对libc的一种实现，是unix、linux的根基，微软也有自 己对libc的实现，叫msvcrt。 5. read system call return 0, 表示到达了文件的结尾。 6.</description></item><item><title>TCP/IP网络安全篇</title><link>/blog/2013-09-30-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8tcpipnetworksecurity/</link><pubDate>Mon, 30 Sep 2013 02:08:29 +0800</pubDate><guid>/blog/2013-09-30-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8tcpipnetworksecurity/</guid><description>《TCP/IP 网络安全篇》，作者是日本的寺田真敏 萱岛 信。
感谢作者理论与实践结合的教学方式，简单地介绍了网络安全的方方面面，让 我学起来也是很有兴趣，真诚地向寺田真敏先生道一声谢谢。
下面是我对本书学习过程中的一个总结，难免有理解偏差之处，还需在以后的 学习实践过程中，进一步体会、纠正。
1 TCP/IP的基础知识 # 1.1 TCP/IP与因特网 # OSI 7-layer model
Host layers: applications Message presentation session -------------------------- transport Message segment -------------------------- media layer: network packet/datagram -------------------------- data link frame -------------------------- physical bit 用于分组交换的设备，IMP（Interface Message Processor）接口报文处理机 的第一号机被设计制成。
TCP/IP协议，是以tcp协议和ip协议为中心，构成的协议族的总称。 TCP/IP协议，从最底层开始，是由网络接口层、网络层、传输层、应用层构成。 像这样的构成层次，可以使开发工作形成模块式开发。
1.2 IP # IP地址与网络分类 # IP数据包的数据最大长度为65535字节。
IP地址由网络号与主机号组成。可以类对网络进行划分，根据网络的规模，从 A类到C类，也存在用于多播通信的D类，其他用于实验的地址还有E类。
但是在目前，为了有效利用已经濒临枯竭的IPv4地址，采用了不依赖于类的IP 地址分配方法——CIDR（Classless Inter Domain Routing，无类域间路由）。 而且为了解决IPv4地址的资源枯竭问题，也开发了具有128位长度的IPv6。
无类域间路由CIDR # 无类域间路由中关键的就是子网掩码。子网掩码，是为了改变网络号与主机号的分界位置而采用的方法，如192.168.0.0/24，表示网络号24位，主机号8位，这个子网掩码设置就比之前分类的方式要灵活多了。
特殊的IP地址: 1)本地环路地址:linux下常见的回环接口lo，地址127.0.0.1，其ip地址可以 根据需要任意设定，也称为localhost。常被用于同一计算机上的通信。 2)广播地址:主机号字段全部为1。 3)多播地址:224.0.0.0～239.255.255.255,常被用于特定工作组中的通信。 4)私有IP地址:限定于内部网络使用而分配的地址，rfc1597中，建议使用以下 的地址段: A类中，10.</description></item><item><title>Linux系统最佳实践 - 命令行技术</title><link>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</link><pubDate>Thu, 21 Jun 2012 08:00:00 +0800</pubDate><guid>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是《Linux系统最佳实践工具-命令行技术》里的一些知识要点。
# 《Linux系统最佳实践》学习笔记 &amp;gt; 参考书目： 《Linux 系统最佳实践工具 —— 命令行技术 》 &amp;gt; 本文撰写： 张 杰 &amp;gt; 截至日期： 2012-6-21 &amp;gt; 总结 ： &amp;gt; 这是我在学习linux过程中，对本书重点内容的一点总结。谈不上心得，只是一点总结，便于以后查阅。在理解/实践的基础上，回头看这些总结的内容会轻松许多。 &amp;gt; 如果你想从本文中获取到丁点帮助，恐怕你必须付出实践，必须肯花时间。 &amp;gt; 有句话叫做“纸上得来终觉浅，绝知此事要躬行”。如果想进步，想获得实质性的进步，必须付出实践。 &amp;gt; linux系统的强大之处不在于它的桌面环境，可能linux现在众多的发行版本中没有任何一款可以与微软抗衡。也许你觉得linux很酷，是的，它的确很酷。 &amp;gt; 它给予了你无穷尽的自由，从内核到桌面，每一个使用linux的人都从中尝到了甜头。但是说真的，linux的“酷”不是靠桌面打下的口碑，这是我们都深知的。 &amp;gt; 当你学习过linux的命令行之后，也许，你才会大彻大悟，linux真是非一般的强悍。而这是windows望尘莫及的。 &amp;gt; 如果你渴望自由，如果你渴望高效，如果…… &amp;gt; 欢迎你加入linux大家庭中来！ # 第一章 Linux简介 ## 1.查看内核版本 uname -r，主版本号/次版本号/修订次数/编译次数 # 第二章 Linux文件系统及其相关处理命令 ## 1.file system - /:文件系统根目录 - /bin:最小系统所需要的命令，其中的文件都是可执行的 - /boot:包含一些启动文件 - /dev:接口设备文件目录 - /etc:系统配置文件所在目录,Editable Text Configuration - /home:用户的主目录 - /lib:库文件目录，例如在执行/bin，/sbin目录下的二进制命令文件时可能会调用的库文件 - /mnt:各项装置的文件系统挂载点，如/mnt/cdrom是光驱的挂载点 - /opt:可以在这里安装自定义软件包（较大的且固定的） - /proc:系统运行时，进程信息以及内核信息（cpu/disk/memory等）都存放在这里。它是一个伪文件系统，存在于内存中，而非硬盘中，通过这个虚拟的文件系统可以在系统运行时调整内核参数，改变内核行为。不用重新启动查看cmos，即可查看系统信息。 - /root:管理员的主目录 - /sbin:目录sbin下的程序都是root权限才可以执行的 - /tmp:存放暂存盘的目录 - /usr:这是系统存放程序的目录，比如命令/配置文件等。当我们安装一个linux发行版提供提供的软件包时，大多安装在这里。这个目录下包含字体文件目录/usr/share/fonts,帮助目录/usr/share/man,/usr/share/doc，普通用户可执行目录/usr/bin,/usr/local/bin,/usr/X11R6/bin,超级用户可执行命令目录/usr/sbin,usr/X11R6/sbin,/usr/local/sbin等。还包含程序的头文件目录/usr/include。 ## 2.</description></item><item><title>Linux系统使用杂谈 - 经验技巧</title><link>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 01 Jan 2012 10:25:37 +0800</pubDate><guid>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是日常使用Linux发行版过程中遇到的问题及解决办法。
/* vim: set ft=text: */ ############################################################################## config codeblocks for wxwidgets if you want to compile and link wxwidgets project,do as following: compiler and debugger--&amp;gt;compiler settings--&amp;gt;other options: add `wx-config --cflags` compiler and debugger--&amp;gt;linker settings--&amp;gt;other options: add `wx-config --libs` note: if you want to build normal c/c++ project rather than wxwidgets projects, you must remove `wx-config --cflags` and `wx-config --libs`. a better choice is to set the target project's properties including compiler and linker options where you can set `wx-config --cflags` and `wx-config --libs`.</description></item></channel></rss>