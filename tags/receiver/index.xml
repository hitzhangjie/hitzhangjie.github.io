<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>receiver on</title><link>/tags/receiver/</link><description>Recent content in receiver on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 21 May 2018 12:33:23 +0800</lastBuildDate><atom:link href="/tags/receiver/index.xml" rel="self" type="application/rss+xml"/><item><title>golang method receiver-type的梗</title><link>/blog/2018-05-21-golang-method-receiver-type%E7%9A%84%E6%A2%97/</link><pubDate>Mon, 21 May 2018 12:33:23 +0800</pubDate><guid>/blog/2018-05-21-golang-method-receiver-type%E7%9A%84%E6%A2%97/</guid><description>这里来聊聊method receiver type为什么不能是pointer和interface类型。
1 receiver-type必须满足的条件 # golang里面提供了一定的面向对象支持，比如我们可以为类型T或者*T定义成员方法（类型T称为成员方法的receiver-type），但是这里的类型T必须满足如下几个条件：
T必须是已经定义过的类型； T与当前方法定义必须在同一个package下面； T不能是指针； T不能是接口类型； 前面两点都比较容易理解，下面两点是什么梗？为什么就不能在指针类型上添加方法？为什么就不能在interface上添加方法？当然可以一句话待过，golang不支持，但是我想问下为什么？
2 receiver-type为什么不能是指针类型？ # golang允许为 类型指针*T 添加方法，但是不允许为 指针类型本身 添加方法。按现有golang的实现方式，为指针类型添加方法会导致方法调用时的歧义。
看下面这个示例程序。
type T int func (t *T) Get() T { return *t + 1 } type P *T func (p P) Get() T { return *p + 2 } func F() { var v1 T var v2 = &amp;amp;v1 var v3 P = &amp;amp;v1 fmt.Println(v1.Get(), v2.Get(), v3.Get()) } 示例程序中 v3.</description></item></channel></rss>