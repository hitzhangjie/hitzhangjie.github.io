---
layout: post  
title: go源码剖析 - go命令  
date: 2020-09-28 22:18:43 +0800
tags: ["go", "toolchain"]
reward: true
---

## 1. 本文简介

首先我们看下go命令行有哪些功能，运行`go help`可以查看go命令的详细帮助信息，go命令有很多子命令，每个子命令有特定的功能。go命令功能之丰富涵盖了源文件编译、汇编、连接、反汇编、逃逸分析、代码生成、模块解析等等非常系统性的功能，了解go命令的实现将有助于系统性掌握整个go编译工具链。本文介绍下go命令的详细功能及大致实现，供后续参考。


## 2. go子命令列表

go支持的子命令列表如下，下面我们逐一来简单说下。

- bug, start a bug report
- build, compile packages and dependencies
- clean, remove object files and cached files
- doc, show documentation for package or symbol
- env, print Go environment information
- fix, update packages to use new APIs
- fmt, gofmt (reformat) package sources
- generate, generate Go files by processing source
- get, add dependencies to current module and install them
- install, compile and install packages and dependencies
- list, list packages or modules
- mod, module maintenance
- run, compile and run Go program
- test, test packages
- tool, run specified go tool
- version, print Go version
- vet, report likely mistakes in packages

## 3. go subcmds

### go bug

`go bug`，用于快速创建bug report。

作为开源项目的维护人员，非常希望开发人员“会”提问题！为什么这么说呢，就是因为如果不会提问题、问问题，沟通成本就会非常高，这对于开源项目维护人员来说，时间上是个极大的浪费。

在腾讯我也参与维护了好几个比较大型的开源项目，经常受到一些同学的问题，很多时候我真的感谢求学阶段长时间泡stackoverflow的经历，stackoverflow上教会了我怎么提问题，这个在我后面学习、沟通、检索、开源协同中起到了很重要的作用。

为了降低沟通成本，go bug内部定义了一个issue模板（其实github也支持定义模板），包括了几个部分：问题简述、go版本、go env信息、执行的操作、期望的结果、实际的结果。这里呢，为了保护go issuer的体验，go bug会自动获取go环境信息，填充到issue模板中，这里的内容将作为issue的body部分。

接下来会判断go issuer当前系统信息，并决定如何打开web浏览器，浏览器打开一个issue创建页面，通过GET参数填充issue的body，一个简单的issue基本信息就填充完成了。go issuer只需要填充下标题、问题简述、执行操作、期望结果、实际结果就创建完成了。

### go build

### go clean

我们在编译构建的过程中，一般都会生成一些临时文件，比如.o文件，如果是使用Makefile管理工程构建的时候一般会定义个PHONY Target clean，通过make clean来清理临时文件、目标文件、程序等，MVN构建也会定义clean这样的target，go也不例外。

`go build`，编译输出可执行程序，`go install`还会将可执行程序安装到GOBIN或者GOPATH/bin，那现在要清理的话，`go clean`会清理当前module下的编译产物，`go clean -i`还会把安装到GOBIN或者GOPATH/bin下安装的程序给清理掉，另外go modules之间也有依赖关系，`go clean -r`还可以递归地清理依赖产物。

举个例子，假如现在有个工程目录叫hello，那么在该工程目录下执行go clean，将清理目录下的下述文件：hello, hello.exe, hello.test, hello.test.exe, main, main.exe, main.test, main.test.exe。那假如hello目录下go.mod定义的module是a.b.c呢？会清理a.b.c, a.b.c.exe, a.b.c.test, a.b.c.test.exe吗？不会！但是go clean -i会从GOBIN或GOPATH/bin下清理这些文件。为啥？目前go clean就是这么实现的。

`go clean`之前实现的有bug，我稍微修改了下，实现了清理${module}, ${module}.exe的功能。

### go doc

`go doc` 可以用来显示指定package下的类型、函数、方法及其注释信息，其用法比较多，如`go doc`、`go doc pkg.symbol.fieldOrMethod`、`go doc pkg.Function`等等。

比如我们运行 `go doc os.Signal`，会显示如下信息：

```bash
package os // import "os"

type Signal interface {
	String() string
	Signal() // to distinguish from other Stringers
}
    A Signal represents an operating system signal. The usual underlying
    implementation is operating system-dependent: on Unix it is syscall.Signal.

var Interrupt Signal = syscall.SIGINT ...
```

从这里我们可以看到整个接口的定义，及其godoc注释信息，那么不禁要问，`go doc` 是如何准确找到这个符号os.Signal定义的呢？

如果之前有了解过`go/ast`的用法、用途之后，应该就不难理解了。我还写过一篇讲微服务代码逻辑可视化的文章，也是使用了go/ast：https://hitzhangjie.github.io/blog/2020-10-06-visualizing-your-go-code/。

`go doc`的逻辑其实很简单，它首先会将os.Signal split一下，发现是os这个package，然后是Signal这个符号，然后它就会根据build package提供的信息来定位到os对应的目录，然后通过`parser.ParseDir(...)`来对目录下go文件进行语法分析。分析完之后就将得到AST，然后再基于AST去查找符号Symbol的定义，比如这里是个类型定义，找到AST中对应的节点之后，再提取出注释信息。最后将这些信息格式化输出到stdout。

`go doc`大致就是这样实现的。

### go env

`go env` 命令用来查看、设置、取消设置go相关的一些环境变量。

我们知道`go env`会显示出一个环境变量列表，这里面这些环境变量名称都是go envCmd里面预定义好的，比如要设置一个不相干的变量名`go env -w xxx`是会报错的。

`go env` 列出的环境变量一般都有一个默认值，如`GOSUMDB=sum.golang.org`，但是我们有时候希望对齐进行调整，那么可以通过`go env -w GOSUMDB=off`来进行设置，如果要取消设置恢复到原来的默认设置，则可以执行`go env -u GOSUMDB`。

那这里不禁要问，用户手动设置的环境变量存储在哪里呢？其实是存储在环境变量`GOENV`对应的文件中，macOS下为`/Users/zhangjie/Library/Application Support/go`，linux下为`~/.config/go/env`，其实就是`os.UserConfigDir()+/go/env`路径下。当我们设置、取消设置的时候，会更新文件中的数据。

`go env`大致就是这么工作的。

### go fix

一门快速演进中的编程语言也会面临一些调整的时候，如果发生了变化，比如将golang.org/x/tools/net/context内容转移到标准库context中，可能已经存在一些存量代码了，或者说开发者已经习惯了使用老的import的包路径了，那怎么办呢？想让开发者付出最小的迁移成本而转到使用最新的标准库context上来。go fix就是干这个事情的。

fix命令执行的时候会检查当前支持那些修复操作，每一个修复操作都指定了要搜索的代码，以及要替换成的代码，比如上面提及的context包导入路径的问题。fix命令会首先解析源文件得到抽象语法树AST，然后基于对AST的操作，搜索出可以修复的问题代码，然后将其替换成对应的新代码，然后再将AST转换成代码输出到源文件中。

这大概就是go fix (go tool fix) 的一个执行过程，${GOROOT}/pkg/tool/darwin_amd64/下保存了go tool对应的一些工具，如fix，vet等，运行go vet, go fix就会最终转换成执行上述路径下的vet、fix命令。`go fix`的入口在${GOROOT}/src/cmd/go/fix/fix.go，实际调用的是`go tool fix`，其入口在`${GOROOT}/src/cmd/fix/main.go。

ps: `go fix`的内部实现，是基于go/ast实现，通过对源码进行语法分析构建ast，通过对ast进行查找、修改，完成对代码的调整，最后再将ast转换为源码输出。

### go fmt

### go generate

### go get

### go install

### go list

### go mod

### go run

### go test

### go tool

### go version

### go vet

## 4. 总结
