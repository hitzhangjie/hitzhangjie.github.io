---
layout: post
title: "Linux任务调度(4)"
description: "本文介绍下Linux调度器的演进过程，对其中有代表性的调度器实现进行分析总结。作为任务调度器系列文集中的一篇，本文重点介绍v2.6.23开始引入的CFS调度器，CFS调度器后续也进行了一系列的优化，包括支持组调度等，目前Linux内核已经来到了v6.0.0+，调度器实现依然是CFS。这个完全公平调度器是如何保证公平的呢？本文将一探究竟。"
date: 2023-11-16 18:59:05 +0800
tags: ["scheduler","cfs","fair","rsdl"]
categories: ["linux内核"]
toc: true
reward: true
---

### 演进过程

首先，再次回顾下下Linux进程调度器的一个发展历史：

- v0.01~v2.4.x: the very first scheduler，复杂度O(n)
- v2.6.0~v2.6.22: O(1) scheduler，复杂度O(1)
- v2.6.23~: Completely Fair Scheduler (CFS)，复杂度O(log(n))

前一篇文章中我们介绍了v0.01版本中的调度器实现，复杂度为O(n)，在v0.01内核实现中写死了最多可调度的任务数量，只能算作是一个toy！随着从v0.01~v2.4.x版本中的优化，能调度的任务数量也上来了，但是复杂度还是O(n)。

### CFS调度器

前面一篇文章介绍O(1)调度器时，提到它对交互式程序的奖惩算法是一个比较“魔性”的难以建模量化其质量的做法，代码也难以理解维护。不禁要问CFS调度器能解决这个问题吗？

#### 认识“楼梯调度器”

在CFS调度器出现之前，内核开发人员 Con Kolivas 提出了 Starecase Deadline，简称梯调度算法。我们简要介绍下RSDL的诞生及工作原理。

随着 2.6.0 版本的临近，一些开发人员担心 CPU 调度程序的问题会让这个稳定版本系列垮台。交互性能差、NUMA 系统支持不佳等等的抱怨很常见。随着时间的推移，大部分问题都已得到解决；大量的交互工作和域调度程序已经解决了大部分问题。近年来，有关调度程序的投诉相对较少。

然而，仍然困扰一些人的一件事是当前 2.6 调度程序的复杂性。尤其是交互性工作，添加了大量非常晦涩的代码。调度程序竭尽全力尝试识别交互式任务并相应地提高其优先级。这个过程涉及到许多奇怪的计算，涉及到许多魔法常数；很难理解，更不用说改进了。

**Con Kolivas 参与了大部分交互工作**，他刚刚发布了他的“楼梯调度程序”补丁的[新版本。](https://lwn.net/Articles/87244/)该补丁旨在大大简化调度程序，同时提高交互响应；它删除了 498 行代码，同时添加了不到 200 行代码。删除的大部分内容是“黑魔法”交互计算；它全部被一个相对简单的、基于等级的方案所取代。

阶梯调度程序为每个 CPU 设置一个多优先级运行队列。最初，每个进程按照其基本优先级确定的等级进入运行队列；然后调度程序可以以常见的方式找到并运行最高优先级的进程。到目前为止，没有太大变化。

在当前的O(1)调度程序中，用完其时间片的进程将被移至单独的“过期”运行队列（expire runqueue）；它们在那里萎靡不振，直到活跃运行队列（active runqueue）中的其余进程也用完它们的时间（或被阻塞），此时二者交换后才能被调度。

而楼梯调度程序中删除了过期的数组这个设计，过期的进程将被放回到楼梯中，但处于下一个较低的级别。因此，它可以继续运行，但优先级较低。当它耗尽另一个时间片时，它再次向下移动。等等。下面的小表显示了进程在每个优先级上花费的时间：



|       |            | 队列1 | 队列2 | ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...  |
| ----- | ---------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 迭代  | 初始优先级 | -1    | -2    | -3   | -4   | -5   | -6   | -7   | -8   | -9   | ...  |
| **1** | 1          | 1     | 1     | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |

当一个进程从楼梯底部掉下来时，会发生一件有趣的事情：它会移回比之前最大值低的一层，并在该层获得两个时间片。此后，它再次沿着台阶向下移动到底部。下一次，它会比最大值低两步，持续三个时间片。上表通过楼梯进行了 3 次迭代，如下所示：



|       |            | 队列1 | 队列2 | ...  | ...  | ...  | ...  | ...  | ...  | ...  | ...  |
| ----- | ---------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 迭代  | 初始优先级 | -1    | -2    | -3   | -4   | -5   | -6   | -7   | -8   | -9   | ...  |
| **1** | 1          | 1     | 1     | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |
| **2** |            | 2     | 1     | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |
| **3** |            |       | 3     | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |

因此，每次下楼梯都涉及相同数量的时间片，但每次都会在该迭代的最高优先级上花费更多的时间片。该算法有助于维护相对优先级。*优先级为n*的进程在从楼梯上掉下来后，会发现自己与优先级为*n* -1 的所有进程竞争，但相对于具有较低基本优先级的其他进程，它会获得更长的时间片。

如果一个进程休眠了合理的时间间隔，它就会被推回到楼梯上。因此，通常需要大量睡眠的交互式任务应该停留在楼梯顶部附近并具有响应能力，而 CPU 消耗者则将大部分时间花在较低的台阶上。

当时，内核社区可能还不愿意在稳定系列中进行另一次重大调度程序更改；很多人希望看到 2.6 真正稳定下来，2.7 开始。然而，这个补丁似乎值得考虑，因为它简化了内核的复杂部分。

### 认识“旋转楼梯”调度器

注意“电梯调度”算法和“旋转楼梯电梯调度”算法，有相似之处，也有不同之处。它和O(1)类似，也是会为每个runqueue配置一个独立的运行队列，而运行队列也是分为active+expre。P进程时间片用完将后将通过“软旋转”将当前进程从楼梯上掉下来就将其放到初始优先级低一等级的等级实验班，“硬限制”值得是进程在active运行队列上无法被调度，只能通过“硬旋转”将当前进程签到指定的账号B上。

后来借鉴了RSDL算法对于公平性的建模思想，Ingo提出了 Complete Fair Scheduler （CFS，完全公平调度器），并且Ingo还实现了一个支持可插拔自定义调度器实现的方案，而这些都是之前Con Kolivas极力主张并遭到Torvalds和Ingo反对并拒绝掉的。Con Kolivas对此感觉到很愤怒，于是他最终下决定离开了内核开发社区。

> ps：可以了解下对ck的访谈，了解下他为什么离开内核开发社区：https://geek.digit.in/community/threads/why-i-quit-kernel-developer-con-kolivas.81361/。

直到后面2009年他又回到了Linux社区提出了 Brain Fucker Scheduler（BFS），业内很多开发人员反映将CFS切换到BFS之后，其在桌面上的交互响应、用户体验有不错的改善、提升，但是时至今日因为这样那样的原因BFS仍然是没有进入Linux内核主线的，它的宿命可能像RSDL一样，但是它的思路可能是对的，Linux没法提供一个通用的调度器来同时最佳适应服务器、桌面、移动设备、嵌入式设备，即使是CFS也无法胜任，内核应该允许在不同场景下采用适应性更好的调度器实现。但是Torvalds、Ingo更倾向于提供一个通用的解决方案。

但是后来因为Torvalds、Ingo（调度器维护者）和Con Kolivas在看法上的分歧，以及关于无法证明算法有效性的一些看法，RSDL算法没有进入内核主线。



### 参考文献

1. The staircase Scheduler,https://lwn.net/Articles/87729/
