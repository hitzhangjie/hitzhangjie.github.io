<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.919d32897099d0335611840e8de8126598e04dec08600b11dc58a2217f4a8223a0719340de3efeedf96217230bed172fe5d3b4dc7b9b6b5065e74c49a2539323.css integrity="sha512-kZ0yiXCZ0DNWEYQOjegSZZjgTewIYAsR3FiiIX9KgiOgcZNA3j7+7fliFyML7Rcv5dO03Huba1Bl50xJolOTIw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Linux内核文档索引 - MySpace</title><meta name=description content="迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。
============================================================================= Fri Sep 18 12:23:06 CST 2014 # Documentation/
[1] zorro.txt zorro bus ii\iiioZorro II is the name of the general purpose expansion bus used by the Amiga 2000 computer. The bus is mainly a buffered extension of the Motorola 68000 bus, with support for bus mastering DMA. The expansion slots use a 100-pin connector and the card form factor is the same as the IBM PC. Zorro II cards implement the Autoconfig protocol for automatic address space assignment (designed before, yet similar to, Plug and Play on the PC)."><link rel=canonical href=/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Linux内核文档索引"><meta property="og:description" content="迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。
============================================================================= Fri Sep 18 12:23:06 CST 2014 # Documentation/
[1] zorro.txt zorro bus ii\iiioZorro II is the name of the general purpose expansion bus used by the Amiga 2000 computer. The bus is mainly a buffered extension of the Motorola 68000 bus, with support for bus mastering DMA. The expansion slots use a 100-pin connector and the card form factor is the same as the IBM PC. Zorro II cards implement the Autoconfig protocol for automatic address space assignment (designed before, yet similar to, Plug and Play on the PC)."><meta property="og:url" content="/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/"><meta property="og:site_name" content="MySpace"><meta property="article:published_time" content="2014-10-24T00:10:00+08:00"><meta property="article:modified_time" content="2014-10-24T00:10:00+08:00"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="MySpace"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@hitzhangjie"><meta name=twitter:creator content="@hitzhangjie"><meta name=twitter:title content="Linux内核文档索引"><meta name=twitter:description content><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="Linux内核文档索引"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":["https://twitter.com/hitzhangjie","https://www.linkedin.com/in/hitzhangjie/","https://github.com/hitzhangjie"],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"MySpace","description":"MySpace is a hitzhangjie\u0027s personal space, for blogs, books, journey, thinkings.","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/","url":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/","name":"Linux内核文档索引","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2014-10-24T00:10:00CET","dateModified":"2014-10-24T00:10:00CET","breadcrumb":{"@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/"]}]},{"@type":"BreadcrumbList","@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/blog2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"Linux内核文档索引","description":"","isPartOf":{"@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/"},"mainEntityOfPage":{"@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/"},"datePublished":"2014-10-24T00:10:00CET","dateModified":"2014-10-24T00:10:00CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/person/1"},"image":{"@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"Linux内核文档索引"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=607868a58d7101001829a8df&product=sop" async></script><style>[alt~=sharing]{border:0;box-shadow:none}div#st-1{text-align:unset}div#st-1 .st-btn{height:24px;padding:0 4px}div#st-1 .st-btn>img{top:4.2px}div#st-2 .st-btn{height:24px;padding:0 4px}div#st-2 .st-btn>img{top:4.2px}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-168027530-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-168027530-1')</script></head><body class="blog single d-flex flex-column min-vh-100"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=MySpace>MySpace</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>MySpace</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/books/>Books</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/landscape>Landscape</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://twitter.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-lg-none">Twitter</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Tag List</h3><ol><li><a href=/tags/unix/>unix</a></li><li><a href=/tags/linux/>linux</a></li><li><a href=/tags/kernel/>kernel</a></li><li><a href=/tags/documentation/>documentation</a></li></ol></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#fri-sep-18-122306-cst-2014>=============================================================================
Fri Sep 18 12:23:06 CST 2014</a></li><li><a href=#fri-sep-19-105956-cst-2014>Fri Sep 19 10:59:56 CST 2014</a><ul><li><a href=#binary-kernel-interface>Binary Kernel Interface</a></li><li><a href=#stable-kernel-source-interfaces>Stable Kernel Source Interfaces</a></li><li><a href=#basic-principles>Basic principles:</a></li><li><a href=#rt-mutex-implementation-design>RT-mutex implementation design</a></li><li><a href=#unbounded-priority-inversion>Unbounded Priority Inversion</a></li><li><a href=#priority-inheritance-pi>Priority Inheritance (PI)</a></li><li><a href=#terminology>Terminology</a></li><li><a href=#pi-chain>PI chain</a></li><li><a href=#plist>Plist</a></li><li><a href=#mutex-waiter-list>Mutex Waiter List</a></li><li><a href=#task-pi-list>Task PI List</a></li><li><a href=#depth-of-the-pi-chain>Depth of the PI Chain</a></li><li><a href=#mutex-owner-and-flags>Mutex owner and flags</a></li><li><a href=#cmpxchg-tricks>cmpxchg Tricks</a></li><li><a href=#priority-adjustments>Priority adjustments</a></li><li><a href=#high-level-overview-of-the-pi-chain-walk>High level overview of the PI chain walk</a></li><li><a href=#pending-owners-and-lock-stealing>Pending Owners and Lock stealing</a></li><li><a href=#taking-of-a-mutex-the-walk-through>Taking of a mutex (The walk through)</a></li><li><a href=#task-blocks-on-mutex>Task blocks on mutex</a></li><li><a href=#waking-up-in-the-loop>Waking up in the loop</a></li><li><a href=#failed-to-get-mutex-on-timeout-or-signal>Failed to get mutex on Timeout or Signal</a></li><li><a href=#unlocking-the-mutex>Unlocking the Mutex</a></li><li><a href=#background>Background</a></li><li><a href=#new-approach-to-robust-futexes>New approach to robust futexes</a></li><li><a href=#performance>Performance</a></li><li><a href=#implementation-details>Implementation details</a></li><li><a href=#testing-architecture-support>Testing, architecture support</a></li><li><a href=#robust-futex>The robust futex ABI
robust futex</a></li></ul></li><li><a href=#sat-sep-20-002548-cst-2014>=============================================================================
Sat Sep 20 00:25:48 CST 2014</a><ul><li><a href=#what-are-red-black-trees-and-what-are-they-for><strong>What are red-black trees, and what are they for?</strong></a></li></ul></li><li><a href=#sat-sep-20-100348-cst-2014>=============================================================================
Sat Sep 20 10:03:48 CST 2014</a><ul><li><a href=#finding-using-git-bisect>Finding using git-bisect</a></li><li><a href=#finding-it-the-old-way>Finding it the old way</a></li></ul></li><li><a href=#fixing-the-bug>Fixing the bug</a></li><li><a href=#notes>NOTES</a><ul><li><a href=#section-1---creating-and-sending-your-change>SECTION 1 - CREATING AND SENDING YOUR CHANGE</a></li><li><a href=#section-2---hints-tips-and-tricks>SECTION 2 - HINTS, TIPS, AND TRICKS</a></li><li><a href=#submitting-drivers-for-the-linux-kernel>Submitting Drivers For The Linux Kernel</a></li><li><a href=#allocating-device-numbers>Allocating Device Numbers</a></li><li><a href=#who-to-submit-drivers-to>Who To Submit Drivers To</a></li><li><a href=#what-criteria-determine-acceptance>What Criteria Determine Acceptance</a></li><li><a href=#what-criteria-do-not-determine-acceptance>What Criteria Do Not Determine Acceptance</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#futex-requeue-pi>Futex Requeue PI</a></li></ul></li><li><a href=#mon-sep-29-101739-cst-2014>=============================================================================
Mon Sep 29 10:17:39 CST 2014</a><ul><li><a href=#ldm---logical-disk-manager-dynamic-disks>LDM - Logical Disk Manager (Dynamic Disks)</a></li><li><a href=#overview>Overview</a></li><li><a href=#example>Example</a></li><li><a href=#compiling-ldm-support>Compiling LDM Support</a></li><li><a href=#booting>Booting</a></li><li><a href=#more-documentation>More Documentation</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>Linux内核文档索引</h1><p><small>Posted 2014-10-24 00:10 +0800 by <a class="stretched-link position-relative" href>ZhangJie</a>&nbsp;&dash;&nbsp;<strong>206&nbsp;min read</strong></small><p><div style=display:flex><div>分享:&nbsp;&nbsp;</div><div><div class=sharethis-inline-share-buttons></div></div></div><hr><p class=lead></p><p>迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。</p><h1 id=fri-sep-18-122306-cst-2014>=============================================================================
Fri Sep 18 12:23:06 CST 2014 <a href=#fri-sep-18-122306-cst-2014 class=anchor aria-hidden=true>#</a></h1><p>Documentation/</p><p>[1] zorro.txt
zorro bus ii\iiioZorro II is the name of the general purpose expansion bus
used by the Amiga 2000 computer. The bus is mainly a buffered extension of the
Motorola 68000 bus, with support for bus mastering DMA. The expansion slots
use a 100-pin connector and the card form factor is the same as the IBM PC.
Zorro II cards implement the Autoconfig protocol for automatic address space
assignment (designed before, yet similar to, Plug and Play on the PC). Zorro
II was succeeded by Zorro III.</p><p>[2] xz.txt
XZ is a general purpose data compression format with high compression ratio
and relatively fast decompression. The primary compression algorithm (filter)
is LZMA2. Additional filters can be used to improve 0010 compression
ratio even further. E.g. Branch/Call/Jump (BCJ) filters 0011 improve
compression ratio of executable data.</p><p>[3] workqueue.txt
There are many cases where an asynchronous process execution context is needed
and the workqueue (wq) API is the most commonly used mechanism for such cases.
When such an asynchronous execution context is needed, a work item describing
which function to execute is put on a queue. An independent thread serves as
the asynchronous execution context. The queue is called workqueue and the
thread is called worker.</p><p><strong>[4] volatile-considered-harmful.txt</strong>
<strong>C programmers have often taken volatile to mean that the variable could be</strong>
<strong>changed outside of the current thread of execution; as a result, they are</strong>
<strong>sometimes tempted to use it in kernel code when shared data structures are</strong>
<strong>being used. In other words, they have been known to treat volatile types</strong>
<strong>kernel code is almost never correct; this document describes why.</strong></p><p>[5] video-output.txt
The output sysfs class driver provides an abstract video output layer that can
be used to hook platform specific methods to enable/disable video output
device through common sysfs interface.</p><p>[6] vgaarbiter.txt
Graphic devices are accessed through ranges in I/O or memory space. While most
modern devices allow relocation of such ranges, some &ldquo;Legacy&rdquo; VGA devices
implemented on PCI will typically have the same &ldquo;hard-decoded&rdquo; addresses as
they did on ISA. For more details see &ldquo;PCI Bus Binding to IEEE Std 1275-1994
Standard for Boot (Initialization Configuration) Firmware Revision 2.1&rdquo;
Section 7, Legacy Devices.</p><p>[7] unshare.txt
This document describes the new system call, unshare. The document provides an
overview of the feature, why it is needed, how it can be used, its interface
specification, design, implementation and how it can be tested.</p><p>[8] unicode.txt
kernel code has been rewritten to use Unicode to map characters to fonts. By
downloading a single Unicode-to-font table, both the eight-bit character sets
and UTF-8 mode are changed to use the font as indicated.</p><p><strong>[9] unaligned memory access</strong>
<strong>Linux runs on a wide variety of architectures which have varying behaviour</strong>
<strong>when it comes to memory access. This document presents some details about</strong>
<strong>unaligned accesses, why you need to write code that doesn&rsquo;t cause them, and</strong>
<strong>how to write such code!</strong></p><p>=============================================================================</p><h1 id=fri-sep-19-105956-cst-2014>Fri Sep 19 10:59:56 CST 2014 <a href=#fri-sep-19-105956-cst-2014 class=anchor aria-hidden=true>#</a></h1><p>[10] sysrq.txt
It is a &lsquo;magical&rsquo; key combo you can hit which the kernel will respond to
regardless of whatever else it is doing, unless it is completely locked up.
Here is the list of possible values
in /proc/sys/kernel/sysrq:
0 - disable sysrq completely
1 - enable all functions of sysrq
>1 - bitmask of allowed sysrq functions (see below for detailed function
description):
2 - enable control of console logging level
4 - enable control of keyboard (SAK, unraw)
8 - enable debugging dumps of processes etc.
16 - enable sync command
32 - enable remount read-only
64 - enable signalling of processes (term, kill, oom-kill)
128 - allow reboot/poweroff
256 - allow nicing of all RT tasks</p><p>You can set the value in the file by the following command:
echo &ldquo;number&rdquo; >/proc/sys/kernel/sysrq</p><p>Note that the value of /proc/sys/kernel/sysrq influences only the invocation
via a keyboard. Invocation of any operation via /proc/sysrq-trigger is always
allowed (by a user with admin privileges).</p><p>Regarding to how to make invoke the sysrq commands, please refer to the kernel
documentation, there&rsquo;s some differences between different architectures
including x86, spark and others. some keyboards may generate different keycode
sequences, remapping may be required, too.</p><p>[11] sysfs-rules.txt
kernel-exported sysfs exports internal kernel implementation details and
depends on internal kernel structures and layout. It is agreed upon by the
kernel developers that the Linux kernel does not provide a stable internal
API. Therefore, there are aspects of the sysfs interface that may not be
stable across kernel releases.</p><p>To minimize the risk of breaking users of sysfs, which are in most cases
low-level userspace applications, with a new kernel release, the users of
sysfs must follow some rules to use an as-abstract-as-possible way to access
this filesystem. The current udev and HAL programs already implement this and
users are encouraged to plug, if possible, into the abstractions these
programs provide instead of accessing sysfs directly.</p><p>But if you really do want or need to access sysfs directly, please follow the
following rules and then your programs should work with future versions of the
sysfs interface.</p><p>[12] svga.txt
This small document describes the &ldquo;Video Mode Selection&rdquo; feature which allows
the use of various special video modes supported by the video BIOS. Due to
usage of the BIOS, the selection is limited to boot time (before the kernel
decompression starts) and works only on 80X86 machines.</p><p>[13] stable_kernel_rules.txt
Everything you ever wanted to know about Linux -stable releases.</p><p>Rules on what kind of patches are accepted, and which ones are not, into the
&ldquo;-stable&rdquo; tree:</p><ul><li>It must be obviously correct and tested.</li><li>It cannot be bigger than 100 lines, with context.</li><li>It must fix only one thing.</li><li>It must fix a real bug that bothers people (not a, &ldquo;This could be a
problem&mldr;&rdquo; type thing).</li><li>It must fix a problem that causes a build error (but not for things
marked CONFIG_BROKEN), an oops, a hang, data corruption, a real
security issue, or some &ldquo;oh, that&rsquo;s not good&rdquo; issue. In short, something
critical.</li><li>Serious issues as reported by a user of a distribution kernel may also
be considered if they fix a notable performance or interactivity issue.
As these fixes are not as obvious and have a higher risk of a subtle
regression they should only be submitted by a distribution kernel
maintainer and include an addendum linking to a bugzilla entry if it
exists and additional information on the user-visible impact.</li><li>New device IDs and quirks are also accepted.</li><li>No &ldquo;theoretical race condition&rdquo; issues, unless an explanation of how the
race can be exploited is also provided.</li><li>It cannot contain any &ldquo;trivial&rdquo; fixes in it (spelling changes,
whitespace cleanups, etc).</li><li>It must follow the Documentation/SubmittingPatches rules.</li><li>It or an equivalent fix must already exist in Linus' tree (upstream).</li></ul><p>Procedure for submitting patches to the -stable tree:</p><ul><li><p>Send the patch, after verifying that it follows the above rules, to
stable@vger.kernel.org. You must note the upstream commit ID in the
changelog of your submission.</p></li><li><p>To have the patch automatically included in the stable tree, add the tag
Cc: stable@vger.kernel.org
in the sign-off area. Once the patch is merged it will be applied to
the stable tree without anything else needing to be done by the author
or subsystem maintainer.</p></li><li><p>If the patch requires other patches as prerequisites which can be
cherry-picked than this can be specified in the following format in
the sign-off area:</p><p>Cc: <a href=mailto:stable@vger.kernel.org>stable@vger.kernel.org</a> # 3.3.x: a1f84a3: sched: Check for idle
Cc: <a href=mailto:stable@vger.kernel.org>stable@vger.kernel.org</a> # 3.3.x: 1b9508f: sched: Rate-limit newidle
Cc: <a href=mailto:stable@vger.kernel.org>stable@vger.kernel.org</a> # 3.3.x: fd21073: sched: Fix affinity logic
Cc: <a href=mailto:stable@vger.kernel.org>stable@vger.kernel.org</a> # 3.3.x
Signed-off-by: Ingo Molnar <a href=mailto:mingo@elte.hu>mingo@elte.hu</a></p><p>The tag sequence has the meaning of:
git cherry-pick a1f84a3
git cherry-pick 1b9508f
git cherry-pick fd21073
git cherry-pick <this commit></p></li><li><p>The sender will receive an ACK when the patch has been accepted into the
queue, or a NAK if the patch is rejected. This response might take a few
days, according to the developer&rsquo;s schedules.</p></li><li><p>If accepted, the patch will be added to the -stable queue, for review by
other developers and by the relevant subsystem maintainer.</p></li><li><p>Security patches should not be sent to this alias, but instead to the
documented security@kernel.org address.</p></li></ul><p>Review cycle:</p><ul><li>When the -stable maintainers decide for a review cycle, the patches will be
sent to the review committee, and the maintainer of the affected area of
the patch (unless the submitter is the maintainer of the area) and CC: to
the linux-kernel mailing list.</li><li>The review committee has 48 hours in which to ACK or NAK the patch.</li><li>If the patch is rejected by a member of the committee, or linux-kernel
members object to the patch, bringing up issues that the maintainers and
members did not realize, the patch will be dropped from the queue.</li><li>At the end of the review cycle, the ACKed patches will be added to the
latest -stable release, and a new -stable release will happen.</li><li>Security patches will be accepted into the -stable tree directly from the
security kernel team, and not go through the normal review cycle.
Contact the kernel security team for more details on this procedure.</li></ul><p>[14] stable_api_nonsense.txt
This is being written to try to explain why Linux does not have a binary
kernel interface, nor does it have a stable kernel interface. Please realize
that this article describes the <em>in kernel</em> interfaces, not the kernel to
userspace interfaces. The kernel to userspace interface is the one that
application programs use, the syscall interface. That interface is <em>very</em>
stable over time, and will not break. I have old programs that were built on
a pre 0.9something kernel that still work just fine on the latest 2.6 kernel
release. That interface is the one that users and application programmers can
count on being stable.</p><p>there are two main topics here, binary kernel interfaces and stable kernel
source interfaces. They both depend on each other, but we will discuss the
binary stuff first to get it out of the way.</p><h2 id=binary-kernel-interface>Binary Kernel Interface <a href=#binary-kernel-interface class=anchor aria-hidden=true>#</a><a href=#binary-kernel-interface class=anchor aria-hidden=true>#</a></h2><p>Assuming that we had a stable kernel source interface for the kernel, a binary
interface would naturally happen too, right? Wrong. Please consider the
following facts about the Linux kernel:</p><ul><li>Depending on the version of the C compiler you use, different kernel
data structures will contain different alignment of structures, and
possibly include different functions in different ways (putting
functions inline or not.) The individual function organization
isn&rsquo;t that important, but the different data structure padding is
very important.</li><li>Depending on what kernel build options you select, a wide range of
different things can be assumed by the kernel:<ul><li>different structures can contain different fields</li><li>Some functions may not be implemented at all, (i.e. some locks
compile away to nothing for non-SMP builds.)</li><li>Memory within the kernel can be aligned in different ways,
depending on the build options.</li><li>Linux runs on a wide range of different processor architectures.
There is no way that binary drivers from one architecture will run
on another architecture properly.</li></ul></li></ul><p>Now a number of these issues can be addressed by simply compiling your module
for the exact specific kernel configuration, using the same exact C compiler
that the kernel was built with. This is sufficient if you want to provide a
module for a specific release version of a specific Linux distribution. But
multiply that single build by the number of different Linux distributions and
the number of different supported releases of the Linux distribution and you
quickly have a nightmare of different build options on different releases.
Also realize that each Linux distribution release contains a number of
different kernels, all tuned to different hardware types (different processor
types and different options), so for even a single release you will
need to create multiple versions of your module.</p><p>Trust me, you will go insane over time if you try to support this kind of
release, I learned this the hard way a long time ago&mldr;</p><h2 id=stable-kernel-source-interfaces>Stable Kernel Source Interfaces <a href=#stable-kernel-source-interfaces class=anchor aria-hidden=true>#</a><a href=#stable-kernel-source-interfaces class=anchor aria-hidden=true>#</a></h2><p>This is a much more &ldquo;volatile&rdquo; topic if you talk to people who try to keep a
Linux kernel driver that is not in the main kernel tree up to date over time.</p><p>Linux kernel development is continuous and at a rapid pace, never stopping to
slow down. As such, the kernel developers find bugs in current interfaces, or
figure out a better way to do things. If they do that, they then fix the
current interfaces to work better. When they do so, function names may
change, structures may grow or shrink, and function parameters may be
reworked. If this happens, all of the instances of where this interface is
used within the kernel are fixed up at the same time, ensuring that everything
continues to work properly.</p><p>As a specific examples of this, the in-kernel USB interfaces have undergone at
least three different reworks over the lifetime of this subsystem. These
reworks were done to address a number of different issues:</p><ul><li><p>A change from a synchronous model of data streams to an asynchronous
one. This reduced the complexity of a number of drivers and
increased the throughput of all USB drivers such that we are now
running almost all USB devices at their maximum speed possible.</p></li><li><p>A change was made in the way data packets were allocated from the
USB core by USB drivers so that all drivers now needed to provide
more information to the USB core to fix a number of documented
deadlocks.</p></li></ul><p>This is in stark contrast to a number of closed source operating systems which
have had to maintain their older USB interfaces over time. This provides the
ability for new developers to accidentally use the old interfaces and do
things in improper ways, causing the stability of the operating system to
suffer.</p><p>In both of these instances, all developers agreed that these were important
changes that needed to be made, and they were made, with relatively little
pain. If Linux had to ensure that it will preserve a stable source interface,
a new interface would have been created, and the older, broken one would
have had to be maintained over time, leading to extra work for the USB
developers. Since all Linux USB developers do their work on their own time,
asking programmers to do extra work for no gain, for free, is not a
possibility.</p><p>Security issues are also very important for Linux. When a security issue is
found, it is fixed in a very short amount of time. A number of times this has
caused internal kernel interfaces to be reworked to prevent the security
problem from occurring. When this happens, all drivers that use the
interfaces were also fixed at the same time, ensuring that the security
problem was fixed and could not come back at some future time accidentally.
If the internal interfaces were not allowed to change, fixing this kind of
security problem and insuring that it could not happen again would not be
possible.</p><p>Kernel interfaces are cleaned up over time. If there is no one using a
current interface, it is deleted. This ensures that the kernel remains as
small as possible, and that all potential interfaces are tested as well as
they can be (unused interfaces are pretty much impossible to test for
validity.)</p><p><strong>[15] spinlocks.txt</strong></p><p><strong>自旋锁，这里自旋的意思值得是线程在一个while循环中不停地检查期望的条件是否得到</strong>
<strong>了满足，如果没有得到满足就等待一段时间，然后继续检查，知道满足之后才会执行后续</strong>
<strong>的处理。</strong>
说白了，自旋就是忙等，我们在以前学习组成原理的时候，了解到cpu与设备的通信方式
主要有3种，分别是程序查询方式（忙等）、中断请求、DMA。其中程序查询方式会中断
cpu的执行，原地踏步，影响cpu的执行效率，可能想到这的时候会认为自旋锁也是这样的
一种锁，这很自然，类比嘛，但是其中有些差别。
我们前面提及的程序查询方式是cpu与硬件设备进行通信的方式，与我们这里操作系统内
部的自旋锁还稍微有些差别，不过，确实是，自旋锁这种排它性锁对系统整体性能可能影
响是比较大的，所以我们在内核中不会用它来长时间阻塞一个线程，而是用它来短暂的阻
塞一个线程，例如将其用于进程调度、线程调度，这个时候，自旋锁在内核中还是非常高
效的。</p><p>另外，实现自旋锁还是比较复杂的，因为要保证能够正确处理可能存在的竟态条件，需要
考虑cpu架构，以及针对这种架构的特殊的汇编指令，例如原子的test、set指令来实现对
自旋锁的加锁、解锁、测试，这在高级语言中是无法做到的。
如果cpu架构中没有原子的这种test、set操作的话，则需要通过某种算法来实现类似的原
子操作。
这样看来，自旋锁是与cpu有关的，好了，现在先不多说了，在看第3个例子的时候，提到
non-irq版本的自旋锁进入临界区后，如果有相同的cpu上有中断到达，并且中断处理函数
中请求相同的自旋锁时，会引发死锁，当讲到这的时候，我们将详细描述自旋锁的实现细
节。</p><p>其实自旋锁效率高不高，还是要看应用的场景，好了下面介绍一下内核中3种常用的自旋
锁。</p><p>Lesson 1: Spin locks</p><p>The most basic primitive for locking is spinlock.</p><pre><code>static DEFINE_SPINLOCK(xxx_lock);
 
    unsigned long flags;

    spin_lock_irqsave(&amp;xxx_lock, flags);
    ... critical section here ..
    spin_unlock_irqrestore(&amp;xxx_lock, flags);

这里的自旋锁会屏蔽后期到达的中断请求，屏蔽并不是表示忽略，而是将到达的中断
请求暂时保存起来，即irqsave，等临界区代码执行完毕时，再将咱存的中断请求恢
复，即irqrestore。
</code></pre><p>The above is always safe. It will disable interrupts <em>locally</em>, but the
spinlock itself will guarantee the global lock, so it will guarantee that
there is only one thread-of-control within the region(s) protected by that
lock. This works well even under UP also, so the code does <em>not</em> need to
worry about UP vs SMP issues: the spinlocks work correctly under both.</p><p>UP: Uniprocessor，单处理器；
SMP: Symmetric Multiprocessor，对称多处理器；
spin_lock_irqsave/spin_lock_irqrestore会禁止中断，这种方式使得自旋锁在UP、SMP
两种情况下均适用。</p><p>NOTE! Implications of spin_locks for memory are further described in:</p><pre><code>Documentation/memory-barriers.txt
   (5) LOCK operations.
   (6) UNLOCK operations.
</code></pre><p>The above is usually pretty simple (you usually need and want only one
spinlock for most things - using more than one spinlock can make things a lot
more complex and even slower and is usually worth it only for sequences that
you <em>know</em> need to be split up: avoid it at all cost if you aren&rsquo;t sure).</p><p>This is really the only really hard part about spinlocks: once you start
using spinlocks they tend to expand to areas you might not have noticed
before, because you have to make sure the spinlocks correctly protect the
shared data structures <em>everywhere</em> they are used. The spinlocks are most
easily added to places that are completely independent of other code (for
example, internal driver data structures that nobody else ever touches).</p><p>NOTE! The spin-lock is safe only when you <em>also</em> use the lock itself to do
locking across CPU&rsquo;s, which implies that EVERYTHING that touches a shared
variable has to agree about the spinlock they want to use.</p><hr><p>Lesson 2: reader-writer spinlocks.</p><p>If your data accesses have a very natural pattern where you usually tend to
mostly read from the shared variables, the reader-writer locks (rw_lock)
versions of the spinlocks are sometimes useful. They allow multiple readers to
be in the same critical region at once, but if somebody wants to change the
variables it has to get an exclusive write lock.</p><p>NOTE! reader-writer locks require more atomic memory operations than simple
spinlocks. Unless the reader critical section is long, you are better off
just using spinlocks.</p><p>其实这里考虑的还是细粒度加锁，以便提高并行、并发能力。
禁用中断的自旋锁版本是最简单的自旋锁版本，但是它由于是排它性锁，所以对并行性影
响较大；
而自旋锁的另一个版本，读写锁，在读者较多的情况下，能够适当提高并行性，提升系统
性能，但是这种情况下，最好临界区比较长，如果临界区比较短的情况下，并行性能的提
升也不会很明显，这个时候最好使用简单版本的自旋锁。</p><p>The routines look the same as above:</p><pre><code>rwlock_t xxx_lock = __RW_LOCK_UNLOCKED(xxx_lock);
 
     unsigned long flags;
 
     read_lock_irqsave(&amp;xxx_lock, flags);
     .. critical section that only reads the info ...
     read_unlock_irqrestore(&amp;xxx_lock, flags);
 
     write_lock_irqsave(&amp;xxx_lock, flags);
     .. read and write exclusive access to the info ...
     write_unlock_irqrestore(&amp;xxx_lock, flags);
</code></pre><p>The above kind of lock may be useful for complex data structures like linked
lists, especially searching for entries without changing the list itself. The
read lock allows many concurrent readers. Anything that <em>changes</em> the list
will have to get the write lock.</p><p>NOTE! RCU is better for list traversal, but requires careful attention to
design detail (see Documentation/RCU/listRCU.txt).</p><p>Also, you cannot &ldquo;upgrade&rdquo; a read-lock to a write-lock, so if you at <em>any</em>
time need to do any changes (even if you don&rsquo;t do it every time), you have to
get the write-lock at the very beginning.</p><p>NOTE! We are working hard to remove reader-writer spinlocks in most cases, so
please don&rsquo;t add a new one without consensus. (Instead, see
Documentation/RCU/rcu.txt for complete information.)</p><p>Lesson 3: spinlocks revisited.</p><p>The single spin-lock primitives above are by no means the only ones. They are
the most safe ones, and the ones that work under all circumstances, but partly
<em>because</em> they are safe they are also fairly slow. They are slower than they&rsquo;d
need to be, because they do have to disable interrupts (which is just a single
instruction on a x86, but it&rsquo;s an expensive one - and on other architectures
it can be worse).</p><p>这里说的因为前两个版本安全，所以它们慢，这么说的原因，是因为，它们加锁的方式限
制了并行度的提高，以牺牲其他线程的运行来保证安全，这影响了整体的运行效率。</p><p>If you have a case where you have to protect a data structure across several
CPU&rsquo;s and you want to use spinlocks you can potentially use cheaper versions
of the spinlocks. IF you know that the spinlocks are never used in interrupt
handlers, you can use the non-irq versions:</p><p>non-irq版本的自旋锁指的是，没有屏蔽中断的自旋锁，当线程进入临界区时，如果这个
时候有中断到达，该中断信号将会被中断处理函数处理，而不是像自旋锁中最简单的那个
版本一样将之irqsave\irqrestore。</p><pre><code>    spin_lock(&amp;lock);
    ...
    spin_unlock(&amp;lock);
</code></pre><p>(and the equivalent read-write versions too, of course). The spinlock will
guarantee the same kind of exclusive access, and it will be much faster.
This is useful if you know that the data in question is only ever
manipulated from a &ldquo;process context&rdquo;, ie no interrupts involved.</p><p>The reasons you mustn&rsquo;t use these versions if you have interrupts that
play with the spinlock is that you can get deadlocks:</p><pre><code>    spin_lock(&amp;lock);
    ...
            &lt;- interrupt comes in:
                    spin_lock(&amp;lock);

    如果在处理器1上加了自旋锁，在进入临界区之后，如果在相同的处理器上有中
    断请求，并且处理函数中也请求对相同的自旋锁进行加锁，此时就会发生死锁;
    如果该中断是在不同的处理器上的话，则不会引发死锁。

    为什么会这样呢，前面讲述各个版本的自旋锁之前，我们提到了自旋锁的实现与
    具体的cpu架构以及特殊的汇编指令有关，好的，现在我们讲一下x86架构下，一
    个non-irq版本的自旋锁的实现（详细信息参看wiki）：

    ; Intel syntax
     
    locked:        ; The lock variable. 1 = locked, 0 = unlocked.
         dd      0
    spin_lock:
         mov     eax, 1          ; Set the EAX register to 1.

         xchg    eax, [locked]   ; Atomically swap the EAX register with
                                 ; the lock variable.
                                 ; This will always store 1 to the lock, leaving
                                 ; the previous value in the EAX register.
         test    eax, eax        ; Test EAX with itself. Among other things, this will
                                 ; set the processor's Zero Flag if EAX is 0.
                                 ; If EAX is 0, then the lock was unlocked and
                                 ; we just locked it.
                                 ; Otherwise, EAX is 1 and we didn't acquire the lock.  
         jnz     spin_lock       ; Jump back to the MOV instruction if the Zero Flag is
                                 ;  not set; the lock was previously locked, and so
                                 ; we need to spin until it becomes unlocked.
         ret                     ; The lock has been acquired, return to the calling 
                                 ;  function.
    spin_unlock:
         mov     eax, 0          ; Set the EAX register to 0.
         xchg    eax, [locked]   ; Atomically swap the EAX register with
                                 ;  the lock variable.
         ret                     ; The lock has been released.
</code></pre><p>where [an interrupt] tries to lock an already locked variable. This is ok if
[the other interrupt] happens on another CPU, but it is <em>not</em> ok if the
interrupt happens on the same CPU that already holds the lock, because the
lock will obviously never be released (because the interrupt is waiting
for the lock, and the lock-holder is interrupted by the interrupt and will
not continue until the interrupt has been processed).</p><p>这段话很重要，我翻译翻译！ 在翻译之前，需要指明，文档中有几个地方写的不是很好
，比如 the other interrupt，其实这个the other interrupt指的就是前面的an
interrupt，不指出来理解起来就是误解。</p><p>首先non-irq版本的自旋锁不会屏蔽中断，有中断到达的时候，仍然会对其进行中断处理
，这一点要明确。</p><p>【当某个中断试图锁定一个已经被锁定的变量时，如果这个中断是在另一个cpu上到达，
那么这种情况下是可行的：</p><pre><code>在当前cpu1上一个线程已经锁定了该变量（non-irq锁），这个时候中断到达到达
cpu2，然后cpu2进入中断的中断处理函数，处理函数中请求对该变量再次加锁，这个
时候，cpu不会允许该加锁，参考上面x86中spinlock的实现，当前[locked]中值为1
，xchg之后，eax为1，test eax,eax，标志寄存器Z为1，jnz spin_lock继续自旋，
可见此时加锁没有成功，中断会继续自旋直到加锁成功。

如果要加锁成功，就要等到cpu1上的持有锁的线程释放锁，只要它释放了锁，cpu2上
的执行中断处理函数的线程就能够成功对其、进行加锁，二者不会构成死锁。

所以说这种情形下，是可行的！
</code></pre><p>】</p><p>【当某个中断试图锁定一个已经被锁定的变量时，如果这个中断与当前中断在相同的cpu上
到达，那么这种情况下是不可行的：</p><pre><code>在当前cpu上一个线程已经锁定了该变量（non-irq锁），这个时候中断到达，然后进
入中断的中断处理函数，处理函数中请求对该变量再次加锁，这个时候，cpu不会允
许该加锁，参考上面x86中spinlock的实现，当前[locked]中值为1，xchg之后，eax
为1，test eax,eax，标志寄存器Z为1，jnz spin_lock继续自旋，可见此时加锁没有
成功，中断1会继续自旋直到加锁成功，但是，只有持有该锁的当前线程被中断了，
释放锁的代码不可能被执行，也就是说中断处理函数中会一直阻塞不会返回。中断处
理函数请求加锁，而当前线程作为锁的持有者，又不释放锁，从而造成死锁。

所以说这种情形下，是不可行的！
</code></pre><p>】</p><p>(This is also the reason why the irq-versions of the spinlocks only need
to disable the <em>local</em> interrupts - it&rsquo;s ok to use spinlocks in interrupts
on other CPU&rsquo;s, because an interrupt on another CPU doesn&rsquo;t interrupt the
CPU that holds the lock, so the lock-holder can continue and eventually
releases the lock).</p><p>Note that you can be clever with read-write locks and interrupts. For
example, if you know that the interrupt only ever gets a read-lock, then
you can use a non-irq version of read locks everywhere - because they
don&rsquo;t block on each other (and thus there is no dead-lock wrt interrupts.
But when you do the write-lock, you have to use the irq-safe version.</p><p>For an example of being clever with rw-locks, see the &ldquo;waitqueue_lock&rdquo;
handling in kernel/sched.c - nothing ever <em>changes</em> a wait-queue from
within an interrupt, they only read the queue in order to know whom to
wake up. So read-locks are safe (which is good: they are very common
indeed), while write-locks need to protect themselves against interrupts.</p><hr><p>Reference information:</p><p>For dynamic initialization, use spin_lock_init() or rwlock_init() as
appropriate:</p><p>spinlock_t xxx_lock;
rwlock_t xxx_rw_lock;</p><p>static int __init xxx_init(void)
{
spin_lock_init(&xxx_lock);
rwlock_init(&xxx_rw_lock);
&mldr;
}</p><p>module_init(xxx_init);</p><p>For static initialization, use DEFINE_SPINLOCK() / DEFINE_RWLOCK() or
__SPIN_LOCK_UNLOCKED() / __RW_LOCK_UNLOCKED() as appropriate.</p><p>[16] sparse.txt
Using sparse for typechecking</p><p>[17] sgi-viws.txt</p><p>The SGI Visual Workstations (models 320 and 540) are based around the Cobalt,
Lithium, and Arsenic ASICs. The Cobalt ASIC is the main system ASIC which
interfaces the 1-4 IA32 cpus, the memory system, and the I/O system in the
Lithium ASIC. The Cobalt ASIC also contains the 3D gfx rendering engine which
renders to main system memory &ndash; part of which is used as the frame buffer
which is DMA&rsquo;ed to a video connector using the Arsenic ASIC. A PIIX4 chip and
NS87307 are used to provide legacy device support (IDE, serial, floppy, and
parallel).</p><p>The Visual Workstation chipset largely conforms to the PC architecture
with some notable exceptions such as interrupt handling.</p><p>[18] sgi-ioc4.txt</p><p>The SGI IOC4 PCI device is a bit of a strange beast, so some notes on it are
in order.</p><p>First, even though the IOC4 performs multiple functions, such as an IDE
controller, a serial controller, a PS/2 keyboard/mouse controller, and an
external interrupt mechanism, it&rsquo;s not implemented as a multifunction device.
The consequence of this from a software standpoint is that all these functions
share a single IRQ, and they can&rsquo;t all register to own the same PCI device ID.
To make matters a bit worse, some of the register blocks (and even registers
themselves) present in IOC4 are mixed-purpose between these several
functions, meaning that there&rsquo;s no clear &ldquo;owning&rdquo; device driver.</p><p>The solution is to organize the IOC4 driver into several independent drivers,
&ldquo;ioc4&rdquo;, &ldquo;sgiioc4&rdquo;, and &ldquo;ioc4_serial&rdquo;. Note that there is no PS/2 controller
driver as this functionality has never been wired up on a shipping IO card.</p><p>[19] serial-console.txt</p><p>Linux Serial Console</p><p>To use a serial port as console you need to compile the support into your
kernel - by default it is not compiled in. For PC style serial ports
it&rsquo;s the config option next to &ldquo;Standard/generic (dumb) serial support&rdquo;.
You must compile serial support into the kernel and not as a module.</p><p>It is possible to specify multiple devices for console output. You can
define a new kernel command line option to select which device(s) to
use for console output.</p><p>The format of this option is:</p><p>console=device,options</p><p>device: tty0 for the foreground virtual console
ttyX for any other virtual console
ttySx for a serial port
lp0 for the first parallel port
ttyUSB0 for the first USB serial device</p><p>options: depend on the driver. For the serial port this
defines the baudrate/parity/bits/flow control of
the port, in the format BBBBPNF, where BBBB is the
speed, P is parity (n/o/e), N is number of bits,
and F is flow control (&lsquo;r&rsquo; for RTS). Default is
9600n8. The maximum baudrate is 115200.</p><p>You can specify multiple console= options on the kernel command line.
Output will appear on all of them. The last device will be used when
you open /dev/console. So, for example:</p><p>console=ttyS1,9600 console=tty0</p><p>defines that opening /dev/console will get you the current foreground
virtual console, and kernel messages will appear on both the VGA
console and the 2nd serial port (ttyS1 or COM2) at 9600 baud.</p><p>Note that you can only define one console per device type (serial, video).</p><p>If no console device is specified, the first device found capable of
acting as a system console will be used. At this time, the system
first looks for a VGA card and then for a serial port. So if you don&rsquo;t
have a VGA card in your system the first serial port will automatically
become the console.</p><p>You will need to create a new device to use /dev/console. The official
/dev/console is now character device 5,1.</p><p>(You can also use a network device as a console. See
Documentation/networking/netconsole.txt for information on that.)</p><p>Here&rsquo;s an example that will use /dev/ttyS1 (COM2) as the console.
Replace the sample values as needed.</p><ol><li>Create /dev/console (real console) and /dev/tty0 (master virtual
console):</li></ol><p>cd /dev
rm -f console tty0
mknod -m 622 console c 5 1
mknod -m 622 tty0 c 4 0</p><ol start=2><li>LILO can also take input from a serial device. This is a very
useful option. To tell LILO to use the serial port:
In lilo.conf (global section):</li></ol><p>serial = 1,9600n8 (ttyS1, 9600 bd, no parity, 8 bits)</p><ol start=3><li>Adjust to kernel flags for the new kernel,
again in lilo.conf (kernel section)</li></ol><p>append = &ldquo;console=ttyS1,9600&rdquo;</p><ol start=4><li>Make sure a getty runs on the serial port so that you can login to
it once the system is done booting. This is done by adding a line
like this to /etc/inittab (exact syntax depends on your getty):</li></ol><p>S1:23:respawn:/sbin/getty -L ttyS1 9600 vt100</p><ol start=5><li>Init and /etc/ioctl.save</li></ol><p>Sysvinit remembers its stty settings in a file in /etc, called
`/etc/ioctl.save'. REMOVE THIS FILE before using the serial
console for the first time, because otherwise init will probably
set the baudrate to 38400 (baudrate of the virtual console).</p><ol start=6><li>/dev/console and X
Programs that want to do something with the virtual console usually
open /dev/console. If you have created the new /dev/console device,
and your console is NOT the virtual console some programs will fail.
Those are programs that want to access the VT interface, and use
/dev/console instead of /dev/tty0. Some of those programs are:</li></ol><p>Xfree86, svgalib, gpm, SVGATextMode</p><p>It should be fixed in modern versions of these programs though.</p><p>Note that if you boot without a console= option (or with
console=/dev/tty0), /dev/console is the same as /dev/tty0. In that
case everything will still work.</p><p>[20] rtc.txt</p><p>Real Time Clock (RTC) Drivers for Linux</p><p>[21] rt-mutex.txt</p><p>RT-mutex subsystem with PI support</p><p>这个地方PI指的是Priority Inheritance。</p><hr><p>RT-mutexes with priority inheritance are used to support PI-futexes, which
enable pthread_mutex_t priority inheritance attributes (PTHREAD_PRIO_INHERIT).
[See Documentation/pi-futex.txt for more details about PI-futexes.]</p><p>This technology was developed in the -rt tree and streamlined for
pthread_mutex support.</p><h2 id=basic-principles>Basic principles: <a href=#basic-principles class=anchor aria-hidden=true>#</a><a href=#basic-principles class=anchor aria-hidden=true>#</a></h2><p>RT-mutexes extend the semantics of simple mutexes by the priority inheritance
protocol.
RT-mutexes通过优先级继承协议，扩展了简单mutex的语义。</p><p>A low priority owner of a rt-mutex inherits the priority of a higher priority
waiter until the rt-mutex is released. If the temporarily boosted owner blocks
on a rt-mutex itself it propagates the priority boosting to the owner of the
other rt_mutex it gets blocked on. The priority boosting is immediately
removed once the rt_mutex has been unlocked.</p><p>rt-mutex的一个低优先级持有者，可以继承等待该rt-mutex的一个高优先级任务的优先级
，低优先级持有者获取了高优先级任务的优先级之后，在内核任务调度时会获取更多的机
会，能够尽快执行完任务，更早地释放rt-mutex，从而让高优先级任务不用因为等待低优
先级任务释放锁而浪费太多时间。在低优先级任务释放锁之后，将恢复到以前的低优先级
。</p><p>假如一个获取了rt-mutex（记为m1）的低优先级任务继承了一个等待该锁的高优先级任务
的优先级，此时如果该低优先级任务还希望获取另一个rt-mutex（记为m2），那么该低优
先级会将继承到的高优先级任务的优先级传递给锁m2的持有者。如果m2的持有者因为获取
高优先级提前完成了任务并释放锁，那么m1的持有者也会提前获得锁m2并尽快完成任务，
并释放锁m1、m2，从而使得高优先级任务尽快获得锁m1.这样看来，rt-mutex优先级的继
承，对系统整体性能来说会是一大改进。</p><p>This approach allows us to shorten the block of high-prio tasks on mutexes
which protect shared resources. Priority inheritance is not a magic bullet for
poorly designed applications, but it allows well-designed applications to use
userspace locks in critical parts of an high priority thread, without losing
determinism.</p><p>The enqueueing of the waiters into the rtmutex waiter list is done in priority
order. For same priorities FIFO order is chosen. For each rtmutex, only the
top priority waiter is enqueued into the owner&rsquo;s priority waiters list. This
list too queues in priority order. Whenever the top priority waiter of a task
changes (for example it timed out or got a signal), the priority of the owner
task is readjusted. [The priority enqueueing is handled by &ldquo;plists&rdquo;, see</p><p>等待rt-mutex的任务按照优先级顺序进入该rt-mutex的等待队列。如果任务是相同的优先
级，则按照先请求先进入队列的原则。对于每一个rt-mutex，只有优先级最高的处于等待
状态的任务会被选择进入锁持有者的优先级等待者队列中，并且这个队列也是按照优先级
进行排序。不管什么时候，这个任务的优先级等待队列的最高优先级的任务发生改变，这
个任务的优先级都会被进行重新调整。</p><p>include/linux/plist.h for more details.]</p><p>RT-mutexes are optimized for fastpath operations and have no internal locking
overhead when locking an uncontended mutex or unlocking a mutex without
waiters. The optimized fastpath operations require cmpxchg support. [If that
is not available then the rt-mutex internal spinlock is used]</p><p>The state of the rt-mutex is tracked via the owner field of the rt-mutex
structure:</p><p>rt_mutex->owner holds the task_struct pointer of the owner. Bit 0 and 1 are
used to keep track of the &ldquo;owner is pending&rdquo; and &ldquo;rtmutex has waiters&rdquo; state.</p><p>owner bit1 bit0
NULL 0 0 mutex is free (fast acquire possible)
NULL 0 1 invalid state
NULL 1 0 Transitional state*
NULL 1 1 invalid state
taskpointer 0 0 mutex is held (fast release possible)
taskpointer 0 1 task is pending owner
taskpointer 1 0 mutex is held and has waiters
taskpointer 1 1 task is pending owner and mutex has waiters</p><p>Pending-ownership handling is a performance optimization: pending-ownership is
assigned to the first (highest priority) waiter of the mutex, when the mutex
is released. The thread is woken up and once it starts executing it can
acquire the mutex. Until the mutex is taken by it (bit 0 is cleared) a
competing higher priority thread can &ldquo;steal&rdquo; the mutex which puts the woken up
thread back on the waiters list.</p><p>The pending-ownership optimization is especially important for the
uninterrupted workflow of high-prio tasks which repeatedly takes/releases
locks that have lower-prio waiters. Without this optimization the higher-prio
thread would ping-pong to the lower-prio task [because at unlock time we
always assign a new owner].</p><p>(*) The &ldquo;mutex has waiters&rdquo; bit gets set to take the lock. If the lock doesn&rsquo;t
already have an owner, this bit is quickly cleared if there are no waiters.
So this is a transitional state to synchronize with looking at the owner field
of the mutex and the mutex owner releasing the lock.</p><p>[22] rt-mutex-design.txt</p><h2 id=rt-mutex-implementation-design>RT-mutex implementation design <a href=#rt-mutex-implementation-design class=anchor aria-hidden=true>#</a><a href=#rt-mutex-implementation-design class=anchor aria-hidden=true>#</a></h2><p>This document tries to describe the design of the rtmutex.c implementation.
It doesn&rsquo;t describe the reasons why rtmutex.c exists. For that please see
Documentation/rt-mutex.txt. Although this document does explain problems that
happen without this code, but that is in the concept to understand what the
code actually is doing.</p><p>这个文档解释rtmutex的具体设计，关于为什么要实现rtmutex，请参考前面21这部分。</p><p>The goal of this document is to help others understand the priority
inheritance (PI) algorithm that is used, as well as reasons for the decisions
that were made to implement PI in the manner that was done.</p><p>这个文档的目的是为了帮助别人理解使用的优先级继承算法，以及实现该算法过程中采用
的某些相关决策的原因。</p><h2 id=unbounded-priority-inversion>Unbounded Priority Inversion <a href=#unbounded-priority-inversion class=anchor aria-hidden=true>#</a><a href=#unbounded-priority-inversion class=anchor aria-hidden=true>#</a></h2><p>Priority inversion is when a lower priority process executes while a higher
priority process wants to run. This happens for several reasons, and most of
the time it can&rsquo;t be helped. Anytime a high priority process wants to use a
resource that a lower priority process has (a mutex for example), the high
priority process must wait until the lower priority process is done with the
resource. This is a priority inversion. What we want to prevent is something
called unbounded priority inversion. That is when the high priority process
is prevented from running by a lower priority process for an undetermined
amount of time.</p><p>理解优先级反转，优先级反转指的是，当一个低优先级进程执行的时候，同时有一个高优
先级进程也希望执行。这在很多情况下都会发生，并且大多数情况下是无法被干预的。某
个时候，如果一个高优先级进车功能希望使用一个低优先级进程拥有的资源，例如一个锁
，高优先级进程不得不等待到低优先级进程释放这个资源，然后才能获取到该资源，并继
续执行。本来高优先级的进程应该先于低优先级进程执行，但是这里，却因为等待低优先
级进程释放资源而等待，并且等待的时间是无法确定的，这种情况我们称之为优先级反转
。
我们希望能够阻止不受限制的优先级反转，即，当一个高优先级进程被一个低优先级进程
阻塞，并且阻塞时间不缺定，我们需要阻止或者尽量避免这种情况。</p><p>The classic example of unbounded priority inversion is were you have three
processes, let&rsquo;s call them processes A, B, and C, where A is the highest
priority process, C is the lowest, and B is in between. A tries to grab a lock
that C owns and must wait and lets C run to release the lock. But in the
meantime, B executes, and since B is of a higher priority than C, it preempts
C, but by doing so, it is in fact preempting A which is a higher priority
process. Now there&rsquo;s no way of knowing how long A will be sleeping waiting
for C to release the lock, because for all we know, B is a CPU hog and will
never give C a chance to release the lock. This is called unbounded priority
inversion.</p><p>举个不受限制的优先级反转的例子，假定有3个进程A、B、C，优先级依次降低，现在A希
望获取一个锁，这个锁被C持有，因此A需要等待到C执行到释放锁后才能继续向下执行，
假定在C释放锁之前，B开始执行，由于B优先级比C高，有可能B会抢占CPU而先于C执行，
假定B占用的CPU时间比较长，例如B是一个while(1)循环，它不会给C机会区释放锁，因此
间接地阻止了最高优先级进程A的执行，并且A继续等待的事件会很长甚至是永久，这被称
之为不受限制的优先级反转。</p><p>Here&rsquo;s a little ASCII art to show the problem.</p><pre><code>grab lock L1 (owned by C)
      |
 A ---+
         C preempted by B
           |
 C    +----+
 
 B         +--------&gt;
                 B now keeps A from running.
</code></pre><h2 id=priority-inheritance-pi>Priority Inheritance (PI) <a href=#priority-inheritance-pi class=anchor aria-hidden=true>#</a><a href=#priority-inheritance-pi class=anchor aria-hidden=true>#</a></h2><p>There are several ways to solve this issue, but other ways are out of scope
for this document. Here we only discuss PI.</p><p>有很多方法来解决不受限制的优先级反转问题，但是这里值讨论优先级继承PI这种方法。</p><p>PI is where a process inherits the priority of another process if the other
process blocks on a lock owned by the current process. To make this easier
to understand, let&rsquo;s use the previous example, with processes A, B, and C again.</p><p>This time, when A blocks on the lock owned by C, C would inherit the priority
of A. So now if B becomes runnable, it would not preempt C, since C now has
the high priority of A. As soon as C releases the lock, it loses its
inherited priority, and A then can continue with the resource that C had.</p><p>以上个例子为例，引入PI，这次，当A等待C释放锁而阻塞时，C会继承A的优先级。所以如
果B运行的时候，它不会抢占C的CPU，因为C已经继承了A的优先级，A的优先级是最高的。
一旦C释放了锁之后，它就会失去从A继承来的优先级，A然后就会获得C释放的锁并继续执
行。</p><h2 id=terminology>Terminology <a href=#terminology class=anchor aria-hidden=true>#</a><a href=#terminology class=anchor aria-hidden=true>#</a></h2><p>Here I explain some terminology that is used in this document to help describe
the design that is used to implement PI.</p><p>PI chain - The PI chain is an ordered series of locks and processes that cause
processes to inherit priorities from a previous process that is
blocked on one of its locks. This is described in more detail
later in this document.</p><pre><code>       优先级继承链。
</code></pre><p>mutex - In this document, to differentiate from locks that implement PI and
spin locks that are used in the PI code, from now on the PI locks
will be called a mutex.</p><pre><code>       在这篇文档中，为了区分实现了优先级继承的锁，和实现该锁的代码中用到
       的普通的自旋锁，从现在开始，实现了优先级继承的锁，将被称为mutex。
</code></pre><p>lock - In this document from now on, I will use the term lock when
referring to spin locks that are used to protect parts of the PI
algorithm. These locks disable preemption for UP (when
CONFIG_PREEMPT is enabled) and on SMP prevents multiple
CPUs from entering critical sections simultaneously.</p><pre><code>       在这篇文档中，将使用lock指代自旋锁。
</code></pre><p>spin lock - Same as lock above.</p><pre><code>        自旋锁，与我们上面提到的lock，在描述PI锁的时候，将表示相同的概念。
</code></pre><p>waiter - A waiter is a struct that is stored on the stack of a blocked
process. Since the scope of the waiter is within the code for a
process being blocked on the mutex, it is fine to allocate the
waiter on the process&rsquo;s stack (local variable). This structure
holds a pointer to the task, as well as the mutex that the task is
blocked on. It also has the plist node structures to place the
task in the waiter_list of a mutex as well as the pi_list of a
mutex owner task (described below).</p><pre><code>       waiter is sometimes used in reference to the task that is waiting
       on a mutex. This is the same as waiter-&gt;task.
</code></pre><p>waiters - A list of processes that are blocked on a mutex.</p><p>top waiter - The highest priority process waiting on a specific mutex.</p><p>top pi waiter - The highest priority process waiting on one of the mutexes
that a specific process owns.</p><p>Note: task and process are used interchangeably in this document, mostly to
differentiate between two processes that are being described together.</p><h2 id=pi-chain>PI chain <a href=#pi-chain class=anchor aria-hidden=true>#</a><a href=#pi-chain class=anchor aria-hidden=true>#</a></h2><p>The PI chain is a list of processes and mutexes that may cause priority
inheritance to take place. Multiple chains may converge, but a chain
would never diverge, since a process can&rsquo;t be blocked on more than one
mutex at a time.</p><p>Example:</p><p>Process: A, B, C, D, E
Mutexes: L1, L2, L3, L4</p><pre><code>A owns: L1
        B blocked on L1
        B owns L2
               C blocked on L2
               C owns L3
                      D blocked on L3
                      D owns L4
                             E blocked on L4
</code></pre><p>The chain would be:</p><p>E->L4->D->L3->C->L2->B->L1->A</p><p>To show where two chains merge, we could add another process F and another
mutex L5 where B owns L5 and F is blocked on mutex L5.</p><p>The chain for F would be:</p><p>F->L5->B->L1->A</p><p>Since a process may own more than one mutex, but never be blocked on more than
one, the chains merge.</p><p>Here we show both chains:</p><pre><code>E-&gt;L4-&gt;D-&gt;L3-&gt;C-&gt;L2-+
                    |
                    +-&gt;B-&gt;L1-&gt;A
                    |
              F-&gt;L5-+
</code></pre><p>For PI to work, the processes at the right end of these chains (or we may also
call it the Top of the chain) must be equal to or higher in priority than the
processes to the left or below in the chain.</p><p>Also since a mutex may have more than one process blocked on it, we can have
multiple chains merge at mutexes. If we add another process G that is blocked
on mutex L2:</p><p>G->L2->B->L1->A</p><p>And once again, to show how this can grow I will show the merging chains
again.</p><pre><code>E-&gt;L4-&gt;D-&gt;L3-&gt;C-+
                +-&gt;L2-+
                |     |
              G-+     +-&gt;B-&gt;L1-&gt;A
                      |
                F-&gt;L5-+
</code></pre><h2 id=plist>Plist <a href=#plist class=anchor aria-hidden=true>#</a><a href=#plist class=anchor aria-hidden=true>#</a></h2><p>Before I go further and talk about how the PI chain is stored through lists on
both mutexes and processes, I&rsquo;ll explain the plist. This is similar to the
struct list_head functionality that is already in the kernel. The
implementation of plist is out of scope for this document, but it is very
important to understand what it does.</p><p>There are a few differences between plist and list, the most important one
being that plist is a priority sorted linked list. This means that the
priorities of the plist are sorted, such that it takes O(1) to retrieve the
highest priority item in the list. Obviously this is useful to store
processes based on their priorities.</p><p>Another difference, which is important for implementation, is that, unlike
list, the head of the list is a different element than the nodes of a list.
So the head of the list is declared as struct plist_head and nodes that will
be added to the list are declared as struct plist_node.</p><h2 id=mutex-waiter-list>Mutex Waiter List <a href=#mutex-waiter-list class=anchor aria-hidden=true>#</a><a href=#mutex-waiter-list class=anchor aria-hidden=true>#</a></h2><p>Every mutex keeps track of all the waiters that are blocked on itself. The
mutex has a plist to store these waiters by priority. This list is protected
by a spin lock that is located in the struct of the mutex. This lock is called
wait_lock. Since the modification of the waiter list is never done in
interrupt context, the wait_lock can be taken without disabling interrupts.</p><h2 id=task-pi-list>Task PI List <a href=#task-pi-list class=anchor aria-hidden=true>#</a><a href=#task-pi-list class=anchor aria-hidden=true>#</a></h2><p>To keep track of the PI chains, each process has its own PI list. This is a
list of all top waiters of the mutexes that are owned by the process. Note
that this list only holds the top waiters and not all waiters that are blocked
on mutexes owned by the process.</p><p>The top of the task&rsquo;s PI list is always the highest priority task that is
waiting on a mutex that is owned by the task. So if the task has inherited a
priority, it will always be the priority of the task that is at the top of
this list.</p><p>This list is stored in the task structure of a process as a plist called
pi_list. This list is protected by a spin lock also in the task structure,
called pi_lock. This lock may also be taken in interrupt context, so when
locking the pi_lock, interrupts must be disabled.</p><h2 id=depth-of-the-pi-chain>Depth of the PI Chain <a href=#depth-of-the-pi-chain class=anchor aria-hidden=true>#</a><a href=#depth-of-the-pi-chain class=anchor aria-hidden=true>#</a></h2><p>The maximum depth of the PI chain is not dynamic, and could actually be
defined. But is very complex to figure it out, since it depends on all the
nesting of mutexes. Let&rsquo;s look at the example where we have 3 mutexes, L1,
L2, and L3, and four separate functions func1, func2, func3 and func4. The
following shows a locking order of L1->L2->L3, but may not actually be
directly nested that way.</p><p>void func1(void)
{
mutex_lock(L1);</p><pre><code>/* do anything */

mutex_unlock(L1);
</code></pre><p>}</p><p>void func2(void)
{
mutex_lock(L1);
mutex_lock(L2);</p><pre><code>/* do something */

mutex_unlock(L2);
mutex_unlock(L1);
</code></pre><p>}</p><p>void func3(void)
{
mutex_lock(L2);
mutex_lock(L3);</p><pre><code>/* do something else */

mutex_unlock(L3);
mutex_unlock(L2);
</code></pre><p>}</p><p>void func4(void)
{
mutex_lock(L3);</p><pre><code>/* do something again */

mutex_unlock(L3);
</code></pre><p>}</p><p>Now we add 4 processes that run each of these functions separately. Processes
A, B, C, and D which run functions func1, func2, func3 and func4 respectively,
and such that D runs first and A last. With D being preempted in func4 in the
&ldquo;do something again&rdquo; area, we have a locking that follows:</p><p>D owns L3
C blocked on L3
C owns L2
B blocked on L2
B owns L1
A blocked on L1</p><p>And thus we have the chain A->L1->B->L2->C->L3->D.</p><p>This gives us a PI depth of 4 (four processes), but looking at any of the
functions individually, it seems as though they only have at most a locking
depth of two. So, although the locking depth is defined at compile time, it
still is very difficult to find the possibilities of that depth.</p><p>Now since mutexes can be defined by user-land applications, we don&rsquo;t want a
DOS type of application that nests large amounts of mutexes to create a large
PI chain, and have the code holding spin locks while looking at a large amount
of data. So to prevent this, the implementation not only implements a maximum
lock depth, but also only holds at most two different locks at a time, as it
walks the PI chain. More about this below.</p><h2 id=mutex-owner-and-flags>Mutex owner and flags <a href=#mutex-owner-and-flags class=anchor aria-hidden=true>#</a><a href=#mutex-owner-and-flags class=anchor aria-hidden=true>#</a></h2><p>The mutex structure contains a pointer to the owner of the mutex. If the
mutex is not owned, this owner is set to NULL. Since all architectures have
the task structure on at least a four byte alignment (and if this is not true,
the rtmutex.c code will be broken!), this allows for the two least significant
bits to be used as flags. This part is also described in
Documentation/rt-mutex.txt, but will also be briefly described here.</p><p>Bit 0 is used as the &ldquo;Pending Owner&rdquo; flag. This is described later.
Bit 1 is used as the &ldquo;Has Waiters&rdquo; flags. This is also described later in
more detail, but is set whenever there are waiters on a mutex.</p><h2 id=cmpxchg-tricks>cmpxchg Tricks <a href=#cmpxchg-tricks class=anchor aria-hidden=true>#</a><a href=#cmpxchg-tricks class=anchor aria-hidden=true>#</a></h2><p>Some architectures implement an atomic cmpxchg (Compare and Exchange). This
is used (when applicable) to keep the fast path of grabbing and releasing
mutexes short.</p><p>cmpxchg is basically the following function performed atomically:</p><p>unsigned long _cmpxchg(unsigned long *A, unsigned long *B, unsigned long *C)
{
unsigned long T = *A;
if (*A == *B) {
*A = *C;
}
return T;
}
#define cmpxchg(a,b,c) _cmpxchg(&a,&b,&c)</p><p>This is really nice to have, since it allows you to only update a variable if
the variable is what you expect it to be. You know if it succeeded if the
return value (the old value of A) is equal to B.</p><p>The macro rt_mutex_cmpxchg is used to try to lock and unlock mutexes. If the
architecture does not support CMPXCHG, then this macro is simply set to fail
every time. But if CMPXCHG is supported, then this will help out extremely to
keep the fast path short.</p><p>The use of rt_mutex_cmpxchg with the flags in the owner field help optimize
the system for architectures that support it. This will also be explained
later in this document.</p><h2 id=priority-adjustments>Priority adjustments <a href=#priority-adjustments class=anchor aria-hidden=true>#</a><a href=#priority-adjustments class=anchor aria-hidden=true>#</a></h2><p>The implementation of the PI code in rtmutex.c has several places that a
process must adjust its priority. With the help of the pi_list of a process
this is rather easy to know what needs to be adjusted.</p><p>The functions implementing the task adjustments are rt_mutex_adjust_prio,
__rt_mutex_adjust_prio (same as the former, but expects the task pi_lock to
already be taken), rt_mutex_getprio, and rt_mutex_setprio.</p><p>rt_mutex_getprio and rt_mutex_setprio are only used in __rt_mutex_adjust_prio.</p><p>rt_mutex_getprio returns the priority that the task should have. Either the
task&rsquo;s own normal priority, or if a process of a higher priority is waiting on
a mutex owned by the task, then that higher priority should be returned.
Since the pi_list of a task holds an order by priority list of all the top
waiters of all the mutexes that the task owns, rt_mutex_getprio simply needs
to compare the top pi waiter to its own normal priority, and return the higher
priority back.</p><p>(Note: if looking at the code, you will notice that the lower number of prio
is returned. This is because the prio field in the task structure is an
inverse order of the actual priority. So a &ldquo;prio&rdquo; of 5 is of higher priority
than a &ldquo;prio&rdquo; of 10.)</p><p>__rt_mutex_adjust_prio examines the result of rt_mutex_getprio, and if the
result does not equal the task&rsquo;s current priority, then rt_mutex_setprio is
called to adjust the priority of the task to the new priority. Note that
rt_mutex_setprio is defined in kernel/sched.c to implement the actual change
in priority.</p><p>It is interesting to note that __rt_mutex_adjust_prio can either increase or
decrease the priority of the task. In the case that a higher priority process
has just blocked on a mutex owned by the task, __rt_mutex_adjust_prio would
increase/boost the task&rsquo;s priority. But if a higher priority task were for
some reason to leave the mutex (timeout or signal), this same function would
decrease/unboost the priority of the task. That is because the pi_list always
contains the highest priority task that is waiting on a mutex owned by the
task, so we only need to compare the priority of that top pi waiter to the
normal priority of the given task.</p><h2 id=high-level-overview-of-the-pi-chain-walk>High level overview of the PI chain walk <a href=#high-level-overview-of-the-pi-chain-walk class=anchor aria-hidden=true>#</a><a href=#high-level-overview-of-the-pi-chain-walk class=anchor aria-hidden=true>#</a></h2><p>The PI chain walk is implemented by the function rt_mutex_adjust_prio_chain.</p><p>The implementation has gone through several iterations, and has ended up with
what we believe is the best. It walks the PI chain by only grabbing at most
two locks at a time, and is very efficient.</p><p>The rt_mutex_adjust_prio_chain can be used either to boost or lower process
priorities.</p><p>rt_mutex_adjust_prio_chain is called with a task to be checked for PI
(de)boosting (the owner of a mutex that a process is blocking on), a flag to
check for deadlocking, the mutex that the task owns, and a pointer to a waiter
that is the process&rsquo;s waiter struct that is blocked on the mutex (although
this parameter may be NULL for deboosting).</p><p>For this explanation, I will not mention deadlock detection. This explanation
will try to stay at a high level.</p><p>When this function is called, there are no locks held. That also means that
the state of the owner and lock can change when entered into this function.</p><p>Before this function is called, the task has already had rt_mutex_adjust_prio
performed on it. This means that the task is set to the priority that it
should be at, but the plist nodes of the task&rsquo;s waiter have not been updated
with the new priorities, and that this task may not be in the proper locations
in the pi_lists and wait_lists that the task is blocked on. This function
solves all that.</p><p>A loop is entered, where task is the owner to be checked for PI changes that
was passed by parameter (for the first iteration). The pi_lock of this task
is taken to prevent any more changes to the pi_list of the task. This also
prevents new tasks from completing the blocking on a mutex that is owned by
this task.</p><p>If the task is not blocked on a mutex then the loop is exited. We are at the
top of the PI chain.</p><p>A check is now done to see if the original waiter (the process that is blocked
on the current mutex) is the top pi waiter of the task. That is, is this
waiter on the top of the task&rsquo;s pi_list. If it is not, it either means that
there is another process higher in priority that is blocked on one of the
mutexes that the task owns, or that the waiter has just woken up via a signal
or timeout and has left the PI chain. In either case, the loop is exited,
since we don&rsquo;t need to do any more changes to the priority of the current
task, or any task that owns a mutex that this current task is waiting on.
A priority chain walk is only needed when a new top pi waiter is made to a
task.</p><p>The next check sees if the task&rsquo;s waiter plist node has the priority equal to
the priority the task is set at. If they are equal, then we are done with the
loop. Remember that the function started with the priority of the task
adjusted, but the plist nodes that hold the task in other processes pi_lists
have not been adjusted.</p><p>Next, we look at the mutex that the task is blocked on. The mutex&rsquo;s wait_lock
is taken. This is done by a spin_trylock, because the locking order of the
pi_lock and wait_lock goes in the opposite direction. If we fail to grab the
lock, the pi_lock is released, and we restart the loop.</p><p>Now that we have both the pi_lock of the task as well as the wait_lock of the
mutex the task is blocked on, we update the task&rsquo;s waiter&rsquo;s plist node that is
located on the mutex&rsquo;s wait_list.</p><p>Now we release the pi_lock of the task.</p><p>Next the owner of the mutex has its pi_lock taken, so we can update the task&rsquo;s
entry in the owner&rsquo;s pi_list. If the task is the highest priority process on
the mutex&rsquo;s wait_list, then we remove the previous top waiter from the owner&rsquo;s
pi_list, and replace it with the task.</p><p>Note: It is possible that the task was the current top waiter on the mutex, in
which case the task is not yet on the pi_list of the waiter. This is OK,
since plist_del does nothing if the plist node is not on any list.</p><p>If the task was not the top waiter of the mutex, but it was before we did the
priority updates, that means we are deboosting/lowering the task. In this
case, the task is removed from the pi_list of the owner, and the new top
waiter is added.</p><p>Lastly, we unlock both the pi_lock of the task, as well as the mutex&rsquo;s
wait_lock, and continue the loop again. On the next iteration of the loop,
the previous owner of the mutex will be the task that will be processed.</p><p>Note: One might think that the owner of this mutex might have changed since we
just grab the mutex&rsquo;s wait_lock. And one could be right. The important thing
to remember is that the owner could not have become the task that is being
processed in the PI chain, since we have taken that task&rsquo;s pi_lock at the
beginning of the loop. So as long as there is an owner of this mutex that is
not the same process as the tasked being worked on, we are OK.</p><p>Looking closely at the code, one might be confused. The check for the end of
the PI chain is when the task isn&rsquo;t blocked on anything or the task&rsquo;s waiter
structure &ldquo;task&rdquo; element is NULL. This check is protected only by the task&rsquo;s
pi_lock. But the code to unlock the mutex sets the task&rsquo;s waiter structure
&ldquo;task&rdquo; element to NULL with only the protection of the mutex&rsquo;s wait_lock,
which was not taken yet. Isn&rsquo;t this a race condition if the task becomes
the new owner?</p><p>The answer is No! The trick is the spin_trylock of the mutex&rsquo;s wait_lock. If
we fail that lock, we release the pi_lock of the task and continue the loop,
doing the end of PI chain check again.</p><p>In the code to release the lock, the wait_lock of the mutex is held the entire
time, and it is not let go when we grab the pi_lock of the new owner of the
mutex. So if the switch of a new owner were to happen after the check for end
of the PI chain and the grabbing of the wait_lock, the unlocking code would
spin on the new owner&rsquo;s pi_lock but never give up the wait_lock. So the PI
chain loop is guaranteed to fail the spin_trylock on the wait_lock, release
the pi_lock, and try again.</p><p>If you don&rsquo;t quite understand the above, that&rsquo;s OK. You don&rsquo;t have to, unless
you really want to make a proof out of it ;)</p><h2 id=pending-owners-and-lock-stealing>Pending Owners and Lock stealing <a href=#pending-owners-and-lock-stealing class=anchor aria-hidden=true>#</a><a href=#pending-owners-and-lock-stealing class=anchor aria-hidden=true>#</a></h2><p>One of the flags in the owner field of the mutex structure is &ldquo;Pending Owner&rdquo;.
What this means is that an owner was chosen by the process releasing the
mutex, but that owner has yet to wake up and actually take the mutex.</p><p>Why is this important? Why can&rsquo;t we just give the mutex to another process
and be done with it?</p><p>The PI code is to help with real-time processes, and to let the highest
priority process run as long as possible with little latencies and delays. If
a high priority process owns a mutex that a lower priority process is blocked
on, when the mutex is released it would be given to the lower priority
process. What if the higher priority process wants to take that mutex again.
The high priority process would fail to take that mutex that it just gave up
and it would need to boost the lower priority process to run with full latency
of that critical section (since the low priority process just entered it).</p><p>There&rsquo;s no reason a high priority process that gives up a mutex should be
penalized if it tries to take that mutex again. If the new owner of the mutex
has not woken up yet, there&rsquo;s no reason that the higher priority process could
not take that mutex away.</p><p>To solve this, we introduced Pending Ownership and Lock Stealing. When a new
process is given a mutex that it was blocked on, it is only given pending
ownership. This means that it&rsquo;s the new owner, unless a higher priority
process comes in and tries to grab that mutex. If a higher priority process
does come along and wants that mutex, we let the higher priority process
&ldquo;steal&rdquo; the mutex from the pending owner (only if it is still pending) and
continue with the mutex.</p><h2 id=taking-of-a-mutex-the-walk-through>Taking of a mutex (The walk through) <a href=#taking-of-a-mutex-the-walk-through class=anchor aria-hidden=true>#</a><a href=#taking-of-a-mutex-the-walk-through class=anchor aria-hidden=true>#</a></h2><p>OK, now let&rsquo;s take a look at the detailed walk through of what happens when
taking a mutex.</p><p>The first thing that is tried is the fast taking of the mutex. This is done
when we have CMPXCHG enabled (otherwise the fast taking automatically fails).
Only when the owner field of the mutex is NULL can the lock be taken with the
CMPXCHG and nothing else needs to be done.</p><p>If there is contention on the lock, whether it is owned or pending owner we go
about the slow path (rt_mutex_slowlock).</p><p>The slow path function is where the task&rsquo;s waiter structure is created on the
stack. This is because the waiter structure is only needed for the scope of
this function. The waiter structure holds the nodes to store the task on the
wait_list of the mutex, and if need be, the pi_list of the owner.</p><p>The wait_lock of the mutex is taken since the slow path of unlocking the mutex
also takes this lock.</p><p>We then call try_to_take_rt_mutex. This is where the architecture that does
not implement CMPXCHG would always grab the lock (if there&rsquo;s no contention).</p><p>try_to_take_rt_mutex is used every time the task tries to grab a mutex in the
slow path. The first thing that is done here is an atomic setting of the &ldquo;Has
Waiters&rdquo; flag of the mutex&rsquo;s owner field. Yes, this could really be false,
because if the mutex has no owner, there are no waiters and the current task
also won&rsquo;t have any waiters. But we don&rsquo;t have the lock yet, so we assume we
are going to be a waiter. The reason for this is to play nice for those
architectures that do have CMPXCHG. By setting this flag now, the owner of
the mutex can&rsquo;t release the mutex without going into the slow unlock path, and
it would then need to grab the wait_lock, which this code currently holds. So
setting the &ldquo;Has Waiters&rdquo; flag forces the owner to synchronize with this code.</p><p>Now that we know that we can&rsquo;t have any races with the owner releasing the
mutex, we check to see if we can take the ownership. This is done if the
mutex doesn&rsquo;t have a owner, or if we can steal the mutex from a pending owner.
Let&rsquo;s look at the situations we have here.</p><ol><li>Has owner that is pending</li></ol><hr><p>The mutex has a owner, but it hasn&rsquo;t woken up and the mutex flag &ldquo;Pending
Owner&rdquo; is set. The first check is to see if the owner isn&rsquo;t the current task.
This is because this function is also used for the pending owner to grab the
mutex. When a pending owner wakes up, it checks to see if it can take the
mutex, and this is done if the owner is already set to itself. If so, we
succeed and leave the function, clearing the &ldquo;Pending Owner&rdquo; bit.</p><p>If the pending owner is not current, we check to see if the current priority
is higher than the pending owner. If not, we fail the function and return.</p><p>There&rsquo;s also something special about a pending owner. That is a pending owner
is never blocked on a mutex. So there is no PI chain to worry about. It also
means that if the mutex doesn&rsquo;t have any waiters, there&rsquo;s no accounting needed
to update the pending owner&rsquo;s pi_list, since we only worry about processes
blocked on the current mutex.</p><p>If there are waiters on this mutex, and we just stole the ownership, we need
to take the top waiter, remove it from the pi_list of the pending owner, and
add it to the current pi_list. Note that at this moment, the pending owner is
no longer on the list of waiters. This is fine, since the pending owner would
add itself back when it realizes that it had the ownership stolen from itself.
When the pending owner tries to grab the mutex, it will fail in
try_to_take_rt_mutex if the owner field points to another process.</p><ol start=2><li>No owner</li></ol><hr><p>If there is no owner (or we successfully stole the lock), we set the owner of
the mutex to current, and set the flag of &ldquo;Has Waiters&rdquo; if the current mutex
actually has waiters, or we clear the flag if it doesn&rsquo;t. See, it was OK that
we set that flag early, since now it is cleared.</p><ol start=3><li>Failed to grab ownership</li></ol><hr><p>The most interesting case is when we fail to take ownership. This means that
there exists an owner, or there&rsquo;s a pending owner with equal or higher
priority than the current task.</p><p>We&rsquo;ll continue on the failed case.</p><p>If the mutex has a timeout, we set up a timer to go off to break us out of
this mutex if we failed to get it after a specified amount of time.</p><p>Now we enter a loop that will continue to try to take ownership of the mutex,
or fail from a timeout or signal.</p><p>Once again we try to take the mutex. This will usually fail the first time in
the loop, since it had just failed to get the mutex. But the second time in
the loop, this would likely succeed, since the task would likely be the
pending owner.</p><p>If the mutex is TASK_INTERRUPTIBLE a check for signals and timeout is done
here.</p><p>The waiter structure has a &ldquo;task&rdquo; field that points to the task that is
blocked on the mutex. This field can be NULL the first time it goes through
the loop or if the task is a pending owner and had its mutex stolen. If the
&ldquo;task&rdquo; field is NULL then we need to set up the accounting for it.</p><h2 id=task-blocks-on-mutex>Task blocks on mutex <a href=#task-blocks-on-mutex class=anchor aria-hidden=true>#</a><a href=#task-blocks-on-mutex class=anchor aria-hidden=true>#</a></h2><p>The accounting of a mutex and process is done with the waiter structure of the
process. The &ldquo;task&rdquo; field is set to the process, and the &ldquo;lock&rdquo; field to the
mutex. The plist nodes are initialized to the processes current priority.</p><p>Since the wait_lock was taken at the entry of the slow lock, we can safely add
the waiter to the wait_list. If the current process is the highest priority
process currently waiting on this mutex, then we remove the previous top
waiter process (if it exists) from the pi_list of the owner, and add the
current process to that list. Since the pi_list of the owner has changed, we
call rt_mutex_adjust_prio on the owner to see if the owner should adjust its
priority accordingly.</p><p>If the owner is also blocked on a lock, and had its pi_list changed (or
deadlock checking is on), we unlock the wait_lock of the mutex and go ahead
and run rt_mutex_adjust_prio_chain on the owner, as described earlier.</p><p>Now all locks are released, and if the current process is still blocked on a
mutex (waiter &ldquo;task&rdquo; field is not NULL), then we go to sleep (call schedule).</p><h2 id=waking-up-in-the-loop>Waking up in the loop <a href=#waking-up-in-the-loop class=anchor aria-hidden=true>#</a><a href=#waking-up-in-the-loop class=anchor aria-hidden=true>#</a></h2><p>The schedule can then wake up for a few reasons.</p><ol><li>we were given pending ownership of the mutex.</li><li>we received a signal and was TASK_INTERRUPTIBLE</li><li>we had a timeout and was TASK_INTERRUPTIBLE</li></ol><p>In any of these cases, we continue the loop and once again try to grab the
ownership of the mutex. If we succeed, we exit the loop, otherwise we
continue and on signal and timeout, will exit the loop, or if we had the mutex
stolen we just simply add ourselves back on the lists and go back to sleep.</p><p>Note: For various reasons, because of timeout and signals, the steal mutex
algorithm needs to be careful. This is because the current process is still on
the wait_list. And because of dynamic changing of priorities, especially on
SCHED_OTHER tasks, the current process can be the highest priority task on the
wait_list.</p><h2 id=failed-to-get-mutex-on-timeout-or-signal>Failed to get mutex on Timeout or Signal <a href=#failed-to-get-mutex-on-timeout-or-signal class=anchor aria-hidden=true>#</a><a href=#failed-to-get-mutex-on-timeout-or-signal class=anchor aria-hidden=true>#</a></h2><p>If a timeout or signal occurred, the waiter&rsquo;s &ldquo;task&rdquo; field would not be NULL
and the task needs to be taken off the wait_list of the mutex and perhaps
pi_list of the owner. If this process was a high priority process, then the
rt_mutex_adjust_prio_chain needs to be executed again on the owner, but this
time it will be lowering the priorities.</p><h2 id=unlocking-the-mutex>Unlocking the Mutex <a href=#unlocking-the-mutex class=anchor aria-hidden=true>#</a><a href=#unlocking-the-mutex class=anchor aria-hidden=true>#</a></h2><p>The unlocking of a mutex also has a fast path for those architectures with
CMPXCHG. Since the taking of a mutex on contention always sets the &ldquo;Has
Waiters&rdquo; flag of the mutex&rsquo;s owner, we use this to know if we need to take the
slow path when unlocking the mutex. If the mutex doesn&rsquo;t have any waiters,
the owner field of the mutex would equal the current process and the mutex can
be unlocked by just replacing the owner field with NULL.</p><p>If the owner field has the &ldquo;Has Waiters&rdquo; bit set (or CMPXCHG is not
available), the slow unlock path is taken.</p><p>The first thing done in the slow unlock path is to take the wait_lock of the
mutex. This synchronizes the locking and unlocking of the mutex.</p><p>A check is made to see if the mutex has waiters or not. On architectures that
do not have CMPXCHG, this is the location that the owner of the mutex will
determine if a waiter needs to be awoken or not. On architectures that do
have CMPXCHG, that check is done in the fast path, but it is still needed in
the slow path too. If a waiter of a mutex woke up because of a signal or
timeout between the time the owner failed the fast path CMPXCHG check and the
grabbing of the wait_lock, the mutex may not have any waiters, thus the owner
still needs to make this check. If there are no waiters then the mutex owner
field is set to NULL, the wait_lock is released and nothing more is needed.</p><p>If there are waiters, then we need to wake one up and give that waiter pending
ownership.</p><p>On the wake up code, the pi_lock of the current owner is taken. The top
waiter of the lock is found and removed from the wait_list of the mutex as
well as the pi_list of the current owner. The task field of the new pending
owner&rsquo;s waiter structure is set to NULL, and the owner field of the mutex is
set to the new owner with the &ldquo;Pending Owner&rdquo; bit set, as well as the &ldquo;Has
Waiters&rdquo; bit if there still are other processes blocked on the mutex.</p><p>The pi_lock of the previous owner is released, and the new pending owner&rsquo;s
pi_lock is taken. Remember that this is the trick to prevent the race
condition in rt_mutex_adjust_prio_chain from adding itself as a waiter on the
mutex.</p><p>We now clear the &ldquo;pi_blocked_on&rdquo; field of the new pending owner, and if the
mutex still has waiters pending, we add the new top waiter to the pi_list of
the pending owner.</p><p>Finally we unlock the pi_lock of the pending owner and wake it up.</p><p>[23] robust-futexes.txt</p><h2 id=background>Background <a href=#background class=anchor aria-hidden=true>#</a><a href=#background class=anchor aria-hidden=true>#</a></h2><p>what are robust futexes? To answer that, we first need to understand what
futexes are: normal futexes are special types of locks that in the
noncontended case can be acquired/released from userspace without having to
enter the kernel.</p><p>A futex is in essence a user-space address, e.g. a 32-bit lock variable field.
If userspace notices contention (the lock is already owned and someone else
wants to grab it too) then the lock is marked with a value that says &ldquo;there&rsquo;s
a waiter pending&rdquo;, and the sys_futex(FUTEX_WAIT) syscall is used to wait for
the other guy to release it. The kernel creates a &lsquo;futex queue&rsquo; internally, so
that it can later on match up the waiter with the waker - without them having
to know about each other. When the owner thread releases the futex, it
notices (via the variable value) that there were waiter(s) pending, and does
the sys_futex(FUTEX_WAKE) syscall to wake them up. Once all waiters have
taken and released the lock, the futex is again back to &lsquo;uncontended&rsquo; state,
and there&rsquo;s no in-kernel state associated with it. The kernel completely
forgets that there ever was a futex at that address. This method makes
futexes very lightweight and scalable.</p><p>&ldquo;Robustness&rdquo; is about dealing with crashes while holding a lock: if a process
exits prematurely while holding a pthread_mutex_t lock that is also shared
with some other process (e.g. yum segfaults while holding a pthread_mutex_t,
or yum is kill -9-ed), then waiters for that lock need to be notified that the
last owner of the lock exited in some irregular way.</p><p>To solve such types of problems, &ldquo;robust mutex&rdquo; userspace APIs were created:
pthread_mutex_lock() returns an error value if the owner exits prematurely -
and the new owner can decide whether the data protected by the lock can be
recovered safely.</p><p>There is a big conceptual problem with futex based mutexes though: it is the
kernel that destroys the owner task (e.g. due to a SEGFAULT), but the kernel
cannot help with the cleanup: if there is no &lsquo;futex queue&rsquo; (and in most cases
there is none, futexes being fast lightweight locks) then the kernel has no
information to clean up after the held lock! Userspace has no chance to clean
up after the lock either - userspace is the one that crashes, so it has no
opportunity to clean up. Catch-22.</p><p>In practice, when e.g. yum is kill -9-ed (or segfaults), a system reboot is
needed to release that futex based lock. This is one of the leading bugreports
against yum.</p><p>To solve this problem, the traditional approach was to extend the vma (virtual
memory area descriptor) concept to have a notion of &lsquo;pending robust futexes
attached to this area&rsquo;. This approach requires 3 new syscall variants to
sys_futex(): FUTEX_REGISTER, FUTEX_DEREGISTER and FUTEX_RECOVER. At do_exit()
time, all vmas are searched to see whether they have a robust_head set. This
approach has two fundamental problems left:</p><ul><li><p>it has quite complex locking and race scenarios. The vma-based approach had
been pending for years, but they are still not completely reliable.</p></li><li><p>they have to scan <em>every</em> vma at sys_exit() time, per thread!</p></li></ul><p>The second disadvantage is a real killer: pthread_exit() takes around 1
microsecond on Linux, but with thousands (or tens of thousands) of vmas every
pthread_exit() takes a millisecond or more, also totally destroying the CPU&rsquo;s
L1 and L2 caches!</p><p>This is very much noticeable even for normal process sys_exit_group() calls:
the kernel has to do the vma scanning unconditionally! (this is because the
kernel has no knowledge about how many robust futexes there are to be cleaned
up, because a robust futex might have been registered in another task, and the
futex variable might have been simply mmap()-ed into this process&rsquo;s address
space).</p><p>This huge overhead forced the creation of CONFIG_FUTEX_ROBUST so that normal
kernels can turn it off, but worse than that: the overhead makes robust
futexes impractical for any type of generic Linux distribution.</p><p>So something had to be done.</p><h2 id=new-approach-to-robust-futexes>New approach to robust futexes <a href=#new-approach-to-robust-futexes class=anchor aria-hidden=true>#</a><a href=#new-approach-to-robust-futexes class=anchor aria-hidden=true>#</a></h2><p>At the heart of this new approach there is a per-thread private list of robust
locks that userspace is holding (maintained by glibc) - which userspace list
is registered with the kernel via a new syscall [this registration happens at
most once per thread lifetime]. At do_exit() time, the kernel checks this
user-space list: are there any robust futex locks to be cleaned up?</p><p>In the common case, at do_exit() time, there is no list registered, so the
cost of robust futexes is just a simple current->robust_list != NULL
comparison. If the thread has registered a list, then normally the list is
empty. If the thread/process crashed or terminated in some incorrect way then
the list might be non-empty: in this case the kernel carefully walks the list
[not trusting it], and marks all locks that are owned by this thread with the
FUTEX_OWNER_DIED bit, and wakes up one waiter (if any).</p><p>The list is guaranteed to be private and per-thread at do_exit() time, so it
can be accessed by the kernel in a lockless way.</p><p>There is one race possible though: since adding to and removing from the list
is done after the futex is acquired by glibc, there is a few instructions
window for the thread (or process) to die there, leaving the futex hung. To
protect against this possibility, userspace (glibc) also maintains a simple
per-thread &lsquo;list_op_pending&rsquo; field, to allow the kernel to clean up if the
thread dies after acquiring the lock, but just before it could have added
itself to the list. Glibc sets this list_op_pending field before it tries to
acquire the futex, and clears it after the list-add (or list-remove) has
finished.</p><p>That&rsquo;s all that is needed - all the rest of robust-futex cleanup is done in
userspace [just like with the previous patches].</p><p>Ulrich Drepper has implemented the necessary glibc support for this new
mechanism, which fully enables robust mutexes.</p><p>Key differences of this userspace-list based approach, compared to the vma
based method:</p><ul><li><p>it&rsquo;s much, much faster: at thread exit time, there&rsquo;s no need to loop over
every vma (!), which the VM-based method has to do. Only a very simple &lsquo;is the
list empty&rsquo; op is done.</p></li><li><p>no VM changes are needed - &lsquo;struct address_space&rsquo; is left alone.</p></li><li><p>no registration of individual locks is needed: robust mutexes dont need any
extra per-lock syscalls. Robust mutexes thus become a very lightweight
primitive - so they dont force the application designer to do a hard choice
between performance and robustness - robust mutexes are just as fast.</p></li><li><p>no per-lock kernel allocation happens.</p></li><li><p>no resource limits are needed.</p></li><li><p>no kernel-space recovery call (FUTEX_RECOVER) is needed.</p></li><li><p>the implementation and the locking is &ldquo;obvious&rdquo;, and there are no
interactions with the VM.</p></li></ul><h2 id=performance>Performance <a href=#performance class=anchor aria-hidden=true>#</a><a href=#performance class=anchor aria-hidden=true>#</a></h2><p>I have benchmarked the time needed for the kernel to process a list of 1
million (!) held locks, using the new method [on a 2GHz CPU]:</p><ul><li>with FUTEX_WAIT set [contended mutex]: 130 msecs</li><li>without FUTEX_WAIT set [uncontended mutex]: 30 msecs</li></ul><p>I have also measured an approach where glibc does the lock notification [which
it currently does for !pshared robust mutexes], and that took 256 msecs -
clearly slower, due to the 1 million FUTEX_WAKE syscalls userspace had to do.</p><p>(1 million held locks are unheard of - we expect at most a handful of locks to
be held at a time. Nevertheless it&rsquo;s nice to know that this approach scales
nicely.)</p><h2 id=implementation-details>Implementation details <a href=#implementation-details class=anchor aria-hidden=true>#</a><a href=#implementation-details class=anchor aria-hidden=true>#</a></h2><p>The patch adds two new syscalls: one to register the userspace list, and one
to query the registered list pointer:</p><p>asmlinkage long
sys_set_robust_list(struct robust_list_head __user *head,
size_t len);</p><p>asmlinkage long
sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,
size_t __user *len_ptr);</p><p>List registration is very fast: the pointer is simply stored in
current->robust_list. [Note that in the future, if robust futexes become
widespread, we could extend sys_clone() to register a robust-list head for new
threads, without the need of another syscall.]</p><p>So there is virtually zero overhead for tasks not using robust futexes, and
even for robust futex users, there is only one extra syscall per thread
lifetime, and the cleanup operation, if it happens, is fast and
straightforward. The kernel doesn&rsquo;t have any internal distinction between
robust and normal futexes.</p><p>If a futex is found to be held at exit time, the kernel sets the following bit
of the futex word:</p><p>#define FUTEX_OWNER_DIED 0x40000000</p><p>and wakes up the next futex waiter (if any). User-space does the rest of the
cleanup.</p><p>Otherwise, robust futexes are acquired by glibc by putting the TID into the
futex field atomically. Waiters set the FUTEX_WAITERS bit:</p><p>#define FUTEX_WAITERS 0x80000000</p><p>and the remaining bits are for the TID.</p><h2 id=testing-architecture-support>Testing, architecture support <a href=#testing-architecture-support class=anchor aria-hidden=true>#</a><a href=#testing-architecture-support class=anchor aria-hidden=true>#</a></h2><p>i&rsquo;ve tested the new syscalls on x86 and x86_64, and have made sure the parsing
of the userspace list is robust [ ;-) ] even if the list is deliberately
corrupted.</p><p>i386 and x86_64 syscalls are wired up at the moment, and Ulrich has tested the
new glibc code (on x86_64 and i386), and it works for his robust-mutex
testcases.</p><p>All other architectures should build just fine too - but they wont have the
new syscalls yet.</p><p>Architectures need to implement the new futex_atomic_cmpxchg_inatomic() inline
function before writing up the syscalls (that function returns -ENOSYS right
now).</p><p>[24] robust-futex-ABI.txt</p><h2 id=robust-futex>The robust futex ABI
robust futex <a href=#robust-futex class=anchor aria-hidden=true>#</a></h2><p>Robust_futexes provide a mechanism that is used in addition to normal futexes,
for kernel assist of cleanup of held locks on task exit.</p><p>robust futex除了提供futex的功能之外，它还提供了一种机制，在任务结束时用于辅助
内核对任务持有的锁进行清理。</p><p>The interesting data as to what futexes a thread is holding is kept on a
linked list in user space, where it can be updated efficiently as locks are
taken and dropped, without kernel intervention. The only additional kernel
intervention required for robust_futexes above and beyond what is required for
futexes is:</p><p>我们关心的数据是线程持有的futexes，这些树需被保存在用户空间的一个链表中，当被
加锁或者锁被释放时，这个链表中的数据可以被高效地更新，这一过程不许要内核的干预
。针对我们上面提到的robust_futexes，内核对它的唯一干预以及它相对于futexes添加
的功能包括：</p><ol><li>a one time call, per thread, to tell the kernel where its list of held
robust_futexes begins, and</li><li>internal kernel code at exit, to handle any listed locks held by the
exiting thread.</li></ol><p>The existing normal futexes already provide a &ldquo;Fast Userspace Locking&rdquo;
mechanism, which handles uncontested locking without needing a system call,
and handles contested locking by maintaining a list of waiting threads in
the kernel. Options on the sys_futex(2) system call support waiting on a
particular futex, and waking up the next waiter on a particular futex.</p><p>For robust_futexes to work, the user code (typically in a library such as
glibc linked with the application) has to manage and place the necessary list
elements exactly as the kernel expects them. If it fails to do so, then
improperly listed locks will not be cleaned up on exit, probably causing
deadlock or other such failure of the other threads waiting on the same locks.</p><p>A thread that anticipates possibly using robust_futexes should first issue the
system call:</p><p>asmlinkage long
sys_set_robust_list(struct robust_list_head __user *head, size_t len);</p><p>The pointer &lsquo;head&rsquo; points to a structure in the threads address space
consisting of three words. Each word is 32 bits on 32 bit arch&rsquo;s, or 64 bits
on 64 bit arch&rsquo;s, and local byte order. Each thread should have its own
thread private &lsquo;head&rsquo;.</p><p>If a thread is running in 32 bit compatibility mode on a 64 native arch
kernel, then it can actually have two such structures - one using 32 bit words
for 32 bit compatibility mode, and one using 64 bit words for 64 bit native
mode. The kernel, if it is a 64 bit kernel supporting 32 bit compatibility
mode, will attempt to process both lists on each task exit, if the
corresponding sys_set_robust_list() call has been made to setup that list.</p><p>The first word in the memory structure at &lsquo;head&rsquo; contains a pointer to a
single linked list of &lsquo;lock entries&rsquo;, one per lock, as described below. If
the list is empty, the pointer will point to itself, &lsquo;head&rsquo;. The last &lsquo;lock
entry&rsquo; points back to the &lsquo;head&rsquo;.</p><p>The second word, called &lsquo;offset&rsquo;, specifies the offset from the address of the
associated &lsquo;lock entry&rsquo;, plus or minus, of what will be called the &lsquo;lock
word&rsquo;, from that &lsquo;lock entry&rsquo;. The &lsquo;lock word&rsquo; is always a 32 bit word,
unlike the other words above. The &lsquo;lock word&rsquo; holds 3 flag bits in the
upper 3 bits, and the thread id (TID) of the thread holding the lock in
the bottom 29 bits. See further below for a description of the flag bits.</p><p>The third word, called &lsquo;list_op_pending&rsquo;, contains transient copy of the
address of the &lsquo;lock entry&rsquo;, during list insertion and removal, and is needed
to correctly resolve races should a thread exit while in the middle of a
locking or unlocking operation.</p><p>Each &lsquo;lock entry&rsquo; on the single linked list starting at &lsquo;head&rsquo; consists of
just a single word, pointing to the next &lsquo;lock entry&rsquo;, or back to &lsquo;head&rsquo; if
there are no more entries. In addition, nearby to each &lsquo;lock entry&rsquo;, at an
offset from the &lsquo;lock entry&rsquo; specified by the &lsquo;offset&rsquo; word, is one &lsquo;lock
word&rsquo;.</p><p>The &lsquo;lock word&rsquo; is always 32 bits, and is intended to be the same 32 bit lock
variable used by the futex mechanism, in conjunction with robust_futexes. The
kernel will only be able to wakeup the next thread waiting for a lock on a
threads exit if that next thread used the futex mechanism to register the
address of that &lsquo;lock word&rsquo; with the kernel.</p><p>For each futex lock currently held by a thread, if it wants this robust_futex
support for exit cleanup of that lock, it should have one &lsquo;lock entry&rsquo; on this
list, with its associated &lsquo;lock word&rsquo; at the specified &lsquo;offset&rsquo;. Should a
thread die while holding any such locks, the kernel will walk this list, mark
any such locks with a bit indicating their holder died, and wakeup the next
thread waiting for that lock using the futex mechanism.</p><p>When a thread has invoked the above system call to indicate it anticipates
using robust_futexes, the kernel stores the passed in &lsquo;head&rsquo; pointer for that
task. The task may retrieve that value later on by using the system call:</p><p>asmlinkage long
sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,
size_t __user *len_ptr);</p><p>It is anticipated that threads will use robust_futexes embedded in larger,
user level locking structures, one per lock. The kernel robust_futex
mechanism doesn&rsquo;t care what else is in that structure, so long as the &lsquo;offset&rsquo;
to the &lsquo;lock word&rsquo; is the same for all robust_futexes used by that thread.
The thread should link those locks it currently holds using the &lsquo;lock entry&rsquo;
pointers. It may also have other links between the locks, such as the reverse
side of a double linked list, but that doesn&rsquo;t matter to the kernel.</p><p>By keeping its locks linked this way, on a list starting with a &lsquo;head&rsquo; pointer
known to the kernel, the kernel can provide to a thread the essential service
available for robust_futexes, which is to help clean up locks held at the time
of (a perhaps unexpectedly) exit.</p><p>Actual locking and unlocking, during normal operations, is handled entirely by
user level code in the contending threads, and by the existing futex mechanism
to wait for, and wakeup, locks. The kernels only essential involvement in
robust_futexes is to remember where the list &lsquo;head&rsquo; is, and to walk the list
on thread exit, handling locks still held by the departing thread, as
described below.</p><p>There may exist thousands of futex lock structures in a threads shared memory,
on various data structures, at a given point in time. Only those lock
structures for locks currently held by that thread should be on that thread&rsquo;s
robust_futex linked lock list a given time.</p><p>A given futex lock structure in a user shared memory region may be held at
different times by any of the threads with access to that region. The thread
currently holding such a lock, if any, is marked with the threads TID in the
lower 29 bits of the &lsquo;lock word&rsquo;.</p><p>When adding or removing a lock from its list of held locks, in order for the
kernel to correctly handle lock cleanup regardless of when the task exits
(perhaps it gets an unexpected signal 9 in the middle of manipulating this
list), the user code must observe the following protocol on &lsquo;lock entry&rsquo;
insertion and removal:</p><p>On insertion:</p><ol><li>set the &lsquo;list_op_pending&rsquo; word to the address of the &lsquo;lock entry&rsquo; to be
inserted,</li><li>acquire the futex lock,</li><li>add the lock entry, with its thread id (TID) in the bottom 29 bits of the
&lsquo;lock word&rsquo;, to the linked list starting at &lsquo;head&rsquo;, and</li><li>clear the &lsquo;list_op_pending&rsquo; word.</li></ol><p>On removal:</p><ol><li>set the &lsquo;list_op_pending&rsquo; word to the address of the &lsquo;lock entry&rsquo; to be
removed,</li><li>remove the lock entry for this lock from the &lsquo;head&rsquo; list,</li><li>release the futex lock, and</li><li>clear the &lsquo;lock_op_pending&rsquo; word.</li></ol><p>On exit, the kernel will consider the address stored in &lsquo;list_op_pending&rsquo; and
the address of each &lsquo;lock word&rsquo; found by walking the list starting at &lsquo;head&rsquo;.
For each such address, if the bottom 29 bits of the &lsquo;lock word&rsquo; at offset
&lsquo;offset&rsquo; from that address equals the exiting threads TID, then the kernel
will do two things:</p><ol><li>if bit 31 (0x80000000) is set in that word, then attempt a futex wakeup on
that address, which will waken the next thread that has used to the futex
mechanism to wait on that address, and</li><li>atomically set bit 30 (0x40000000) in the &lsquo;lock word&rsquo;.</li></ol><p>In the above, bit 31 was set by futex waiters on that lock to indicate they
were waiting, and bit 30 is set by the kernel to indicate that the lock owner
died holding the lock.</p><p>The kernel exit code will silently stop scanning the list further if at any
point:</p><ol><li>the &lsquo;head&rsquo; pointer or an subsequent linked list pointer is not a valid
address of a user space word</li><li>the calculated location of the &lsquo;lock word&rsquo; (address plus &lsquo;offset&rsquo;) is not
the valid address of a 32 bit user space word</li><li>if the list contains more than 1 million (subject to future kernel
configuration changes) elements.</li></ol><p>When the kernel sees a list entry whose &lsquo;lock word&rsquo; doesn&rsquo;t have the current
threads TID in the lower 29 bits, it does nothing with that entry, and goes on
to the next entry.</p><p>Bit 29 (0x20000000) of the &lsquo;lock word&rsquo; is reserved for future use.</p><h1 id=sat-sep-20-002548-cst-2014>=============================================================================
Sat Sep 20 00:25:48 CST 2014 <a href=#sat-sep-20-002548-cst-2014 class=anchor aria-hidden=true>#</a></h1><p>[25] rfkill.txt</p><p>rfkill - RF kill switch support</p><p>The rfkill subsystem provides a generic interface to disabling any radio
transmitter in the system. When a transmitter is blocked, it shall not
radiate any power.</p><p>The subsystem also provides the ability to react on button presses and
disable all transmitters of a certain type (or all). This is intended for
situations where transmitters need to be turned off, for example on
aircraft.</p><p>The rfkill subsystem has a concept of &ldquo;hard&rdquo; and &ldquo;soft&rdquo; block, which
differ little in their meaning (block == transmitters off) but rather in
whether they can be changed or not:</p><ul><li>hard block: read-only radio block that cannot be overriden by software</li><li>soft block: writable radio block (need not be readable) that is set by
the system software.</li></ul><p>[26] rbtree.txt</p><h2 id=what-are-red-black-trees-and-what-are-they-for><strong>What are red-black trees, and what are they for?</strong> <a href=#what-are-red-black-trees-and-what-are-they-for class=anchor aria-hidden=true>#</a><a href=#what-are-red-black-trees-and-what-are-they-for class=anchor aria-hidden=true>#</a></h2><p><strong>Red-black trees are a type of self-balancing binary search tree, used for</strong>
<strong>storing sortable key/value data pairs. This differs from radix trees (which</strong>
<strong>are used to efficiently store sparse arrays and thus use long integer indexes</strong>
<strong>to insert/access/delete nodes) and hash tables (which are not kept sorted to</strong>
<strong>be easily traversed in order, and must be tuned for a specific size and</strong>
<strong>hash function where rbtrees scale gracefully storing arbitrary keys).</strong></p><p>Red-black trees are similar to AVL trees, but provide faster real-time bounded
worst case performance for insertion and deletion (at most two rotations and
three rotations, respectively, to balance the tree), with slightly slower
(but still O(log n)) lookup time.</p><p>To quote Linux Weekly News:</p><p>There are a number of red-black trees in use in the kernel.
The deadline and CFQ I/O schedulers employ rbtrees to
track requests; the packet CD/DVD driver does the same.
The high-resolution timer code uses an rbtree to organize outstanding
timer requests. The ext3 filesystem tracks directory entries in a
red-black tree. Virtual memory areas (VMAs) are tracked with red-black
trees, as are epoll file descriptors, cryptographic keys, and network
packets in the &ldquo;hierarchical token bucket&rdquo; scheduler.</p><p>[27] ramoops.txt</p><p>Ramoops is an oops/panic logger that writes its logs to RAM before the system
crashes. It works by logging oopses and panics in a circular buffer. Ramoops
needs a system with persistent RAM so that the content of that area can
survive after a restart.</p><p>[28] prio_tree.txt</p><p>[29] printk-formats.txt</p><p>[30] preempt-locking.txt</p><p>[31] pnp.txt</p><p>Plug and Play provides a means of detecting and setting resources for legacy or
otherwise unconfigurable devices. The Linux Plug and Play Layer provides these
services to compatible drivers.</p><p>[32] pinctrl.txt</p><p>[33] pi-futex.txt</p><p>类似与rt-mutex的实现。</p><p>[34] parport.txt
[35] parport-lowlevel.txt</p><p>The `parport' code provides parallel-port support under Linux. This includes
the ability to share one port between multiple device drivers.</p><p>[36] padata.txt</p><p>Padata is a mechanism by which the kernel can farm work out to be done in
parallel on multiple CPUs while retaining the ordering of tasks. It was
developed for use with the IPsec code, which needs to be able to perform
encryption and decryption on large numbers of packets without reordering those
packets. The crypto developers made a point of writing padata in a
sufficiently general fashion that it could be put to other uses as well.</p><p>[37] oops-tracing.txt</p><p>[38] 00-INDEX</p><p>This is a brief list of all the files in ./linux/Documentation and what they
contain. If you add a documentation file, please list it here in alphabetical
order as well, or risk being hunted down like a rabid dog. Please try and
keep the descriptions small enough to fit on one line.</p><p>[39] Changes</p><p>This document is designed to provide a list of the minimum levels of software
necessary to run the 3.0 kernels.</p><h1 id=sat-sep-20-100348-cst-2014>=============================================================================
Sat Sep 20 10:03:48 CST 2014 <a href=#sat-sep-20-100348-cst-2014 class=anchor aria-hidden=true>#</a></h1><p>[40] CodingStyle.txt</p><pre><code>            Linux kernel coding style
</code></pre><p>This is a short document describing the preferred coding style for the
linux kernel. Coding style is very personal, and I won&rsquo;t <em>force</em> my
views on anybody, but this is what goes for anything that I have to be
able to maintain, and I&rsquo;d prefer it for most other things too. Please
at least consider the points made here.</p><p>First off, I&rsquo;d suggest printing out a copy of the GNU coding standards,
and NOT read it. Burn them, it&rsquo;s a great symbolic gesture.</p><p>Anyway, here goes:</p><pre><code>            Chapter 1: Indentation
</code></pre><p>Tabs are 8 characters, and thus indentations are also 8 characters.
There are heretic movements that try to make indentations 4 (or even 2!)
characters deep, and that is akin to trying to define the value of PI to
be 3.</p><p>Rationale: The whole idea behind indentation is to clearly define where
a block of control starts and ends. Especially when you&rsquo;ve been looking
at your screen for 20 straight hours, you&rsquo;ll find it a lot easier to see
how the indentation works if you have large indentations.</p><p>Now, some people will claim that having 8-character indentations makes
the code move too far to the right, and makes it hard to read on a
80-character terminal screen. The answer to that is that if you need
more than 3 levels of indentation, you&rsquo;re screwed anyway, and should fix
your program.</p><p>In short, 8-char indents make things easier to read, and have the added
benefit of warning you when you&rsquo;re nesting your functions too deep.
Heed that warning.</p><p>The preferred way to ease multiple indentation levels in a switch statement is
to align the &ldquo;switch&rdquo; and its subordinate &ldquo;case&rdquo; labels in the same column
instead of &ldquo;double-indenting&rdquo; the &ldquo;case&rdquo; labels. E.g.:</p><pre><code>    switch (suffix) {
    case 'G':
    case 'g':
            mem &lt;&lt;= 30;
            break;
    case 'M':
    case 'm':
            mem &lt;&lt;= 20;
            break;
    case 'K':
    case 'k':
            mem &lt;&lt;= 10;
            /* fall through */
    default:
            break;
    }
</code></pre><p>Don&rsquo;t put multiple statements on a single line unless you have
something to hide:</p><pre><code>    if (condition) do_this;
      do_something_everytime;
</code></pre><p>Don&rsquo;t put multiple assignments on a single line either. Kernel coding style
is super simple. Avoid tricky expressions.</p><p>Outside of comments, documentation and except in Kconfig, spaces are never
used for indentation, and the above example is deliberately broken.</p><p>Get a decent editor and don&rsquo;t leave whitespace at the end of lines.</p><pre><code>            Chapter 2: Breaking long lines and strings
</code></pre><p>Coding style is all about readability and maintainability using commonly
available tools.</p><p>The limit on the length of lines is 80 columns and this is a strongly
preferred limit.</p><p>Statements longer than 80 columns will be broken into sensible chunks, unless
exceeding 80 columns significantly increases readability and does not hide
information. Descendants are always substantially shorter than the parent and
are placed substantially to the right. The same applies to function headers
with a long argument list. However, never break user-visible strings such as
printk messages, because that breaks the ability to grep for them.</p><pre><code>            Chapter 3: Placing Braces and Spaces
</code></pre><p>The other issue that always comes up in C styling is the placement of
braces. Unlike the indent size, there are few technical reasons to
choose one placement strategy over the other, but the preferred way, as
shown to us by the prophets Kernighan and Ritchie, is to put the opening
brace last on the line, and put the closing brace first, thusly:</p><pre><code>    if (x is true) {
            we do y
    }
</code></pre><p>This applies to all non-function statement blocks (if, switch, for,
while, do). E.g.:</p><pre><code>    switch (action) {
    case KOBJ_ADD:
            return &quot;add&quot;;
    case KOBJ_REMOVE:
            return &quot;remove&quot;;
    case KOBJ_CHANGE:
            return &quot;change&quot;;
    default:
            return NULL;
    }
</code></pre><p>However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus:</p><pre><code>    int function(int x)
    {
            body of function
    }
</code></pre><p>Heretic people all over the world have claimed that this inconsistency
is &mldr; well &mldr; inconsistent, but all right-thinking people know that
(a) K&R are <em>right</em> and (b) K&R are right. Besides, functions are
special anyway (you can&rsquo;t nest them in C).</p><p>Note that the closing brace is empty on a line of its own, <em>except</em> in
the cases where it is followed by a continuation of the same statement,
ie a &ldquo;while&rdquo; in a do-statement or an &ldquo;else&rdquo; in an if-statement, like
this:</p><pre><code>    do {
            body of do-loop
    } while (condition);
</code></pre><p>and</p><pre><code>    if (x == y) {
            ..
    } else if (x &gt; y) {
            ...
    } else {
            ....
    }
</code></pre><p>Rationale: K&R.</p><p>Also, note that this brace-placement also minimizes the number of empty
(or almost empty) lines, without any loss of readability. Thus, as the
supply of new-lines on your screen is not a renewable resource (think
25-line terminal screens here), you have more empty lines to put
comments on.</p><p>Do not unnecessarily use braces where a single statement will do.</p><p>if (condition)
action();</p><p>and</p><p>if (condition)
do_this();
else
do_that();</p><p>This does not apply if only one branch of a conditional statement is a single
statement; in the latter case use braces in both branches:</p><p>if (condition) {
do_this();
do_that();
} else {
otherwise();
}</p><pre><code>            3.1:  Spaces
</code></pre><p>Linux kernel style for use of spaces depends (mostly) on
function-versus-keyword usage. Use a space after (most) keywords. The
notable exceptions are sizeof, typeof, alignof, and <strong>attribute</strong>, which look
somewhat like functions (and are usually used with parentheses in Linux,
although they are not required in the language, as in: &ldquo;sizeof info&rdquo; after
&ldquo;struct fileinfo info;&rdquo; is declared).</p><p>So use a space after these keywords:
if, switch, case, for, do, while
but not with sizeof, typeof, alignof, or <strong>attribute</strong>. E.g.,
s = sizeof(struct file);</p><p>Do not add spaces around (inside) parenthesized expressions. This example is
<em>bad</em>:</p><pre><code>    s = sizeof( struct file );
</code></pre><p>When declaring pointer data or a function that returns a pointer type, the
preferred use of &lsquo;*&rsquo; is adjacent to the data name or function name and not
adjacent to the type name. Examples:</p><pre><code>    char *linux_banner;
    unsigned long long memparse(char *ptr, char **retptr);
    char *match_strdup(substring_t *s);
</code></pre><p>Use one space around (on each side of) most binary and ternary operators,
such as any of these:</p><pre><code>    =  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :
</code></pre><p>but no space after unary operators:
& * + - ~ ! sizeof typeof alignof <strong>attribute</strong> defined</p><p>no space before the postfix increment & decrement unary operators:
++ &ndash;</p><p>no space after the prefix increment & decrement unary operators:
++ &ndash;</p><p>and no space around the &lsquo;.&rsquo; and &ldquo;->&rdquo; structure member operators.</p><p>Do not leave trailing whitespace at the ends of lines. Some editors with
&ldquo;smart&rdquo; indentation will insert whitespace at the beginning of new lines as
appropriate, so you can start typing the next line of code right away.
However, some such editors do not remove the whitespace if you end up not
putting a line of code there, such as if you leave a blank line. As a result,
you end up with lines containing trailing whitespace.</p><p>Git will warn you about patches that introduce trailing whitespace, and can
optionally strip the trailing whitespace for you; however, if applying a series
of patches, this may make later patches in the series fail by changing their
context lines.</p><pre><code>            Chapter 4: Naming
</code></pre><p>C is a Spartan language, and so should your naming be. Unlike Modula-2
and Pascal programmers, C programmers do not use cute names like
ThisVariableIsATemporaryCounter. A C programmer would call that
variable &ldquo;tmp&rdquo;, which is much easier to write, and not the least more
difficult to understand.</p><p>HOWEVER, while mixed-case names are frowned upon, descriptive names for
global variables are a must. To call a global function &ldquo;foo&rdquo; is a
shooting offense.</p><p>GLOBAL variables (to be used only if you <em>really</em> need them) need to
have descriptive names, as do global functions. If you have a function
that counts the number of active users, you should call that
&ldquo;count_active_users()&rdquo; or similar, you should <em>not</em> call it &ldquo;cntusr()&rdquo;.</p><p>Encoding the type of a function into the name (so-called Hungarian
notation) is brain damaged - the compiler knows the types anyway and can
check those, and it only confuses the programmer. No wonder MicroSoft
makes buggy programs.</p><p>LOCAL variable names should be short, and to the point. If you have
some random integer loop counter, it should probably be called &ldquo;i&rdquo;.
Calling it &ldquo;loop_counter&rdquo; is non-productive, if there is no chance of it
being mis-understood. Similarly, &ldquo;tmp&rdquo; can be just about any type of
variable that is used to hold a temporary value.</p><p>If you are afraid to mix up your local variable names, you have another
problem, which is called the function-growth-hormone-imbalance syndrome.
See chapter 6 (Functions).</p><pre><code>            Chapter 5: Typedefs
</code></pre><p>Please don&rsquo;t use things like &ldquo;vps_t&rdquo;.</p><p>It&rsquo;s a <em>mistake</em> to use typedef for structures and pointers. When you see a</p><pre><code>    vps_t a;
</code></pre><p>in the source, what does it mean?</p><p>In contrast, if it says</p><pre><code>    struct virtual_container *a;
</code></pre><p>you can actually tell what &ldquo;a&rdquo; is.</p><p>Lots of people think that typedefs &ldquo;help readability&rdquo;. Not so. They are
useful only for:</p><p>(a) totally opaque objects (where the typedef is actively used to <em>hide</em>
what the object is).</p><pre><code> Example: &quot;pte_t&quot; etc. opaque objects that you can only access using
 the proper accessor functions.

 NOTE! Opaqueness and &quot;accessor functions&quot; are not good in themselves.
 The reason we have them for things like pte_t etc. is that there
 really is absolutely _zero_ portably accessible information there.
</code></pre><p>(b) Clear integer types, where the abstraction <em>helps</em> avoid confusion
whether it is &ldquo;int&rdquo; or &ldquo;long&rdquo;.</p><pre><code> u8/u16/u32 are perfectly fine typedefs, although they fit into
 category (d) better than here.

 NOTE! Again - there needs to be a _reason_ for this. If something is
 &quot;unsigned long&quot;, then there's no reason to do

    typedef unsigned long myflags_t;

 but if there is a clear reason for why it under certain circumstances
 might be an &quot;unsigned int&quot; and under other configurations might be
 &quot;unsigned long&quot;, then by all means go ahead and use a typedef.
</code></pre><p>(c) when you use sparse to literally create a <em>new</em> type for
type-checking.</p><p>(d) New types which are identical to standard C99 types, in certain
exceptional circumstances.</p><pre><code> Although it would only take a short amount of time for the eyes and
 brain to become accustomed to the standard types like 'uint32_t',
 some people object to their use anyway.

 Therefore, the Linux-specific 'u8/u16/u32/u64' types and their
 signed equivalents which are identical to standard types are
 permitted -- although they are not mandatory in new code of your
 own.

 When editing existing code which already uses one or the other set
 of types, you should conform to the existing choices in that code.
</code></pre><p>(e) Types safe for use in userspace.</p><pre><code> In certain structures which are visible to userspace, we cannot
 require C99 types and cannot use the 'u32' form above. Thus, we
 use __u32 and similar types in all structures which are shared
 with userspace.
</code></pre><p>Maybe there are other cases too, but the rule should basically be to NEVER
EVER use a typedef unless you can clearly match one of those rules.</p><p>In general, a pointer, or a struct that has elements that can reasonably
be directly accessed should <em>never</em> be a typedef.</p><pre><code>            Chapter 6: Functions
</code></pre><p>Functions should be short and sweet, and do just one thing. They should
fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24,
as we all know), and do one thing and do that well.</p><p>The maximum length of a function is inversely proportional to the
complexity and indentation level of that function. So, if you have a
conceptually simple function that is just one long (but simple)
case-statement, where you have to do lots of small things for a lot of
different cases, it&rsquo;s OK to have a longer function.</p><p>However, if you have a complex function, and you suspect that a
less-than-gifted first-year high-school student might not even
understand what the function is all about, you should adhere to the
maximum limits all the more closely. Use helper functions with
descriptive names (you can ask the compiler to in-line them if you think
it&rsquo;s performance-critical, and it will probably do a better job of it
than you would have done).</p><p>Another measure of the function is the number of local variables. They
shouldn&rsquo;t exceed 5-10, or you&rsquo;re doing something wrong. Re-think the
function, and split it into smaller pieces. A human brain can
generally easily keep track of about 7 different things, anything more
and it gets confused. You know you&rsquo;re brilliant, but maybe you&rsquo;d like
to understand what you did 2 weeks from now.</p><p>In source files, separate functions with one blank line. If the function is
exported, the EXPORT* macro for it should follow immediately after the closing
function brace line. E.g.:</p><p>int system_is_up(void)
{
return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);</p><p>In function prototypes, include parameter names with their data types.
Although this is not required by the C language, it is preferred in Linux
because it is a simple way to add valuable information for the reader.</p><pre><code>            Chapter 7: Centralized exiting of functions
</code></pre><p>Albeit deprecated by some people, the equivalent of the goto statement is
used frequently by compilers in form of the unconditional jump instruction.</p><p>The goto statement comes in handy when a function exits from multiple
locations and some common work such as cleanup has to be done.</p><p>The rationale is:</p><ul><li>unconditional statements are easier to understand and follow</li><li>nesting is reduced</li><li>errors by not updating individual exit points when making
modifications are prevented</li><li>saves the compiler work to optimize redundant code away ;)</li></ul><p>int fun(int a)
{
int result = 0;
char *buffer = kmalloc(SIZE);</p><pre><code>    if (buffer == NULL)
            return -ENOMEM;

    if (condition1) {
            while (loop1) {
                    ...
            }
            result = 1;
            goto out;
    }
    ...
</code></pre><p>out:
kfree(buffer);
return result;
}</p><pre><code>            Chapter 8: Commenting
</code></pre><p>Comments are good, but there is also a danger of over-commenting. NEVER
try to explain HOW your code works in a comment: it&rsquo;s much better to
write the code so that the <em>working</em> is obvious, and it&rsquo;s a waste of
time to explain badly written code.</p><p>Generally, you want your comments to tell WHAT your code does, not HOW.
Also, try to avoid putting comments inside a function body: if the
function is so complex that you need to separately comment parts of it,
you should probably go back to chapter 6 for a while. You can make
small comments to note or warn about something particularly clever (or
ugly), but try to avoid excess. Instead, put the comments at the head
of the function, telling people what it does, and possibly WHY it does
it.</p><p>When commenting the kernel API functions, please use the kernel-doc format.
See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc
for details.</p><p>Linux style for comments is the C89 &ldquo;/* &mldr; */&rdquo; style.
Don&rsquo;t use C99-style &ldquo;// &mldr;&rdquo; comments.</p><p>The preferred style for long (multi-line) comments is:</p><pre><code>    /*
     * This is the preferred style for multi-line
     * comments in the Linux kernel source code.
     * Please use it consistently.
     *
     * Description:  A column of asterisks on the left side,
     * with beginning and ending almost-blank lines.
     */
</code></pre><p>It&rsquo;s also important to comment data, whether they are basic types or derived
types. To this end, use just one data declaration per line (no commas for
multiple data declarations). This leaves you room for a small comment on each
item, explaining its use.</p><pre><code>            Chapter 9: You've made a mess of it
</code></pre><p>That&rsquo;s OK, we all do. You&rsquo;ve probably been told by your long-time Unix
user helper that &ldquo;GNU emacs&rdquo; automatically formats the C sources for
you, and you&rsquo;ve noticed that yes, it does do that, but the defaults it
uses are less than desirable (in fact, they are worse than random
typing - an infinite number of monkeys typing into GNU emacs would never
make a good program).</p><p>So, you can either get rid of GNU emacs, or change it to use saner
values. To do the latter, you can stick the following in your .emacs file:</p><p>(defun c-lineup-arglist-tabs-only (ignored)
&ldquo;Line up argument lists by tabs, not spaces&rdquo;
(let* ((anchor (c-langelem-pos c-syntactic-element))
(column (c-langelem-2nd-pos c-syntactic-element))
(offset (- (1+ column) anchor))
(steps (floor offset c-basic-offset)))
(* (max steps 1)
c-basic-offset)))</p><p>(add-hook &lsquo;c-mode-common-hook
(lambda ()
;; Add kernel style
(c-add-style
&ldquo;linux-tabs-only&rdquo;
&lsquo;(&ldquo;linux&rdquo; (c-offsets-alist
(arglist-cont-nonempty
c-lineup-gcc-asm-reg
c-lineup-arglist-tabs-only))))))</p><p>(add-hook &lsquo;c-mode-hook
(lambda ()
(let ((filename (buffer-file-name)))
;; Enable kernel mode for the appropriate files
(when (and filename
(string-match (expand-file-name &ldquo;~/src/linux-trees&rdquo;)
filename))
(setq indent-tabs-mode t)
(c-set-style &ldquo;linux-tabs-only&rdquo;)))))</p><p>This will make emacs go better with the kernel coding style for C
files below ~/src/linux-trees.</p><p>But even if you fail in getting emacs to do sane formatting, not
everything is lost: use &ldquo;indent&rdquo;.</p><p>Now, again, GNU indent has the same brain-dead settings that GNU emacs
has, which is why you need to give it a few command line options.
However, that&rsquo;s not too bad, because even the makers of GNU indent
recognize the authority of K&R (the GNU people aren&rsquo;t evil, they are
just severely misguided in this matter), so you just give indent the
options &ldquo;-kr -i8&rdquo; (stands for &ldquo;K&R, 8 character indents&rdquo;), or use
&ldquo;scripts/Lindent&rdquo;, which indents in the latest style.</p><p>&ldquo;indent&rdquo; has a lot of options, and especially when it comes to comment
re-formatting you may want to take a look at the man page. But
remember: &ldquo;indent&rdquo; is not a fix for bad programming.</p><pre><code>            Chapter 10: Kconfig configuration files
</code></pre><p>For all of the Kconfig* configuration files throughout the source tree,
the indentation is somewhat different. Lines under a &ldquo;config&rdquo; definition
are indented with one tab, while help text is indented an additional two
spaces. Example:</p><p>config AUDIT
bool &ldquo;Auditing support&rdquo;
depends on NET
help
Enable auditing infrastructure that can be used with another
kernel subsystem, such as SELinux (which requires this for
logging of avc messages output). Does not do system-call
auditing without CONFIG_AUDITSYSCALL.</p><p>Features that might still be considered unstable should be defined as
dependent on &ldquo;EXPERIMENTAL&rdquo;:</p><p>config SLUB
depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT
bool &ldquo;SLUB (Unqueued Allocator)&rdquo;
&mldr;</p><p>while seriously dangerous features (such as write support for certain
filesystems) should advertise this prominently in their prompt string:</p><p>config ADFS_FS_RW
bool &ldquo;ADFS write support (DANGEROUS)&rdquo;
depends on ADFS_FS
&mldr;</p><p>For full documentation on the configuration files, see the file
Documentation/kbuild/kconfig-language.txt.</p><pre><code>            Chapter 11: Data structures
</code></pre><p>Data structures that have visibility outside the single-threaded
environment they are created and destroyed in should always have
reference counts. In the kernel, garbage collection doesn&rsquo;t exist (and
outside the kernel garbage collection is slow and inefficient), which
means that you absolutely <em>have</em> to reference count all your uses.</p><p>Reference counting means that you can avoid locking, and allows multiple
users to have access to the data structure in parallel - and not having
to worry about the structure suddenly going away from under them just
because they slept or did something else for a while.</p><p>Note that locking is <em>not</em> a replacement for reference counting.
Locking is used to keep data structures coherent, while reference
counting is a memory management technique. Usually both are needed, and
they are not to be confused with each other.</p><p>Many data structures can indeed have two levels of reference counting,
when there are users of different &ldquo;classes&rdquo;. The subclass count counts
the number of subclass users, and decrements the global count just once
when the subclass count goes to zero.</p><p>Examples of this kind of &ldquo;multi-level-reference-counting&rdquo; can be found in
memory management (&ldquo;struct mm_struct&rdquo;: mm_users and mm_count), and in
filesystem code (&ldquo;struct super_block&rdquo;: s_count and s_active).</p><p>Remember: if another thread can find your data structure, and you don&rsquo;t
have a reference count on it, you almost certainly have a bug.</p><pre><code>            Chapter 12: Macros, Enums and RTL
</code></pre><p>Names of macros defining constants and labels in enums are capitalized.</p><p>#define CONSTANT 0x12345</p><p>Enums are preferred when defining several related constants.</p><p>CAPITALIZED macro names are appreciated but macros resembling functions
may be named in lower case.</p><p>Generally, inline functions are preferable to macros resembling functions.</p><p>Macros with multiple statements should be enclosed in a do - while block:</p><p>#define macrofun(a, b, c)<br>do {<br>if (a == 5)<br>do_this(b, c);<br>} while (0)</p><p>Things to avoid when using macros:</p><ol><li>macros that affect control flow:</li></ol><p>#define FOO(x)<br>do {<br>if (blah(x) &lt; 0)<br>return -EBUGGERED;<br>} while(0)</p><p>is a <em>very</em> bad idea. It looks like a function call but exits the &ldquo;calling&rdquo;
function; don&rsquo;t break the internal parsers of those who will read the code.</p><ol start=2><li>macros that depend on having a local variable with a magic name:</li></ol><p>#define FOO(val) bar(index, val)</p><p>might look like a good thing, but it&rsquo;s confusing as hell when one reads the
code and it&rsquo;s prone to breakage from seemingly innocent changes.</p><ol start=3><li><p>macros with arguments that are used as l-values: FOO(x) = y; will
bite you if somebody e.g. turns FOO into an inline function.</p></li><li><p>forgetting about precedence: macros defining constants using expressions
must enclose the expression in parentheses. Beware of similar issues with
macros using parameters.</p></li></ol><p>#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)</p><p>The cpp manual deals with macros exhaustively. The gcc internals manual also
covers RTL which is used frequently with assembly language in the kernel.</p><pre><code>            Chapter 13: Printing kernel messages
</code></pre><p>Kernel developers like to be seen as literate. Do mind the spelling
of kernel messages to make a good impression. Do not use crippled
words like &ldquo;dont&rdquo;; use &ldquo;do not&rdquo; or &ldquo;don&rsquo;t&rdquo; instead. Make the messages
concise, clear, and unambiguous.</p><p>Kernel messages do not have to be terminated with a period.</p><p>Printing numbers in parentheses (%d) adds no value and should be avoided.</p><p>There are a number of driver model diagnostic macros in &lt;linux/device.h>
which you should use to make sure messages are matched to the right device
and driver, and are tagged with the right level: dev_err(), dev_warn(),
dev_info(), and so forth. For messages that aren&rsquo;t associated with a
particular device, &lt;linux/printk.h> defines pr_debug() and pr_info().</p><p>Coming up with good debugging messages can be quite a challenge; and once
you have them, they can be a huge help for remote troubleshooting. Such
messages should be compiled out when the DEBUG symbol is not defined (that
is, by default they are not included). When you use dev_dbg() or pr_debug(),
that&rsquo;s automatic. Many subsystems have Kconfig options to turn on -DDEBUG.
A related convention uses VERBOSE_DEBUG to add dev_vdbg() messages to the
ones already enabled by DEBUG.</p><pre><code>            Chapter 14: Allocating memory
</code></pre><p>The kernel provides the following general purpose memory allocators:
kmalloc(), kzalloc(), kcalloc(), vmalloc(), and vzalloc(). Please refer to
the API documentation for further information about them.</p><p>The preferred form for passing a size of a struct is the following:</p><pre><code>    p = kmalloc(sizeof(*p), ...);
</code></pre><p>The alternative form where struct name is spelled out hurts readability and
introduces an opportunity for a bug when the pointer variable type is changed
but the corresponding sizeof that is passed to a memory allocator is not.</p><p>Casting the return value which is a void pointer is redundant. The conversion
from void pointer to any other pointer type is guaranteed by the C programming
language.</p><pre><code>            Chapter 15: The inline disease
</code></pre><p>There appears to be a common misperception that gcc has a magic &ldquo;make me
faster&rdquo; speedup option called &ldquo;inline&rdquo;. While the use of inlines can be
appropriate (for example as a means of replacing macros, see Chapter 12), it
very often is not. Abundant use of the inline keyword leads to a much bigger
kernel, which in turn slows the system as a whole down, due to a bigger
icache footprint for the CPU and simply because there is less memory
available for the pagecache. Just think about it; a pagecache miss causes a
disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles
that can go into these 5 milliseconds.</p><p>A reasonable rule of thumb is to not put inline at functions that have more
than 3 lines of code in them. An exception to this rule are the cases where
a parameter is known to be a compiletime constant, and as a result of this
constantness you <em>know</em> the compiler will be able to optimize most of your
function away at compile time. For a good example of this later case, see
the kmalloc() inline function.</p><p>Often people argue that adding inline to functions that are static and used
only once is always a win since there is no space tradeoff. While this is
technically correct, gcc is capable of inlining these automatically without
help, and the maintenance issue of removing the inline when a second user
appears outweighs the potential value of the hint that tells gcc to do
something it would have done anyway.</p><pre><code>            Chapter 16: Function return values and names
</code></pre><p>Functions can return values of many different kinds, and one of the
most common is a value indicating whether the function succeeded or
failed. Such a value can be represented as an error-code integer
(-Exxx = failure, 0 = success) or a &ldquo;succeeded&rdquo; boolean (0 = failure,
non-zero = success).</p><p>Mixing up these two sorts of representations is a fertile source of
difficult-to-find bugs. If the C language included a strong distinction
between integers and booleans then the compiler would find these mistakes
for us&mldr; but it doesn&rsquo;t. To help prevent such bugs, always follow this
convention:</p><pre><code>    If the name of a function is an action or an imperative command,
    the function should return an error-code integer.  If the name
    is a predicate, the function should return a &quot;succeeded&quot; boolean.
</code></pre><p>For example, &ldquo;add work&rdquo; is a command, and the add_work() function returns 0
for success or -EBUSY for failure. In the same way, &ldquo;PCI device present&rdquo; is
a predicate, and the pci_dev_present() function returns 1 if it succeeds in
finding a matching device or 0 if it doesn&rsquo;t.</p><p>All EXPORTed functions must respect this convention, and so should all
public functions. Private (static) functions need not, but it is
recommended that they do.</p><p>Functions whose return value is the actual result of a computation, rather
than an indication of whether the computation succeeded, are not subject to
this rule. Generally they indicate failure by returning some out-of-range
result. Typical examples would be functions that return pointers; they use
NULL or the ERR_PTR mechanism to report failure.</p><pre><code>            Chapter 17:  Don't re-invent the kernel macros
</code></pre><p>The header file include/linux/kernel.h contains a number of macros that
you should use, rather than explicitly coding some variant of them yourself.
For example, if you need to calculate the length of an array, take advantage
of the macro</p><p>#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</p><p>Similarly, if you need to calculate the size of some structure member, use</p><p>#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))</p><p>There are also min() and max() macros that do strict type checking if you
need them. Feel free to peruse that header file to see what else is already
defined that you shouldn&rsquo;t reproduce in your code.</p><pre><code>            Chapter 18:  Editor modelines and other cruft
</code></pre><p>Some editors can interpret configuration information embedded in source files,
indicated with special markers. For example, emacs interprets lines marked
like this:</p><p>-<em>- mode: c -</em>-</p><p>Or like this:</p><p>/*
Local Variables:
compile-command: &ldquo;gcc -DMAGIC_DEBUG_FLAG foo.c&rdquo;
End:
*/</p><p>Vim interprets markers that look like this:</p><p>Do not include any of these in source files. People have their own personal
editor configurations, and your source files should not override them. This
includes markers for indentation and mode configuration. People may use their
own custom mode, or may have some other magic method for making indentation
work correctly.</p><p>[41] BUG-HUNTING.txt</p><p>这篇文档讲述了如何定位内核中的bug，常用的方式包括通过git-bisect进行搜索，以及
通过常规的旧有方式进行搜索定位，下面对其进行简要描述。</p><h2 id=finding-using-git-bisect>Finding using git-bisect <a href=#finding-using-git-bisect class=anchor aria-hidden=true>#</a><a href=#finding-using-git-bisect class=anchor aria-hidden=true>#</a></h2><p>Using the provided tools with git makes finding bugs easy provided the bug is
reproducible.</p><p>Steps to do it:</p><ul><li>start using git for the kernel source</li><li>read the man page for git-bisect</li><li>have fun</li></ul><h2 id=finding-it-the-old-way>Finding it the old way <a href=#finding-it-the-old-way class=anchor aria-hidden=true>#</a><a href=#finding-it-the-old-way class=anchor aria-hidden=true>#</a></h2><p>[Sat Mar 2 10:32:33 PST 1996 KERNEL_BUG-HOWTO lm@sgi.com (Larry McVoy)]</p><p>This is how to track down a bug if you know nothing about kernel hacking.
It&rsquo;s a brute force approach but it works pretty well.</p><p>You need:</p><pre><code>    . A reproducible bug - it has to happen predictably (sorry)
    . All the kernel tar files from a revision that worked to the
      revision that doesn't
</code></pre><p>You will then do:</p><pre><code>    . Rebuild a revision that you believe works, install, and verify that.
    . Do a binary search over the kernels to figure out which one
      introduced the bug.  I.e., suppose 1.3.28 didn't have the bug, but
      you know that 1.3.69 does.  Pick a kernel in the middle and build
      that, like 1.3.50.  Build &amp; test; if it works, pick the mid point
      between .50 and .69, else the mid point between .28 and .50.
    . You'll narrow it down to the kernel that introduced the bug.  You
      can probably do better than this but it gets tricky.

    . Narrow it down to a subdirectory

      - Copy kernel that works into &quot;test&quot;.  Let's say that 3.62 works,
        but 3.63 doesn't.  So you diff -r those two kernels and come
        up with a list of directories that changed.  For each of those
        directories:

            Copy the non-working directory next to the working directory
            as &quot;dir.63&quot;.
            One directory at time, try moving the working directory to
            &quot;dir.62&quot; and mv dir.63 dir&quot;time, try

                    mv dir dir.62
                    mv dir.63 dir
                    find dir -name '*.[oa]' -print | xargs rm -f

            And then rebuild and retest.  Assuming that all related
            changes were contained in the sub directory, this should
            isolate the change to a directory.

            Problems: changes in header files may have occurred; I've
            found in my case that they were self explanatory - you may
            or may not want to give up when that happens.

    . Narrow it down to a file

      - You can apply the same technique to each file in the directory,
        hoping that the changes in that file are self contained.

    . Narrow it down to a routine

      - You can take the old file and the new file and manually create
        a merged file that has

            #ifdef VER62
            routine()
            {
                    ...
            }
            #else
            routine()
            {
                    ...
            }
            #endif

        And then walk through that file, one routine at a time and
        prefix it with

            #define VER62
            /* both routines here */
            #undef VER62

        Then recompile, retest, move the ifdefs until you find the one
        that makes the difference.
</code></pre><p>Finally, you take all the info that you have, kernel revisions, bug
description, the extent to which you have narrowed it down, and pass
that off to whomever you believe is the maintainer of that section.
A post to linux.dev.kernel isn&rsquo;t such a bad idea if you&rsquo;ve done some
work to narrow it down.</p><p>If you get it down to a routine, you&rsquo;ll probably get a fix in 24 hours.</p><p>My apologies to Linus and the other kernel hackers for describing this
brute force approach, it&rsquo;s hardly what a kernel hacker would do. However,
it does work and it lets non-hackers help fix bugs. And it is cool
because Linux snapshots will let you do this - something that you can&rsquo;t
do with vendor supplied releases.</p><p>还讲述了如何修复内核bug的方式。</p><h1 id=fixing-the-bug>Fixing the bug <a href=#fixing-the-bug class=anchor aria-hidden=true>#</a></h1><p>Nobody is going to tell you how to fix bugs. Seriously. You need to work it
out. But below are some hints on how to use the tools.</p><p>To debug a kernel, use objdump and look for the hex offset from the crash
output to find the valid line of code/assembler. Without debug symbols, you
will see the assembler code for the routine shown, but if your kernel has
debug symbols the C code will also be available. (Debug symbols can be enabled
in the kernel hacking menu of the menu configuration.) For example:</p><pre><code>objdump -r -S -l --disassemble net/dccp/ipv4.o
</code></pre><p>NB.: you need to be at the top level of the kernel tree for this to pick up
your C files.</p><p>If you don&rsquo;t have access to the code you can also debug on some crash dumps
e.g. crash dump output as shown by Dave Miller.</p><blockquote><p>EIP is at ip_queue_xmit+0x14/0x4c0
&mldr;
Code: 44 24 04 e8 6f 05 00 00 e9 e8 fe ff ff 8d 76 00 8d bc 27 00 00
00 00 55 57 56 53 81 ec bc 00 00 00 8b ac 24 d0 00 00 00 8b 5d 08
&lt;8b> 83 3c 01 00 00 89 44 24 14 8b 45 28 85 c0 89 44 24 18 0f 85</p><p>Put the bytes into a &ldquo;foo.s&rdquo; file like this:</p><pre><code>      .text
      .globl foo
</code></pre><p>foo:
.byte &mldr;. /* bytes from Code: part of OOPS dump */</p><p>Compile it with &ldquo;gcc -c -o foo.o foo.s&rdquo; then look at the output of
&ldquo;objdump &ndash;disassemble foo.o&rdquo;.</p><p>Output:</p><p>ip_queue_xmit:
push %ebp
push %edi
push %esi
push %ebx
sub $0xbc, %esp
mov 0xd0(%esp), %ebp ! %ebp = arg0 (skb)
mov 0x8(%ebp), %ebx ! %ebx = skb->sk
mov 0x13c(%ebx), %eax ! %eax = inet_sk(sk)->opt</p></blockquote><p>In addition, you can use GDB to figure out the exact file and line
number of the OOPS from the vmlinux file. If you have
CONFIG_DEBUG_INFO enabled, you can simply copy the EIP value from the
OOPS:</p><p>EIP: 0060:[<c021e50e>] Not tainted VLI</p><p>And use GDB to translate that to human-readable form:</p><p>gdb vmlinux
(gdb) l *0xc021e50e</p><p>If you don&rsquo;t have CONFIG_DEBUG_INFO enabled, you use the function
offset from the OOPS:</p><p>EIP is at vt_ioctl+0xda8/0x1482</p><p>And recompile the kernel with CONFIG_DEBUG_INFO enabled:</p><p>make vmlinux
gdb vmlinux
(gdb) p vt_ioctl
(gdb) l *(0x<address of vt_ioctl>+ 0xda8)
or, as one command
(gdb) l *(vt_ioctl + 0xda8)</p><p>If you have a call trace, such as :-</p><blockquote><p>Call Trace:
[<ffffffff8802c8e9>] :jbd:log_wait_commit+0xa3/0xf5
[<ffffffff810482d9>] autoremove_wake_function+0x0/0x2e
[<ffffffff8802770b>] :jbd:journal_stop+0x1be/0x1ee
&mldr;
this shows the problem in the :jbd: module. You can load that module in gdb
and list the relevant code.
gdb fs/jbd/jbd.ko
(gdb) p log_wait_commit
(gdb) l *(0x<address>+ 0xa3)
or
(gdb) l *(log_wait_commit + 0xa3)</p></blockquote><p>Another very useful option of the Kernel Hacking section in menuconfig is
Debug memory allocations. This will help you see whether data has been
initialised and not set before use etc. To see the values that get assigned
with this look at mm/slab.c and search for POISON_INUSE. When using this an
Oops will often show the poisoned data instead of zero which is the default.</p><p>Once you have worked out a fix please submit it upstream. After all open
source is about sharing what you do and don&rsquo;t you want to be recognised for
your genius?</p><p>Please do read Documentation/SubmittingPatches though to help your code get
accepted.</p><p>[42] DMA-API-HOWTO.txt</p><p>This is a guide to device driver writers on how to use the DMA API with
example pseudo-code. For a concise description of the API, see DMA-API.txt.</p><p>[43] DMA-API.txt</p><p>This document describes the DMA API. For a more gentle introduction of the
API (and actual examples) see Documentation/DMA-API-HOWTO.txt.</p><p>[44] DMA-ISA-LPC.txt</p><p>This document describes how to do DMA transfers using the old ISA DMA
controller. Even though ISA is more or less dead today the LPC bus uses the
same DMA system so it will be around for quite some time.</p><p>[45] DMA-attributes.txt</p><p>This document describes the semantics of the DMA attributes that are defined
in linux/dma-attrs.h.</p><p>[46] HOWTO.txt</p><p>This is the be-all, end-all document on this topic. It contains instructions
on how to become a Linux kernel developer and how to learn to work with the
Linux kernel development community. It tries to not contain anything related
to the technical aspects of kernel programming, but will help point you in the
right direction for that.</p><p>[47] IPMI.txt</p><p>The Intelligent Platform Management Interface, or IPMI, is a standard for
controlling intelligent devices that monitor a system. It provides for
dynamic discovery of sensors in the system and the ability to monitor the
sensors and be informed when the sensor&rsquo;s values change or go outside certain
boundaries. It also has a standardized database for field-replaceable units
(FRUs) and a watchdog timer.</p><p>To use this, you need an interface to an IPMI controller in your system
(called a Baseboard Management Controller, or BMC) and management software
that can use the IPMI system.</p><p>This document describes how to use the IPMI driver for Linux. If you are not
familiar with IPMI itself, see the web site at:
http://www.intel.com/design/servers/ipmi/index.htm.<br>IPMI is a big subject and I can&rsquo;t cover it all here!</p><p><strong>[48] IRQ-affinity.txt</strong></p><p><strong>SMP IRQ affinity，指的是</strong></p><p><strong>对称多处理器中的中断请求绑定。</strong></p><p>/proc/irq/IRQ#/smp_affinity and /proc/irq/IRQ#/smp_affinity_list specify which
target CPUs are permitted for a given IRQ source. It&rsquo;s a bitmask
(smp_affinity) or cpu list (smp_affinity_list) of allowed CPUs. It&rsquo;s not
allowed to turn off all CPUs, and if an IRQ controller does not support IRQ
affinity then the value will not change from the default of all cpus.</p><p>/proc/irq/IRQ#/smp_affinity和/proc/irq/IRQ#/smp_affinity_list指明了允许接收某
个中断请求IRQ#的多个或某个cpu。它是一个位掩码smp_affinity或者一个cpu列表
smp_affinity_list，其中记录了允许接受该中断请求的cpu。不允许禁止所有cpu接收该
中断请求，如果一个中断控制器不支持中断请求绑定，那么只能采用默认值，即允许所有
cpu接收该中断请求，并且这个值不会被修改。</p><p>/proc/irq/default_smp_affinity specifies default affinity mask that applies to
all non-active IRQs. Once IRQ is allocated/activated its affinity bitmask will
be set to the default mask. It can then be changed as described above.
Default mask is 0xffffffff.</p><p>/proc/irq/default_smp_affinity指明了默认的中断绑定掩码，这个默认值将应用于所有
的非活动的、未激活的中断号。一旦一个中断号被分配、激活，那么它的中断绑定掩码将
被设置为这个默认值。这个默认值可以通过前面提到过的方法进行修改。这个默认掩码的
值为0xffffffff，请注意，该掩码是32位的。</p><p>Here is an example of restricting IRQ44 (eth1) to CPU0-3 then restricting
it to CPU4-7 (this is an 8-CPU SMP box):</p><p>网卡向cpu发中断请求44，下面我们对这个中断请求与cpu的绑定关系进行设置，并通过
ping命令进行测试，网卡会将接收到的icmp请求，以中断44的形式发送到绑定的cpu，通
过查看cpu接收到的中断请求数量，我们可以判断，这个44这个中断请求与cpu的绑定关系
。</p><p>[root@moon 44]# cd /proc/irq/44
[root@moon 44]# cat smp_affinity
ffffffff
首先，查看到44这个中断请求的默认绑定掩码为0xffffffff，说明，所有的cpu都可以接
收该中断请求。</p><p>[root@moon 44]# echo 0f > smp_affinity
[root@moon 44]# cat smp_affinity
0000000f</p><p>然后我们设置smp_affinity的值为0x0000000f，即使得编号为0-3的cpu允许接收该44这个
中断请求，其他的cpu都不会接收44这个中断请求。</p><p>[root@moon 44]# ping -f h
PING hell (195.4.7.3): 56 data bytes
&mldr;
&mdash; hell ping statistics &mdash;
6029 packets transmitted, 6027 packets received, 0% packet loss
round-trip min/avg/max = 0.1/0.1/0.4 ms</p><p>然后，对主机进行ping测试，这里的-f表示洪泛，h表示主机，实际测试的时候，可以修
改为localhost。这个时候，应用程序ping向主机发送了icmp请求包，网卡设备捕获到之
后，会向cpu发送中断号为44的中断请求。现在该主机上有8个cpu，由于我们设置了编号
为0-3的cpu可以接收该中断，其他的则不可以，那么如果我们查看cpu对中断44的接收情
况时，只有编号为0-3的cpu才能接收到中断请求。</p><p>[root@moon 44]# cat /proc/interrupts | grep &lsquo;CPU|44:&rsquo;
CPU0 CPU1 CPU2 CPU3 CPU4 CPU5 CPU6 CPU7
44: 1068 1785 1785 1783 0 0 0 0 IO-APIC-level eth1</p><p>通过查看测试结果，我们发现cpu 4-7 确实没有接收到编号为44的中断请求，但是编号
为0-3的cpu接收到了该中断请求。</p><p>As can be seen from the line above IRQ44 was delivered only to the first four
processors (0-3).
Now lets restrict that IRQ to CPU(4-7).</p><p>[root@moon 44]# echo f0 > smp_affinity
[root@moon 44]# cat smp_affinity
000000f0</p><p>进一步进行测试，我们将允许接收编号44的中断请求的cpu设定为编号4-7，即将
smp_affinity的值设定为0x000000f0，下面再次通过ping进行测试。</p><p>[root@moon 44]# ping -f h
PING hell (195.4.7.3): 56 data bytes
..
&mdash; hell ping statistics &mdash;
2779 packets transmitted, 2777 packets received, 0% packet loss
round-trip min/avg/max = 0.1/0.5/585.4 ms
[root@moon 44]# cat /proc/interrupts | &lsquo;CPU|44:&rsquo;
CPU0 CPU1 CPU2 CPU3 CPU4 CPU5 CPU6 CPU7
44: 1068 1785 1785 1783 1784 1069 1070 1069 IO-APIC-level eth1</p><p>This time around IRQ44 was delivered only to the last four processors.
i.e counters for the CPU0-3 did not change.</p><p>将当前cpu接收到的中断请求44的数量，与前面一次ping测试时各个cpu接收到的中断请求
44的数量对比发现，只有编号为4-7的cpu接收到的中断请求44的数量发生了改变，说明我
们成功的设置了中断请求44的中断绑定到cpu 4-7。</p><p>Here is an example of limiting that same irq (44) to cpus 1024 to 1031:</p><p>[root@moon 44]# echo 1024-1031 > smp_affinity
[root@moon 44]# cat smp_affinity
1024-1031</p><p>上面的语法可以将中断绑定到编号范围为1024-1031的cpu上。</p><p>Note that to do this with a bitmask would require 32 bitmasks of zero to
follow the pertinent one.</p><p><strong>[49] IRQ.txt</strong></p><p><strong>What is an IRQ?</strong></p><p><strong>An IRQ is an interrupt request from a device. Currently they can come in over</strong>
<strong>a pin, or over a packet. Several devices may be connected to the same pin</strong>
<strong>thus sharing an IRQ.</strong></p><p>An IRQ number is a kernel identifier used to talk about a hardware interrupt
source. Typically this is an index into the global irq_desc array, but except
for what linux/interrupt.h implements the details are architecture specific.</p><p>An IRQ number is an enumeration of the possible interrupt sources on a
machine. Typically what is enumerated is the number of input pins on all of
the interrupt controller in the system. In the case of ISA what is enumerated
are the 16 input pins on the two i8259 interrupt controllers.</p><p>Architectures can assign additional meaning to the IRQ numbers, and are
encouraged to in the case where there is any manual configuration of the
hardware involved. The ISA IRQs are a classic example of assigning this kind
of additional meaning.</p><p>[50] Intel-IOMMU.txt</p><p>Linux IOMMU Support</p><p>[51] ManagementStyle.txt</p><p>Linux kernel management style</p><p>[52] SAK.txt</p><p>SAK, 讲述的其实是系统魔法键sysrq中的一个，还是很有必要的，学习下吧。</p><p>An operating system&rsquo;s Secure Attention Key is a security tool which is
provided as protection against trojan password capturing programs. It is an
undefeatable way of killing all programs which could be masquerading as login
applications. Users need to be taught to enter this key sequence before they
log in to the system.</p><p>From the PC keyboard, Linux has two similar but different ways of providing
SAK. One is the ALT-SYSRQ-K sequence. You shouldn&rsquo;t use this sequence. It
is only available if the kernel was compiled with sysrq support.</p><p>The proper way of generating a SAK is to define the key sequence using
`loadkeys&rsquo;. This will work whether or not sysrq support is compiled into the
kernel.</p><p>SAK works correctly when the keyboard is in raw mode. This means that once
defined, SAK will kill a running X server. If the system is in run level 5,
the X server will restart. This is what you want to happen.</p><p>What key sequence should you use? Well, CTRL-ALT-DEL is used to reboot the
machine. CTRL-ALT-BACKSPACE is magical to the X server. We&rsquo;ll choose
CTRL-ALT-PAUSE.</p><p>In your rc.sysinit (or rc.local) file, add the command</p><p>echo &ldquo;control alt keycode 101 = SAK&rdquo; | /bin/loadkeys</p><p>And that&rsquo;s it! Only the superuser may reprogram the SAK key.</p><h1 id=notes>NOTES <a href=#notes class=anchor aria-hidden=true>#</a></h1><p>1: Linux SAK is said to be not a &ldquo;true SAK&rdquo; as is required by systems which
implement C2 level security. This author does not know why.</p><p>2: On the PC keyboard, SAK kills all applications which have /dev/console
opened.</p><p>Unfortunately this includes a number of things which you don&rsquo;t actually want
killed. This is because these applications are incorrectly holding
/dev/console open. Be sure to complain to your Linux distributor about this!</p><p>You can identify processes which will be killed by SAK with the command</p><p>ls -l /proc/[0-9]<em>/fd/</em> | grep console</p><p>l-wx&mdash;&mdash; 1 root root 64 Mar 18 00:46 /proc/579/fd/0 -> /dev/console</p><p>Then:</p><p>ps aux|grep 579</p><p>root 579 0.0 0.1 1088 436 ? S 00:43 0:00 gpm -t ps/2</p><p>So `gpm&rsquo; will be killed by SAK. This is a bug in gpm. It should be closing
standard input. You can work around this by finding the initscript which
launches gpm and changing it thusly:</p><p>Old:</p><p>daemon gpm</p><p>New:</p><p>daemon gpm &lt; /dev/null</p><p>Vixie cron also seems to have this problem, and needs the same treatment.</p><p>Also, one prominent Linux distribution has the following three lines in its
rc.sysinit and rc scripts:</p><p>exec 3&lt;&0
exec 4>&1
exec 5>&2</p><p>These commands cause <em>all</em> daemons which are launched by the initscripts to
have file descriptors 3, 4 and 5 attached to /dev/console. So SAK kills them
all. A workaround is to simply delete these lines, but this may cause system
management applications to malfunction - test everything well.</p><p>[53] SM501.txt</p><p>The Silicon Motion SM501 multimedia companion chip is a multifunction device
which may provide numerous interfaces including USB host controller USB
gadget, asynchronous serial ports, audio functions, and a dual display video
interface. The device may be connected by PCI or local bus with varying
functions enabled.</p><p>[54] SecurityBugs.txt</p><p>Linux kernel developers take security very seriously. As such, we&rsquo;d like to
know when a security bug is found so that it can be fixed and disclosed as
quickly as possible. Please report security bugs to the Linux kernel security
team.</p><ol><li>Contact</li></ol><p>The Linux kernel security team can be contacted by email at
<a href=mailto:security@kernel.org>security@kernel.org</a>. This is a private list of security officers who will
help verify the bug report and develop and release a fix. It is possible that
the security team will bring in extra help from area maintainers to understand
and fix the security vulnerability.</p><p>As it is with any bug, the more information provided the easier it will be to
diagnose and fix. Please review the procedure outlined in REPORTING-BUGS if
you are unclear about what information is helpful. Any exploit code is very
helpful and will not be released without consent from the reporter unless it
has already been made public.</p><ol start=2><li>Disclosure</li></ol><p>The goal of the Linux kernel security team is to work with the bug submitter
to bug resolution as well as disclosure. We prefer to fully disclose the bug
as soon as possible. It is reasonable to delay disclosure when the bug or the
fix is not yet fully understood, the solution is not well-tested or for vendor
coordination. However, we expect these delays to be short, measurable in
days, not weeks or months. A disclosure date is negotiated by the security
team working with the bug submitter as well as vendors. However, the kernel
security team holds the final say when setting a disclosure date. The
timeframe for disclosure is from immediate (esp. if it&rsquo;s already publicly
known) to a few weeks. As a basic default policy, we expect report date to
disclosure date to be on the order of 7 days.</p><ol start=3><li>Non-disclosure agreements</li></ol><p>The Linux kernel security team is not a formal body and therefore unable to
enter any non-disclosure agreements.</p><p>[55] SubmitChecklist.txt</p><p>Linux Kernel patch submission checklist</p><p>Here are some basic things that developers should do if they want to see their
kernel patch submissions accepted more quickly.</p><p>These are all above and beyond the documentation that is provided in
Documentation/SubmittingPatches and elsewhere regarding submitting Linux
kernel patches.</p><pre><code>1: If you use a facility then #include the file that defines/declares
   that facility.  Don't depend on other header files pulling in ones
   that you use.

2: Builds cleanly with applicable or modified CONFIG options =y, =m, and
   =n.  No gcc warnings/errors, no linker warnings/errors.

2b: Passes allnoconfig, allmodconfig

2c: Builds successfully when using O=builddir

3: Builds on multiple CPU architectures by using local cross-compile tools
   or some other build farm.

4: ppc64 is a good architecture for cross-compilation checking because it
   tends to use `unsigned long' for 64-bit quantities.

5: Check your patch for general style as detailed in
   Documentation/CodingStyle.  Check for trivial violations with the
   patch style checker prior to submission (scripts/checkpatch.pl).
   You should be able to justify all violations that remain in
   your patch.

6: Any new or modified CONFIG options don't muck up the config menu.

7: All new Kconfig options have help text.

8: Has been carefully reviewed with respect to relevant Kconfig
   combinations.  This is very hard to get right with testing -- brainpower
   pays off here.

9: Check cleanly with sparse.

10: Use 'make checkstack' and 'make namespacecheck' and fix any problems
    that they find.  Note: checkstack does not point out problems explicitly,
             but any one function that uses more than 512 bytes on the stack is a
             candidate for change.
         
11: Include kernel-doc to document global kernel APIs.  (Not required for
                     static functions, but OK there also.) Use 'make htmldocs' or 'make mandocs' to check the kernel-doc and fix any issues.
         
12: Has been tested with CONFIG_PREEMPT, CONFIG_DEBUG_PREEMPT,
             CONFIG_DEBUG_SLAB, CONFIG_DEBUG_PAGEALLOC, CONFIG_DEBUG_MUTEXES,
             CONFIG_DEBUG_SPINLOCK, CONFIG_DEBUG_ATOMIC_SLEEP, CONFIG_PROVE_RCU
             and CONFIG_DEBUG_OBJECTS_RCU_HEAD all simultaneously enabled.
         
13: Has been build- and runtime tested with and without CONFIG_SMP and
             CONFIG_PREEMPT.
         
14: If the patch affects IO/Disk, etc: has been tested with and without
             CONFIG_LBDAF.
         
15: All codepaths have been exercised with all lockdep features enabled.
         
16: All new /proc entries are documented under Documentation/
         
17: All new kernel boot parameters are documented in
             Documentation/kernel-parameters.txt.
         
18: All new module parameters are documented with MODULE_PARM_DESC()
    
19: All new userspace interfaces are documented in Documentation/ABI/.
        See Documentation/ABI/README for more information.
        Patches that change userspace interfaces should be CCed to
        linux-api@vger.kernel.org.
    
20: Check that it all passes `make headers_check'.
    
21: Has been checked with injection of at least slab and page-allocation
        failures.  See Documentation/fault-injection/.
    
        If the new code is substantial, addition of subsystem-specific fault
        injection might be appropriate.
    
22: Newly-added code has been compiled with `gcc -W' (use &quot;make
		EXTRA_CFLAGS=-W&quot;).  This will generate lots of noise, but is good for finding 		bugs like &quot;warning: comparison between signed and unsigned&quot;.
    
23: Tested after it has been merged into the -mm patchset to make sure
        that it still works with all of the other queued patches and various
        changes in the VM, VFS, and other subsystems.
    
24: All memory barriers {e.g., barrier(), rmb(), wmb()} need a comment in the
        source code that explains the logic of what they are doing and why.
    
25: If any ioctl's are added by the patch, then also update
        Documentation/ioctl/ioctl-number.txt.
    
26: If your modified source code depends on or uses any of the kernel
        APIs or features that are related to the following kconfig symbols,
        then test multiple builds with the related kconfig symbols disabled
        and/or =m (if that option is available) [not all of these at the
        same time, just various/random combinations of them]:
    
        CONFIG_SMP, CONFIG_SYSFS, CONFIG_PROC_FS, CONFIG_INPUT, CONFIG_PCI,
        CONFIG_BLOCK, CONFIG_PM, CONFIG_HOTPLUG, CONFIG_MAGIC_SYSRQ,
        CONFIG_NET, CONFIG_INET=n (but latter with CONFIG_NET=y)
</code></pre><p>[56] SubmittingPatches.txt</p><p>How to Get Your Change Into the Linux Kernel
or
Care And Operation Of Your Linus Torvalds</p><p>For a person or company who wishes to submit a change to the Linux kernel, the
process can sometimes be daunting if you&rsquo;re not familiar with &ldquo;the system.&rdquo;
This text is a collection of suggestions which can greatly increase the
chances of your change being accepted.</p><p>Read Documentation/SubmitChecklist for a list of items to check before
submitting code. If you are submitting a driver, also read
Documentation/SubmittingDrivers.</p><hr><h2 id=section-1---creating-and-sending-your-change>SECTION 1 - CREATING AND SENDING YOUR CHANGE <a href=#section-1---creating-and-sending-your-change class=anchor aria-hidden=true>#</a><a href=#section-1---creating-and-sending-your-change class=anchor aria-hidden=true>#</a></h2><ol><li>&ldquo;diff -up&rdquo;</li></ol><hr><p>Use &ldquo;diff -up&rdquo; or &ldquo;diff -uprN&rdquo; to create patches.</p><p>All changes to the Linux kernel occur in the form of patches, as generated by
diff(1). When creating your patch, make sure to create it in &ldquo;unified diff&rdquo;
format, as supplied by the &lsquo;-u&rsquo; argument to diff(1). Also, please use the
&lsquo;-p&rsquo; argument which shows which C function each change is in - that makes the
resultant diff a lot easier to read. Patches should be based in the root
kernel source directory, not in any lower subdirectory.</p><p>To create a patch for a single file, it is often sufficient to do:</p><pre><code>SRCTREE= linux-2.6
MYFILE=  drivers/net/mydriver.c
 
cd $SRCTREE
cp $MYFILE $MYFILE.orig
vi $MYFILE      # make your change
cd ..
diff -up $SRCTREE/$MYFILE{.orig,} &gt; /tmp/patch
</code></pre><p>To create a patch for multiple files, you should unpack a &ldquo;vanilla&rdquo;, or
unmodified kernel source tree, and generate a diff against your own source
tree. For example:</p><pre><code>MYSRC= /devel/linux-2.6
 
tar xvfz linux-2.6.12.tar.gz
mv linux-2.6.12 linux-2.6.12-vanilla
diff -uprN -X linux-2.6.12-vanilla/Documentation/dontdiff \
linux-2.6.12-vanilla $MYSRC &gt; /tmp/patch
</code></pre><p>&ldquo;dontdiff&rdquo; is a list of files which are generated by the kernel during the
build process, and should be ignored in any diff(1)-generated patch. The
&ldquo;dontdiff&rdquo; file is included in the kernel tree in 2.6.12 and later. For
earlier kernel versions, you can get it from
<a href=http://www.xenotime.net/linux/doc/dontdiff>http://www.xenotime.net/linux/doc/dontdiff</a>.</p><p>Make sure your patch does not include any extra files which do not belong in a
patch submission. Make sure to review your patch -after- generated it with
diff(1), to ensure accuracy.</p><p>If your changes produce a lot of deltas, you may want to look into splitting
them into individual patches which modify things in logical stages. This will
facilitate easier reviewing by other kernel developers, very important if you
want your patch accepted. There are a number of scripts which can aid in
this:
Quilt: http://savannah.nongnu.org/projects/quilt</p><p>Andrew Morton&rsquo;s patch scripts:
http://userweb.kernel.org/~akpm/stuff/patch-scripts.tar.gz Instead of these
scripts, quilt is the recommended patch management tool (see above).</p><ol start=2><li>Describe your changes.</li></ol><p>Describe the technical detail of the change(s) your patch includes.</p><p>Be as specific as possible. The WORST descriptions possible include things
like &ldquo;update driver X&rdquo;, &ldquo;bug fix for driver X&rdquo;, or &ldquo;this patch includes
updates for subsystem X. Please apply.&rdquo;</p><p>The maintainer will thank you if you write your patch description in a form
which can be easily pulled into Linux&rsquo;s source code management system, git, as
a &ldquo;commit log&rdquo;. See #15, below.</p><p>If your description starts to get long, that&rsquo;s a sign that you probably need
to split up your patch. See #3, next.</p><p>When you submit or resubmit a patch or patch series, include the complete
patch description and justification for it. Don&rsquo;t just say that this is
version N of the patch (series). Don&rsquo;t expect the patch merger to refer back
to earlier patch versions or referenced URLs to find the patch description and
put that into the patch. I.e., the patch (series) and its description should
be self-contained. This benefits both the patch merger(s) and reviewers.
Some reviewers probably didn&rsquo;t even receive earlier versions of the patch.</p><p>If the patch fixes a logged bug entry, refer to that bug entry by number and
URL.</p><ol start=3><li>Separate your changes.</li></ol><p>Separate <em>logical changes</em> into a single patch file.</p><p>For example, if your changes include both bug fixes and performance
enhancements for a single driver, separate those changes into two or more
patches. If your changes include an API update, and a new driver which uses
that new API, separate those into two patches.</p><p>On the other hand, if you make a single change to numerous files, group those
changes into a single patch. Thus a single logical change is contained within
a single patch.</p><p>If one patch depends on another patch in order for a change to be complete,
that is OK. Simply note &ldquo;this patch depends on patch X&rdquo; in your patch
description.</p><p>If you cannot condense your patch set into a smaller set of patches, then only
post say 15 or so at a time and wait for review and integration.</p><ol start=4><li>Style check your changes.</li></ol><p>Check your patch for basic style violations, details of which can be found in
Documentation/CodingStyle. Failure to do so simply wastes the reviewers time
and will get your patch rejected, probably without even being read.</p><p>At a minimum you should check your patches with the patch style checker prior
to submission (scripts/checkpatch.pl). You should be able to justify all
violations that remain in your patch.</p><ol start=5><li>Select e-mail destination.</li></ol><p>Look through the MAINTAINERS file and the source code, and determine if your
change applies to a specific subsystem of the kernel, with an assigned
maintainer. If so, e-mail that person.</p><p>If no maintainer is listed, or the maintainer does not respond, send your
patch to the primary Linux kernel developer&rsquo;s mailing list,
linux-kernel@vger.kernel.org. Most kernel developers monitor this e-mail
list, and can comment on your changes.</p><p>Do not send more than 15 patches at once to the vger mailing lists!!!</p><p>Linus Torvalds is the final arbiter of all changes accepted into the Linux
kernel. His e-mail address is <a href=mailto:torvalds@linux-foundation.org>torvalds@linux-foundation.org</a>. He gets a lot
of e-mail, so typically you should do your best to -avoid- sending him e-mail.</p><p>Patches which are bug fixes, are &ldquo;obvious&rdquo; changes, or similarly require
little discussion should be sent or CC&rsquo;d to Linus. Patches which require
discussion or do not have a clear advantage should usually be sent first to
linux-kernel. Only after the patch is discussed should the patch then be
submitted to Linus.</p><ol start=6><li>Select your CC (e-mail carbon copy) list.</li></ol><p>Unless you have a reason NOT to do so, CC linux-kernel@vger.kernel.org.</p><p>Other kernel developers besides Linus need to be aware of your change, so that
they may comment on it and offer code review and suggestions. linux-kernel is
the primary Linux kernel developer mailing list. Other mailing lists are
available for specific subsystems, such as USB, framebuffer devices, the VFS,
the SCSI subsystem, etc. See the MAINTAINERS file for a mailing list that
relates specifically to your change.</p><p>Majordomo lists of VGER.KERNEL.ORG at:
<a href=http://vger.kernel.org/vger-lists.html>http://vger.kernel.org/vger-lists.html</a></p><p>If changes affect userland-kernel interfaces, please send the MAN-PAGES
maintainer (as listed in the MAINTAINERS file) a man-pages patch, or at least
a notification of the change, so that some information makes its way into the
manual pages.</p><p>Even if the maintainer did not respond in step #5, make sure to ALWAYS copy
the maintainer when you change their code.</p><p>For small patches you may want to CC the Trivial Patch Monkey
trivial@kernel.org which collects &ldquo;trivial&rdquo; patches. Have a look into the
MAINTAINERS file for its current manager. Trivial patches must qualify for
one of the following rules: Spelling fixes in documentation Spelling fixes
which could break grep(1) Warning fixes (cluttering with useless warnings is
bad) Compilation fixes (only if they are actually correct) Runtime fixes (only
if they actually fix things) Removing use of deprecated functions/macros (eg.
check_region) Contact detail and documentation fixes Non-portable code
replaced by portable code (even in arch-specific, since people copy, as long
as it&rsquo;s trivial) Any fix by the author/maintainer of the file (ie. patch
monkey in re-transmission mode)</p><ol start=7><li>No MIME, no links, no compression, no attachments. Just plain text.</li></ol><p>Linus and other kernel developers need to be able to read and comment on the
changes you are submitting. It is important for a kernel developer to be able
to &ldquo;quote&rdquo; your changes, using standard e-mail tools, so that they may comment
on specific portions of your code.</p><p>For this reason, all patches should be submitting e-mail &ldquo;inline&rdquo;. WARNING:
Be wary of your editor&rsquo;s word-wrap corrupting your patch, if you choose to
cut-n-paste your patch.</p><p>Do not attach the patch as a MIME attachment, compressed or not. Many popular
e-mail applications will not always transmit a MIME attachment as plain text,
making it impossible to comment on your code. A MIME attachment also
takes Linus a bit more time to process, decreasing the likelihood of your
MIME-attached change being accepted.</p><p>Exception: If your mailer is mangling patches then someone may ask you to
re-send them using MIME.</p><p>See Documentation/email-clients.txt for hints about configuring your e-mail
client so that it sends your patches untouched.</p><ol start=8><li>E-mail size.</li></ol><p>When sending patches to Linus, always follow step #7.</p><p>Large changes are not appropriate for mailing lists, and some maintainers. If
your patch, uncompressed, exceeds 300 kB in size, it is preferred that you
store your patch on an Internet-accessible server, and provide instead a URL
(link) pointing to your patch.</p><ol start=9><li>Name your kernel version.</li></ol><p>It is important to note, either in the subject line or in the patch
description, the kernel version to which this patch applies.</p><p>If the patch does not apply cleanly to the latest kernel version, Linus will
not apply it.</p><ol start=10><li>Don&rsquo;t get discouraged. Re-submit.</li></ol><p>After you have submitted your change, be patient and wait. If Linus likes
your change and applies it, it will appear in the next version of the kernel
that he releases.</p><p>However, if your change doesn&rsquo;t appear in the next version of the kernel,
there could be any number of reasons. It&rsquo;s YOUR job to narrow down those
reasons, correct what was wrong, and submit your updated change.</p><p>It is quite common for Linus to &ldquo;drop&rdquo; your patch without comment. That&rsquo;s the
nature of the system. If he drops your patch, it could be due to
* Your patch did not apply cleanly to the latest kernel version.
* Your patch was not sufficiently discussed on linux-kernel.
* A style issue (see section 2).
* An e-mail formatting issue (re-read this section).
* A technical problem with your change.
* He gets tons of e-mail, and yours got lost in the shuffle.
* You are being annoying.</p><p>When in doubt, solicit comments on linux-kernel mailing list.</p><ol start=11><li>Include PATCH in the subject</li></ol><p>Due to high e-mail traffic to Linus, and to linux-kernel, it is common
convention to prefix your subject line with [PATCH]. This lets Linus and
other kernel developers more easily distinguish patches from other e-mail
discussions.</p><ol start=12><li>Sign your work</li></ol><p>To improve tracking of who did what, especially with patches that can
percolate to their final resting place in the kernel through several layers of
maintainers, we&rsquo;ve introduced a &ldquo;sign-off&rdquo; procedure on patches that are being
emailed around.</p><p>The sign-off is a simple line at the end of the explanation for the patch,
which certifies that you wrote it or otherwise have the right to pass it on as
an open-source patch. The rules are pretty simple: if you can certify the
below:</p><pre><code>    Developer's Certificate of Origin 1.1

    By making a contribution to this project, I certify that:

    (a) The contribution was created in whole or in part by me and I have
        the right to submit it under the open source license indicated in
        the file; or

    (b) The contribution is based upon previous work that, to the best of
        my knowledge, is covered under an appropriate open source license
        and I have the right under that license to submit that work with
        modifications, whether created in whole or in part by me, under
        the same open source license (unless I am permitted to submit
                under a different license), as indicated in the file; or

    (c) The contribution was provided directly to me by some other person
        who certified (a), (b) or (c) and I have not modified it.

    (d) I understand and agree that this project and the contribution are
        public and that a record of the contribution (including all
        personal information I submit with it, including my sign-off) is
        maintained indefinitely and may be redistributed consistent with
        this project or the open source license(s) involved.

then you just add a line saying
        Signed-off-by: Random J Developer &lt;random@developer.example.org&gt;
</code></pre><p>using your real name (sorry, no pseudonyms or anonymous contributions.)</p><p>Some people also put extra tags at the end. They&rsquo;ll just be ignored for now,
but you can do this to mark internal company procedures or just point out some
special detail about the sign-off.</p><p>If you are a subsystem or branch maintainer, sometimes you need to slightly
modify patches you receive in order to merge them, because the code is not
exactly the same in your tree and the submitters&rsquo;. If you stick strictly to
rule (c), you should ask the submitter to rediff, but this is a totally
counter-productive waste of time and energy. Rule (b) allows you to adjust the
code, but then it is very impolite to change one submitter&rsquo;s code and make him
endorse your bugs. To solve this problem, it is recommended that you add a
line between the last Signed-off-by header and yours, indicating the nature of
your changes. While there is nothing mandatory about this, it seems like
prepending the description with your mail and/or name, all enclosed in square
brackets, is noticeable enough to make it obvious that you are responsible for
last-minute changes. Example :</p><pre><code>    Signed-off-by: Random J Developer &lt;random@developer.example.org&gt;
    [lucky@maintainer.example.org: struct foo moved from foo.c to foo.h]
    Signed-off-by: Lucky K Maintainer &lt;lucky@maintainer.example.org&gt;
</code></pre><p>This practise is particularly helpful if you maintain a stable branch and want
at the same time to credit the author, track changes, merge the fix, and
protect the submitter from complaints. Note that under no circumstances can
you change the author&rsquo;s identity (the From header), as it is the one which
appears in the changelog.</p><p>Special note to back-porters: It seems to be a common and useful practise to
insert an indication of the origin of a patch at the top of the commit message
(just after the subject line) to facilitate tracking. For instance, here&rsquo;s
what we see in 2.6-stable :</p><pre><code>Date:   Tue May 13 19:10:30 +0000

    SCSI: libiscsi regression in 2.6.25: fix nop timer handling

    commit 4cf1043593db6a337f10e006c23c69e5fc93e722 upstream
</code></pre><p>And here&rsquo;s what appears in 2.4 :</p><pre><code>Date:   Tue May 13 22:12:27 +0200

    wireless, airo: waitbusy() won't delay

    [backport of 2.6 commit b7acbdfbd1f277c1eb23f344f899cfa4cd0bf36a]
</code></pre><p>Whatever the format, this information provides a valuable help to people
tracking your trees, and to people trying to trouble-shoot bugs in your tree.
13) When to use Acked-by: and Cc:</p><p>The Signed-off-by: tag indicates that the signer was involved in the
development of the patch, or that he/she was in the patch&rsquo;s delivery path.</p><p>If a person was not directly involved in the preparation or handling of a
patch but wishes to signify and record their approval of it then they can
arrange to have an Acked-by: line added to the patch&rsquo;s changelog.</p><p>Acked-by: is often used by the maintainer of the affected code when that
maintainer neither contributed to nor forwarded the patch.</p><p>Acked-by: is not as formal as Signed-off-by:. It is a record that the acker
has at least reviewed the patch and has indicated acceptance. Hence patch
mergers will sometimes manually convert an acker&rsquo;s &ldquo;yep, looks good to me&rdquo;
into an Acked-by:.</p><p>Acked-by: does not necessarily indicate acknowledgement of the entire patch.
For example, if a patch affects multiple subsystems and has an Acked-by: from
one subsystem maintainer then this usually indicates acknowledgement of just
the part which affects that maintainer&rsquo;s code. Judgement should be used here.
When in doubt people should refer to the original discussion in the mailing
list archives.</p><p>If a person has had the opportunity to comment on a patch, but has not
provided such comments, you may optionally add a &ldquo;Cc:&rdquo; tag to the patch. This
is the only tag which might be added without an explicit action by the person
it names. This tag documents that potentially interested parties have been
included in the discussion</p><ol start=14><li>Using Reported-by:, Tested-by: and Reviewed-by:</li></ol><p>If this patch fixes a problem reported by somebody else, consider adding a
Reported-by: tag to credit the reporter for their contribution. Please note
that this tag should not be added without the reporter&rsquo;s permission,
especially if the problem was not reported in a public forum. That said, if
we diligently credit our bug reporters, they will, hopefully, be inspired to
help us again in the future.</p><p>A Tested-by: tag indicates that the patch has been successfully tested (in
some environment) by the person named. This tag informs maintainers that
some testing has been performed, provides a means to locate testers for
future patches, and ensures credit for the testers.</p><p>Reviewed-by:, instead, indicates that the patch has been reviewed and found
acceptable according to the Reviewer&rsquo;s Statement:</p><pre><code>    Reviewer's statement of oversight

    By offering my Reviewed-by: tag, I state that:

     (a) I have carried out a technical review of this patch to
         evaluate its appropriateness and readiness for inclusion into
         the mainline kernel.

     (b) Any problems, concerns, or questions relating to the patch
         have been communicated back to the submitter.  I am satisfied
         with the submitter's response to my comments.

     (c) While there may be things that could be improved with this
         submission, I believe that it is, at this time, (1) a
         worthwhile modification to the kernel, and (2) free of known
         issues which would argue against its inclusion.

     (d) While I have reviewed the patch and believe it to be sound, I
         do not (unless explicitly stated elsewhere) make any
         warranties or guarantees that it will achieve its stated
         purpose or function properly in any given situation.
</code></pre><p>A Reviewed-by tag is a statement of opinion that the patch is an appropriate
modification of the kernel without any remaining serious technical issues.
Any interested reviewer (who has done the work) can offer a Reviewed-by tag
for a patch. This tag serves to give credit to reviewers and to inform
maintainers of the degree of review which has been done on the patch.
Reviewed-by: tags, when supplied by reviewers known to understand the subject
area and to perform thorough reviews, will normally increase the likelihood of
your patch getting into the kernel.</p><ol start=15><li>The canonical patch format</li></ol><p>The canonical patch subject line is:</p><pre><code>Subject: [PATCH 001/123] subsystem: summary phrase
</code></pre><p>The canonical patch message body contains the following:</p><ul><li><p>A &ldquo;from&rdquo; line specifying the patch author.</p></li><li><p>An empty line.</p></li><li><p>The body of the explanation, which will be copied to the
permanent changelog to describe this patch.</p></li><li><p>The &ldquo;Signed-off-by:&rdquo; lines, described above, which will
also go in the changelog.</p></li><li><p>A marker line containing simply &ldquo;&mdash;&rdquo;.</p></li><li><p>Any additional comments not suitable for the changelog.</p></li><li><p>The actual patch (diff output).</p></li></ul><p>The Subject line format makes it very easy to sort the emails alphabetically
by subject line - pretty much any email reader will support that - since
because the sequence number is zero-padded, the numerical and alphabetic sort
is the same.</p><p>The &ldquo;subsystem&rdquo; in the email&rsquo;s Subject should identify which area or subsystem
of the kernel is being patched.</p><p>The &ldquo;summary phrase&rdquo; in the email&rsquo;s Subject should concisely describe the
patch which that email contains. The &ldquo;summary phrase&rdquo; should not be a
filename. Do not use the same &ldquo;summary phrase&rdquo; for every patch in a whole
patch series (where a &ldquo;patch series&rdquo; is an ordered sequence of multiple,
related patches).</p><p>Bear in mind that the &ldquo;summary phrase&rdquo; of your email becomes a globally-unique
identifier for that patch. It propagates all the way into the git changelog.
The &ldquo;summary phrase&rdquo; may later be used in developer discussions which refer to
the patch. People will want to google for the &ldquo;summary phrase&rdquo; to read
discussion regarding that patch. It will also be the only thing that people
may quickly see when, two or three months later, they are going through
perhaps thousands of patches using tools such as &ldquo;gitk&rdquo; or &ldquo;git log
&ndash;oneline&rdquo;.</p><p>For these reasons, the &ldquo;summary&rdquo; must be no more than 70-75 characters, and it
must describe both what the patch changes, as well as why the patch might be
necessary. It is challenging to be both succinct and descriptive, but that is
what a well-written summary should do.</p><p>The &ldquo;summary phrase&rdquo; may be prefixed by tags enclosed in square brackets:
&ldquo;Subject: [PATCH tag] <summary phrase>&rdquo;. The tags are not considered part of
the summary phrase, but describe how the patch should be treated. Common tags
might include a version descriptor if the multiple versions of the patch have
been sent out in response to comments (i.e., &ldquo;v1, v2, v3&rdquo;), or &ldquo;RFC&rdquo; to
indicate a request for comments. If there are four patches in a patch series
the individual patches may be numbered like this: 1/4, 2/4, 3/4, 4/4. This
assures that developers understand the order in which the patches should be
applied and that they have reviewed or applied all of the patches in the patch
series.</p><p>A couple of example Subjects:</p><pre><code>Subject: [patch 2/5] ext2: improve scalability of bitmap searching
Subject: [PATCHv2 001/207] x86: fix eflags tracking
</code></pre><p>The &ldquo;from&rdquo; line must be the very first line in the message body, and has the
form:</p><pre><code>    From: Original Author &lt;author@example.com&gt;
</code></pre><p>The &ldquo;from&rdquo; line specifies who will be credited as the author of the patch in
the permanent changelog. If the &ldquo;from&rdquo; line is missing, then the &ldquo;From:&rdquo; line
from the email header will be used to determine the patch author in the
changelog.</p><p>The explanation body will be committed to the permanent source changelog, so
should make sense to a competent reader who has long since forgotten the
immediate details of the discussion that might have led to this patch.
Including symptoms of the failure which the patch addresses (kernel log
messages, oops messages, etc.) is especially useful for people who
might be searching the commit logs looking for the applicable patch. If a
patch fixes a compile failure, it may not be necessary to include <em>all</em> of the
compile failures; just enough that it is likely that someone searching for the
patch can find it. As in the &ldquo;summary phrase&rdquo;, it is important to be both
succinct as well as descriptive.</p><p>The &ldquo;&mdash;&rdquo; marker line serves the essential purpose of marking for patch
handling tools where the changelog message ends.</p><p>One good use for the additional comments after the &ldquo;&mdash;&rdquo; marker is for a
diffstat, to show what files have changed, and the number of inserted and
deleted lines per file. A diffstat is especially useful on bigger patches.
Other comments relevant only to the moment or the maintainer, not suitable for
the permanent changelog, should also go here. A good example of such comments
might be &ldquo;patch changelogs&rdquo; which describe what has changed between the v1 and
v2 version of the patch.</p><p>If you are going to include a diffstat after the &ldquo;&mdash;&rdquo; marker, please use
diffstat options &ldquo;-p 1 -w 70&rdquo; so that filenames are listed from the top of the
kernel source tree and don&rsquo;t use too much horizontal space (easily fit in 80
columns, maybe with some indentation).</p><p>See more details on the proper patch format in the following references.</p><ol start=16><li>Sending &ldquo;git pull&rdquo; requests (from Linus emails)</li></ol><p>Please write the git repo address and branch name alone on the same line so
that I can&rsquo;t even by mistake pull from the wrong branch, and so that a
triple-click just selects the whole thing.</p><p>So the proper format is something along the lines of:</p><pre><code>    &quot;Please pull from

            git://jdelvare.pck.nerim.net/jdelvare-2.6 i2c-for-linus

     to get these changes:&quot;
</code></pre><p>so that I don&rsquo;t have to hunt-and-peck for the address and inevitably get it
wrong (actually, I&rsquo;ve only gotten it wrong a few times, and checking against
the diffstat tells me when I get it wrong, but I&rsquo;m just a lot more comfortable
when I don&rsquo;t have to &ldquo;look for&rdquo; the right thing to pull, and double-check that
I have the right branch-name).</p><p>Please use &ldquo;git diff -M &ndash;stat &ndash;summary&rdquo; to generate the diffstat:
the -M enables rename detection, and the summary enables a summary of
new/deleted or renamed files.</p><p>With rename detection, the statistics are rather different [&mldr;] because git
will notice that a fair number of the changes are renames.</p><hr><h2 id=section-2---hints-tips-and-tricks>SECTION 2 - HINTS, TIPS, AND TRICKS <a href=#section-2---hints-tips-and-tricks class=anchor aria-hidden=true>#</a><a href=#section-2---hints-tips-and-tricks class=anchor aria-hidden=true>#</a></h2><p>This section lists many of the common &ldquo;rules&rdquo; associated with code submitted
to the kernel. There are always exceptions&mldr; but you must have a really good
reason for doing so. You could probably call this section Linus Computer
Science 101.</p><ol><li>Read Documentation/CodingStyle</li></ol><p>Nuff said. If your code deviates too much from this, it is likely to be
rejected without further review, and without comment.</p><p>One significant exception is when moving code from one file to another &ndash; in
this case you should not modify the moved code at all in the same patch which
moves it. This clearly delineates the act of moving the code and your
changes. This greatly aids review of the actual differences and allows tools
to better track the history of the code itself.</p><p>Check your patches with the patch style checker prior to submission
(scripts/checkpatch.pl). The style checker should be viewed as a guide not as
the final word. If your code looks better with a violation then its probably
best left alone.</p><p>The checker reports at three levels:</p><ul><li>ERROR: things that are very likely to be wrong</li><li>WARNING: things requiring careful review</li><li>CHECK: things requiring thought</li></ul><p>You should be able to justify all violations that remain in your patch.</p><ol start=2><li>#ifdefs are ugly</li></ol><p>Code cluttered with ifdefs is difficult to read and maintain. Don&rsquo;t do it.
Instead, put your ifdefs in a header, and conditionally define &lsquo;static inline&rsquo;
functions, or macros, which are used in the code. Let the compiler optimize
away the &ldquo;no-op&rdquo; case.</p><p>Simple example, of poor code:</p><pre><code>    dev = alloc_etherdev (sizeof(struct funky_private));
    if (!dev)
            return -ENODEV;
    #ifdef CONFIG_NET_FUNKINESS
    init_funky_net(dev);
    #endif
</code></pre><p>Cleaned-up example:</p><p>(in header)
#ifndef CONFIG_NET_FUNKINESS
static inline void init_funky_net (struct net_device *d) {}
#endif</p><p>(in the code itself)
dev = alloc_etherdev (sizeof(struct funky_private));
if (!dev)
return -ENODEV;
init_funky_net(dev);</p><ol start=3><li>&lsquo;static inline&rsquo; is better than a macro</li></ol><p>Static inline functions are greatly preferred over macros. They provide type
safety, have no length limitations, no formatting limitations, and under gcc
they are as cheap as macros.</p><p>Macros should only be used for cases where a static inline is clearly
suboptimal [there are a few, isolated cases of this in fast paths], or where
it is impossible to use a static inline function [such as string-izing].</p><p>&lsquo;static inline&rsquo; is preferred over &lsquo;static <strong>inline</strong>&rsquo;, &lsquo;extern inline&rsquo;, and
&lsquo;extern <strong>inline</strong>&rsquo;.</p><ol start=4><li>Don&rsquo;t over-design.</li></ol><p>Don&rsquo;t try to anticipate nebulous future cases which may or may not be useful:
&ldquo;Make it as simple as you can, and no simpler.&rdquo;</p><p>[57] SubmittingPatches.txt</p><h2 id=submitting-drivers-for-the-linux-kernel>Submitting Drivers For The Linux Kernel <a href=#submitting-drivers-for-the-linux-kernel class=anchor aria-hidden=true>#</a><a href=#submitting-drivers-for-the-linux-kernel class=anchor aria-hidden=true>#</a></h2><p>This document is intended to explain how to submit device drivers to the
various kernel trees. Note that if you are interested in video card drivers
you should probably talk to XFree86 (http://www.xfree86.org/) and/or X.Org
(http://x.org/) instead.</p><p>Also read the Documentation/SubmittingPatches document.</p><h2 id=allocating-device-numbers>Allocating Device Numbers <a href=#allocating-device-numbers class=anchor aria-hidden=true>#</a><a href=#allocating-device-numbers class=anchor aria-hidden=true>#</a></h2><p>Major and minor numbers for block and character devices are allocated by the
Linux assigned name and number authority (currently this is Torben Mathiasen).
The site is http://www.lanana.org/. This also deals with allocating numbers
for devices that are not going to be submitted to the mainstream kernel. See
Documentation/devices.txt for more information on this.</p><p>If you don&rsquo;t use assigned numbers then when your device is submitted it will
be given an assigned number even if that is different from values you may have
shipped to customers before.</p><h2 id=who-to-submit-drivers-to>Who To Submit Drivers To <a href=#who-to-submit-drivers-to class=anchor aria-hidden=true>#</a><a href=#who-to-submit-drivers-to class=anchor aria-hidden=true>#</a></h2><p>Linux 2.0:
No new drivers are accepted for this kernel tree.</p><p>Linux 2.2:
No new drivers are accepted for this kernel tree.</p><p>Linux 2.4:
If the code area has a general maintainer then please submit it to the
maintainer listed in MAINTAINERS in the kernel file. If the maintainer
does not respond or you cannot find the appropriate maintainer then
please contact Willy Tarreau <a href=mailto:w@1wt.eu>w@1wt.eu</a>.</p><p>Linux 2.6:
The same rules apply as 2.4 except that you should follow linux-kernel
to track changes in API&rsquo;s. The final contact point for Linux 2.6
submissions is Andrew Morton.</p><h2 id=what-criteria-determine-acceptance>What Criteria Determine Acceptance <a href=#what-criteria-determine-acceptance class=anchor aria-hidden=true>#</a><a href=#what-criteria-determine-acceptance class=anchor aria-hidden=true>#</a></h2><p>Licensing: The code must be released to us under the GNU General Public
License. We don&rsquo;t insist on any kind of exclusive GPL licensing,
and if you wish the driver to be useful to other communities such
as BSD you may well wish to release under multiple licenses. See
accepted licenses at include/linux/module.h</p><p>Copyright: The copyright owner must agree to use of GPL. It&rsquo;s best if the
submitter and copyright owner are the same person/entity. If not,
the name of the person/entity authorizing use of GPL should be
listed in case it&rsquo;s necessary to verify the will of the copyright
owner.</p><p>Interfaces: If your driver uses existing interfaces and behaves like other
drivers in the same class it will be much more likely to be
accepted than if it invents gratuitous new ones. If you need to
implement a common API over Linux and NT drivers do it in
userspace.</p><p>Code: Please use the Linux style of code formatting as documented in
Documentation/CodingStyle. If you have sections of code that need
to be in other formats, for example because they are shared with a
windows driver kit and you want to maintain them just once
separate them out nicely and note this fact.</p><p>Portability:Pointers are not always 32bits, not all computers are little
endian, people do not all have floating point and you shouldn&rsquo;t
use inline x86 assembler in your driver without careful thought.
Pure x86 drivers generally are not popular. If you only have x86
hardware it is hard to test portability but it is easy to make
sure the code can easily be made portable.</p><p>Clarity: It helps if anyone can see how to fix the driver. It helps you
because you get patches not bug reports. If you submit a driver
that intentionally obfuscates how the hardware works it will go in
the bitbucket.</p><p>PM support: Since Linux is used on many portable and desktop systems, your
driver is likely to be used on such a system and therefore it
should support basic power management by implementing, if
necessary, the .suspend and .resume methods used during the
system-wide suspend and resume transitions. You should verify
that your driver correctly handles the suspend and resume, but if
you are unable to ensure that, please at least define the .suspend
method returning the -ENOSYS (&ldquo;Function not implemented&rdquo;) error.
You should also try to make sure that your driver uses as little
power as possible when it&rsquo;s not doing anything. For the driver
testing instructions see Documentation/power/drivers-testing.txt
and for a relatively complete overview of the power management
issues related to drivers see Documentation/power/devices.txt .</p><p>Control: In general if there is active maintenance of a driver by the
author then patches will be redirected to them unless they are
totally obvious and without need of checking. If you want to be
the contact and update point for the driver it is a good idea to
state this in the comments, and include an entry in MAINTAINERS
for your driver.</p><h2 id=what-criteria-do-not-determine-acceptance>What Criteria Do Not Determine Acceptance <a href=#what-criteria-do-not-determine-acceptance class=anchor aria-hidden=true>#</a><a href=#what-criteria-do-not-determine-acceptance class=anchor aria-hidden=true>#</a></h2><p>Vendor: Being the hardware vendor and maintaining the driver is often a
good thing. If there is a stable working driver from other people
already in the tree don&rsquo;t expect &lsquo;we are the vendor&rsquo; to get your
driver chosen. Ideally work with the existing driver author to
build a single perfect driver.</p><p>Author: It doesn&rsquo;t matter if a large Linux company wrote the driver, or
kernel tree. Anyone who tells you otherwise
isn&rsquo;t telling the whole story.</p><p>[58] VGA-softcursor.txt</p><p>Linux now has some ability to manipulate cursor appearance. Normally, you can
set the size of hardware cursor (and also work around some ugly bugs in those
miserable Trident cards&ndash;see #define TRIDENT_GLITCH in
drivers/video/vgacon.c). You can now play a few new tricks: you can make your
cursor look like a non-blinking red block, make it inverse background of the
character it&rsquo;s over or to highlight that character and still choose whether
the original hardware cursor should remain visible or not. There may be other
things I have never thought of.</p><p>[59] applying-patches.txt</p><p>A frequently asked question on the Linux Kernel Mailing List is how to apply a
patch to the kernel or, more specifically, what base kernel a patch for one of
the many trees/branches should be applied to. Hopefully this document will
explain this to you.</p><p>[60] atomic_opts.txt</p><p>This document is intended to serve as a guide to Linux port maintainers on how
to implement atomic counter, bitops, and spinlock interfaces properly.</p><p>port这里是移植的意思。</p><p>[61] bad_memory.txt</p><p>How to deal with bad memory e.g. reported by memtest86+ ?</p><p>如何处理内存诊断工具memtest86+报告的坏内存。
#########################################################</p><p>There are three possibilities I know of:</p><ol><li>Reinsert/swap the memory modules</li></ol><p>重新插入内存条、将内存条拔下来插入其他内存槽。</p><ol start=2><li>Buy new modules (best!) or try to exchange the memory
if you have spare-parts</li></ol><p>购买新的内存条（这是最好的）或者试着换用其他备用的内存，如果你有的话。</p><ol start=3><li>Use BadRAM or memmap</li></ol><p>继续使用坏内存，但是要对其中的某些坏区域进行屏蔽。</p><p>This Howto is about number 3) .</p><p>BadRAM</p><h6 id=heading><a href=#heading class=anchor aria-hidden=true>#</a><a href=#heading class=anchor aria-hidden=true>#</a></h6><p>BadRAM is the actively developed and available as kernel-patch
here: http://rick.vanrein.org/linux/badram/</p><p>For more details see the BadRAM documentation.</p><p>memmap</p><h6 id=heading-1><a href=#heading-1 class=anchor aria-hidden=true>#</a><a href=#heading-1 class=anchor aria-hidden=true>#</a></h6><p>memmap is already in the kernel and usable as kernel-parameter at
boot-time. Its syntax is slightly strange and you may need to
calculate the values by yourself!</p><p>Syntax to exclude a memory area (see kernel-parameters.txt for details):
memmap=<size>$<address></p><p>memmap=容量:起始地址。
注意，这里容量的表示有两种方式，一种是通过十进制+容量单位，一种是通过16进制，
采用16进制的时候，默认表示容量单位为字节。
可以参照下面的示例。</p><p>Example: memtest86+ reported here errors at address 0x18691458, 0x1869and
some others. All had 0x1869xxxx in common, so I chose a pattern of
0x18690000,0xffff0000.</p><p>With the numbers of the example above:
memmap=64K$0x18690000
or
memmap=0x10000$0x18690000</p><p>[62] basic_profiling.txt</p><p>[63] binfmt_misc.txt</p><p>This Kernel feature allows you to invoke almost (for restrictions see below)
every program by simply typing its name in the shell. This includes for
example compiled Java(TM), Python or Emacs programs.</p><p>只要你在shell里面输入程序的名字，linux内核几乎允许你执行所有的程序，例如运行
java程序、python程序或者emacs程序等。</p><p>To achieve this you must tell binfmt_misc which interpreter has to be invoked
with which binary. Binfmt_misc recognises the binary-type by matching some
bytes at the beginning of the file with a magic byte sequence (masking out
specified bits) you have supplied. Binfmt_misc can also recognise a filename
extension aka &lsquo;.com&rsquo; or &lsquo;.exe&rsquo;.</p><p>A few examples (assumed you are in /proc/sys/fs/binfmt_misc):</p><ul><li><p>enable support for em86 (like binfmt_em86, for Alpha AXP only):
echo &lsquo;:i386:M::\x7fELF\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02
\x00\x03:\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff
\xff\xfb\xff\xff:/bin/em86:&rsquo; > register
echo &lsquo;:i486:M::\x7fELF\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02
\x00\x06:\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff
\xff\xfb\xff\xff:/bin/em86:&rsquo; > register</p></li><li><p>enable support for packed DOS applications (pre-configured dosemu hdimages):
echo &lsquo;:DEXE:M::\x0eDEX::/usr/bin/dosexec:&rsquo; > register</p></li><li><p>enable support for Windows executables using wine:
echo &lsquo;:DOSWin:M::MZ::/usr/local/bin/wine:&rsquo; > register</p></li></ul><p>For java support see Documentation/java.txt</p><p>[64] braille-console.txt</p><p>To get early boot messages on a braille device (before userspace screen
readers can start), you first need to compile the support for the usual serial
console (see serial-console.txt), and for braille device (in Device Drivers -
Accessibility).</p><p>[65] bt8xxgpio.txt</p><p>[66] btmrvl.txt</p><p>All commands are used via debugfs interface.</p><p>[67] bus-virt-phys-mapping.txt</p><p>[ NOTE: The virt_to_bus() and bus_to_virt() functions have been
superseded by the functionality provided by the PCI DMA interface
(see Documentation/DMA-API-HOWTO.txt). They continue
to be documented below for historical purposes, but new code
must not use them. &ndash;davidm 00/12/12 ]</p><p>[ This is a mail message in response to a query on IO mapping, thus the
strange format for a &ldquo;document&rdquo; ]</p><p>The AHA-is a bus-master device, and your patch makes the driver give the
controller the physical address of the buffers, which is correct on x86
(because all bus master devices see the physical memory mappings directly).</p><p>However, on many setups, there are actually <em>three</em> different ways of looking
at memory addresses, and in this case we actually want the third, the
so-called &ldquo;bus address&rdquo;.</p><p>Essentially, the three ways of addressing memory are (this is &ldquo;real memory&rdquo;,
that is, normal RAM&ndash;see later about other details):</p><pre><code> - CPU untranslated.  This is the &quot;physical&quot; address.  Physical address 
   0 is what the CPU sees when it drives zeroes on the memory bus.

 - CPU translated address. This is the &quot;virtual&quot; address, and is 
   completely internal to the CPU itself with the CPU doing the appropriate
   translations into &quot;CPU untranslated&quot;. 

 - bus address. This is the address of memory as seen by OTHER devices, 
   not the CPU. Now, in theory there could be many different bus 
   addresses, with each device seeing memory in some device-specific way, but
   happily most hardware designers aren't actually actively trying to make
   things any more complex than necessary, so you can assume that all 
   external hardware sees the memory the same way. 
</code></pre><p>Now, on normal PCs the bus address is exactly the same as the physical
address, and things are very simple indeed. However, they are that simple
because the memory and the devices share the same address space, and that is
not generally necessarily true on other PCI/ISA setups.</p><p>Now, just as an example, on the PReP (PowerPC Reference Platform), the CPU
sees a memory map something like this (this is from memory):</p><pre><code>0-2 GB          &quot;real memory&quot;
2 GB-3 GB       &quot;system IO&quot; (inb/out and similar accesses on x86)
3 GB-4 GB       &quot;IO memory&quot; (shared memory over the IO bus)
</code></pre><p>Now, that looks simple enough. However, when you look at the same thing from
the viewpoint of the devices, you have the reverse, and the physical memory
address 0 actually shows up as address 2 GB for any IO master.</p><p>So when the CPU wants any bus master to write to physical memory 0, it has to
give the master address 0x8000as the memory address.</p><p>So, for example, depending on how the kernel is actually mapped on the PPC,
you can end up with a setup like this:</p><pre><code> physical address:      0
 virtual address:       0xC0000000
 bus address:           0x80000000
</code></pre><p>where all the addresses actually point to the same thing. It&rsquo;s just seen
through different translations..</p><p>[68] cachetlb.txt</p><p>Cache and TLB Flushing Under Linux</p><p>转译后备缓冲器，在中国大陆也被翻译为页表缓存、转址旁路缓存，为CPU的一种缓存，
由存储器管理单元用于改进虚拟地址到物理地址的转译速度。目前所有的桌面型及服务器
型处理器皆使用TLB。TLB具有固定数目的空间槽，用于存放将虚拟地址映射至物理地址的
标签页表条目。为典型的内容可寻址存储器。其搜索关键字为虚拟内存地址，其搜索结果
为物理地址。如果请求的虚拟地址在TLB中存在，CAM 将给出一个非常快速的匹配结果，
之后就可以使用得到的物理地址访问存储器。如果请求的虚拟地址不在TLB 中，就会使用
标签页表进行虚实地址转换，而标签页表的访问速度比TLB慢很多。</p><p>[69] circular-buffers.txt</p><p>Linux provides a number of features that can be used to implement circular
buffering. There are two sets of such features:</p><p>linux提供了一些特征用于实现环形缓冲，这些特征主要可以分为两组：</p><p>(1) Convenience functions for determining information about power-of-2 sized
buffers.</p><pre><code> 一些方便使用的函数，用于获取、设置2^x的容量的环形缓冲区中的信息。
</code></pre><p>(2) Memory barriers for when the producer and the consumer of objects in the
buffer don&rsquo;t want to share a lock.</p><pre><code> 内存访问限制，用于保证环形缓冲区中数据对象的生产者和消费者不能共享锁。
</code></pre><p>To use these facilities, as discussed below, there needs to be just one
producer and just one consumer. It is possible to handle multiple producers
by serialising them, and to handle multiple consumers by serialising them.</p><p>[70] coccinelle.txt</p><p>[71] cpu-hotplug.txt</p><p>CPU hotplug Support in Linux(tm) Kernel</p><p>[72] cpu-load.txt</p><p>Linux exports various bits of information via <code>/proc/stat' and </code>/proc/uptime'
that userland tools, such as top(1), use to calculate the average time system
spent in a particular state</p><p>[73] cputopology.txt</p><p>Export CPU topology info via sysfs. Items (attributes) are similar to
/proc/cpuinfo.</p><p>[74] dcdbas.txt</p><p>The Dell Systems Management Base Driver provides a sysfs interface for
systems management software such as Dell OpenManage to perform system
management interrupts and host control actions (system power cycle or power
off after OS shutdown) on certain Dell systems.</p><p>[75] debugging-modules.txt</p><p>Debugging Modules after 2.6.3</p><p>[76] debugging-via-ohci1394.txt</p><p>Using physical DMA provided by OHCI-FireWire controllers for debugging</p><p>[77] dell_rbu.txt</p><p>Purpose:
Demonstrate the usage of the new open sourced rbu (Remote BIOS Update) driver
for updating BIOS images on Dell servers and desktops.</p><p>[78] devices.txt</p><p>This list is the Linux Device List, the official registry of allocated device
numbers and /dev directory nodes for the Linux operating system.</p><p>[79] dmaengine.txt</p><p>Below is a guide to device driver writers on how to use the Slave-DMA API of
the DMA Engine. This is applicable only for slave DMA usage only</p><p>[80] dontdiff.txt</p><p>[81] dynamic-debug-howto.txt</p><p>This document describes how to use the dynamic debug (ddebug) feature.</p><p>Dynamic debug is designed to allow you to dynamically enable/disable kernel
code to obtain additional kernel information. Currently, if
CONFIG_DYNAMIC_DEBUG is set, then all pr_debug()/dev_dbg() calls can be
dynamically enabled per-callsite.</p><p>Dynamic debug has even more useful features:</p><ul><li><p>Simple query language allows turning on and off debugging statements by
matching any combination of:</p><ul><li>source filename</li><li>function name</li><li>line number (including ranges of line numbers)</li><li>module name</li><li>format string</li></ul></li><li><p>Provides a debugfs control file: <debugfs>/dynamic_debug/control which can</p></li><li><p>be read to display the complete list of known debug statements, to help guide
you</p></li></ul><p>[82] edac.txt</p><p>EDAC, error detection and correction.</p><p>The &lsquo;edac&rsquo; kernel module goal is to detect and report errors that occur within
the computer system running under linux.</p><p>[83] eisa.txt</p><p>EISA bus support.</p><p>[84] email-clients.txt</p><p>Email clients info for Linux.
介绍了在通过email提交linux内核补丁信息时的一些与email客户端相关的注意事项，例
如使用Alphine、Evolution、Kmail、Lotus Notes、Mutt、Pine、Sylpheed、
Thunderbird、TkRat、Gmail Web等。</p><p>[85] feature-removal-schedule.txt</p><p>The following is a list of files and features that are going to be removed in
the kernel source tree. Every entry should contain what exactly is going
away, why it is happening, and who is going to be doing the work. When the
feature is removed from the kernel, it should also be removed from this file.</p><p>Mon Sep 29 012:03:32 CST 2014</p><p>[86] flexible-arrays.txt</p><p>Large contiguous memory allocations can be unreliable in the Linux kernel.
Kernel programmers will sometimes respond to this problem by allocating pages
with vmalloc(). This solution not ideal, though. On 32-bit systems, memory
from vmalloc() must be mapped into a relatively small address space; it&rsquo;s easy
to run out. On SMP systems, the page table changes required by vmalloc()
allocations can require expensive cross-processor interrupts on all CPUs.
And, on all systems, use of space in the vmalloc() range increases pressure on
the translation lookaside buffer (TLB), reducing the erformance of the system</p><p>[87] futex-requeue-pi.txt</p><h2 id=futex-requeue-pi>Futex Requeue PI <a href=#futex-requeue-pi class=anchor aria-hidden=true>#</a><a href=#futex-requeue-pi class=anchor aria-hidden=true>#</a></h2><p>Requeueing of tasks from a non-PI futex to a PI futex requires special
handling in order to ensure the underlying rt_mutex is never left without an
owner if it has waiters; doing so would break the PI boosting logic [see
rt-mutex-desgin.txt] For the purposes of brevity, this action will be referred
to as &ldquo;requeue_pi&rdquo; throughout this document. Priority inheritance is
abbreviated throughout as &ldquo;PI&rdquo;.</p><p>[88] gcov.txt</p><p>Using gcov with the Linux kernel</p><p>[89] gpio.txt</p><p>A &ldquo;General Purpose Input/Output&rdquo; (GPIO) is a flexible software-controlled
digital signal. They are provided from many kinds of chip, and are familiar
to Linux developers working with embedded and custom hardware.</p><p>[90] highuid.txt</p><p>Notes on the change from 16-bit UIDs to 32-bit UIDs:</p><ul><li><p>kernel code MUST take into account __kernel_uid_t and __kernel_uid32_t when
communicating between user and kernel space in an ioctl or data structure.</p></li><li><p>kernel code should use uid_t and gid_t in kernel-private structures and
code.</p></li></ul><p>[91] hw_random.txt</p><p>Introduction:</p><p>The hw_random framework is software that makes use of a special hardware
feature on your CPU or motherboard, a Random Number Generator (RNG). The
software has two parts: core providing the /dev/hw_random character device and
its sysfs support, plus a hardware-specific driver that plugs into that core.</p><p>To make the most effective use of these mechanisms, you should download the
support software as well. Download the latest version of the &ldquo;rng-tools&rdquo;
package from the hw_random driver&rsquo;s official Web site:</p><pre><code>    http://sourceforge.net/projects/gkernel/
</code></pre><p>Those tools use /dev/hw_random to fill the kernel entropy pool, which is used
internally and exported by the /dev/urandom and /dev/random special files.</p><p>[92] hwspinlock.txt</p><p>Hardware Spinlock Framework</p><p>[93] init.txt</p><p>Explaining the dreaded &ldquo;No init found.&rdquo; boot hang message</p><p>[94] initrd.txt</p><p>Using the initial RAM disk (initrd)</p><p>initrd provides the capability to load a RAM disk by the boot loader. This
RAM disk can then be mounted as the root file system and programs can be run
from it. Afterwards, a new root file system can be mounted from a different
device. The previous root (from initrd) is then moved to a directory and can
be subsequently unmounted.</p><p>initrd is mainly designed to allow system startup to occur in two phases,
where the kernel comes up with a minimum set of compiled-in drivers, and where
additional modules are loaded from initrd.</p><p>This document gives a brief overview of the use of initrd. A more detailed
discussion of the boot process can be found in [1].</p><p>Operation</p><p>When using initrd, the system typically boots as follows:</p><ol><li><p>the boot loader loads the kernel and the initial RAM disk</p></li><li><p>the kernel converts initrd into a &ldquo;normal&rdquo; RAM disk and frees the memory
used by initrd</p></li><li><p>if the root device is not /dev/ram0, the old (deprecated) change_root
procedure is followed. see the &ldquo;Obsolete root change mechanism&rdquo; section
below.</p></li><li><p>root device is mounted. if it is /dev/ram0, the initrd image is then
mounted as root</p></li><li><p>/sbin/init is executed (this can be any valid executable, including shell
scripts; it is run with uid 0 and can do basically everything init can
do).</p></li><li><p>init mounts the &ldquo;real&rdquo; root file system</p></li><li><p>init places the root file system at the root directory using the
pivot_root system call</p></li><li><p>init execs the /sbin/init on the new root filesystem, performing the
usual boot sequence</p></li><li><p>the initrd file system is removed</p></li></ol><pre><code>Note that changing the root directory does not involve unmounting it.  It
is therefore possible to leave processes running on initrd during that
procedure. Also note that file systems mounted under initrd continue to be
accessible.
</code></pre><p>[95] intel_txt.txt</p><p>Intel(R) TXT Overview:</p><p>Intel&rsquo;s technology for safer computing, Intel(R) Trusted Execution Technology
(Intel(R) TXT), defines platform-level enhancements that provide the building
blocks for creating trusted platforms.</p><p>Intel TXT was formerly known by the code name LaGrande Technology (LT).</p><p>Intel TXT in Brief:
o Provides dynamic root of trust for measurement (DRTM)
o Data protection in case of improper shutdown
o Measurement and verification of launched environment</p><p>Intel TXT is part of the vPro(TM) brand and is also available some non-vPro
systems. It is currently available on desktop systems based on the Q35, X38,
Q45, and Q43 Express chipsets (e.g. Dell Optiplex 755, HP dc7800, etc.)
and mobile systems based on the GM45, PM45, and GS45 Express chipsets.</p><p>[96] io-mapping.txt</p><p>The io_mapping functions in linux/io-mapping.h provide an abstraction for
efficiently mapping small regions of an I/O device to the CPU. The initial
usage is to support the large graphics aperture on 32-bit processors where
ioremap_wc cannot be used to statically map the entire aperture to the CPU as
it would consume too much of the kernel address space.</p><p>[97] io_ordering.txt</p><p>On some platforms, so-called memory-mapped I/O is weakly ordered. On such
platforms, driver writers are responsible for ensuring that I/O writes to
memory-mapped addresses on their device arrive in the order intended. This is
typically done by reading a &lsquo;safe&rsquo; device or bridge register, causing the I/O
chipset to flush pending writes to the device before any reads are posted. A
driver would usually use this technique immediately prior to the exit of a
critical section of code protected by spinlocks. This would ensure that
subsequent writes to I/O space arrived only after all prior writes (much like
a memory barrier op, mb(), only with respect to I/O).</p><p>[98] iostats.txt</p><p>I/O statistics fields</p><p>Since 2.4.20 (and some versions before, with patches), and 2.5.45, more
extensive disk statistics have been introduced to help measure disk activity.
Tools such as sar and iostat typically interpret these and do the work for
you, but in case you are interested in creating your own tools, the fields are
explained here.</p><p>[99] irqflags-tracing.txt</p><p>IRQ-flags state tracing</p><p>the &ldquo;irq-flags tracing&rdquo; feature &ldquo;traces&rdquo; hardirq and softirq state, in that it
gives interested subsystems an opportunity to be notified of every
hardirqs-off/hardirqs-on, softirqs-off/softirqs-on event that happens in the
kernel.</p><p>[100] isapnp.txt</p><p>ISA Plug & Play support</p><p>[101] java.txt</p><p>Java(tm) Binary Kernel Support for Linv1.03</p><p>Linux beats them ALL! While all other OS&rsquo;s are TALKING about direct of Java
Binaries in the OS, Linux is doing it!</p><p>[101] kernel-doc-nano-HOWTO.txt</p><p>[102] kernel-docs.txt</p><p>这篇文档列出了很多文档的索引以及参考书目，要经常看这些书目。</p><p>Index of Documentation for People Interested in Writing and/or
Understanding the Linux Kernel.
Juan-Mariano de Goyeneche <a href=mailto:jmseyas@dit.upm.es>jmseyas@dit.upm.es</a></p><p>The need for a document like this one became apparent in the linux-kernel
mailing list as the same questions, asking for pointers to information,
appeared again and again.</p><p>Fortunately, as more and more people get to GNU/Linux, more and more get
interested in the Kernel. But reading the sources is not always enough. It is
easy to understand the code, but miss the concepts, the philosophy and design
decisions behind this code.</p><p>Unfortunately, not many documents are available for beginners to start.
And, even if they exist, there was no &ldquo;well-known&rdquo; place which kept track
of them. These lines try to cover this lack. All documents available on
line known by the author are listed, while some reference books are also
mentioned.</p><p>PLEASE, if you know any paper not listed here or write a new document,
send me an e-mail, and I&rsquo;ll include a reference to it here. Any
corrections, ideas or comments are also welcomed.</p><p>The papers that follow are listed in no particular order. All are
cataloged with the following fields: the document&rsquo;s &ldquo;Title&rdquo;, the
&ldquo;Author&rdquo;/s, the &ldquo;URL&rdquo; where they can be found, some &ldquo;Keywords&rdquo; helpful
when searching for specific topics, and a brief &ldquo;Description&rdquo; of the
Document.</p><p>Enjoy!</p><p>ON-LINE DOCS:</p><ul><li><p>Title: &ldquo;Linux Device Drivers, Third Edition&rdquo;
Author: Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman
URL: http://lwn.net/Kernel/LDD3/
Description: A 600-page book covering the (2.6.10) driver
programming API and kernel hacking in general. Available under the
Creative Commons Attribution-ShareAlike 2.0 license.</p></li><li><p>Title: &ldquo;The Linux Kernel&rdquo;
Author: David A. Rusling.
URL: http://www.tldp.org/LDP/tlk/tlk.html
Keywords: everything!, book.
Description: On line, 200 pages book describing most aspects of
the Linux Kernel. Probably, the first reference for beginners.
Lots of illustrations explaining data structures use and
relationships in the purest Richard W. Stevens' style. Contents:
&ldquo;1.-Hardware Basics, 2.-Software Basics, 3.-Memory Management,
4.-Processes, 5.-Interprocess Communication Mechanisms, 6.-PCI,
7.-Interrupts and Interrupt Handling, 8.-Device Drivers, 9.-The
File system, 10.-Networks, 11.-Kernel Mechanisms, 12.-Modules,
13.-The Linux Kernel Sources, A.-Linux Data Structures, B.-The
Alpha AXP Processor, C.-Useful Web and FTP Sites, D.-The GNU
General Public License, Glossary&rdquo;. In short: a must have.</p></li><li><p>Title: &ldquo;Linux Device Drivers, 2nd Edition&rdquo;
Author: Alessandro Rubini and Jonathan Corbet.
URL: http://www.xml.com/ldd/chapter/book/index.html
Keywords: device drivers, modules, debugging, memory, hardware,
interrupt handling, char drivers, block drivers, kmod, mmap, DMA,
buses.
Description: O&rsquo;Reilly&rsquo;s popular book, now also on-line under the
GNU Free Documentation License.
Notes: You can also buy it in paper-form from O&rsquo;Reilly. See below
under BOOKS (Not on-line).</p></li><li><p>Title: &ldquo;Conceptual Architecture of the Linux Kernel&rdquo;
Author: Ivan T. Bowman.
URL: http://plg.uwaterloo.ca/
Keywords: conceptual software architecture, extracted design,
reverse engineering, system structure.
Description: Conceptual software architecture of the Linux kernel,
automatically extracted from the source code. Very detailed. Good
figures. Gives good overall kernel understanding.</p></li><li><p>Title: &ldquo;Concrete Architecture of the Linux Kernel&rdquo;
Author: Ivan T. Bowman, Saheem Siddiqi, and Meyer C. Tanuan.
URL: http://plg.uwaterloo.ca/
Keywords: concrete architecture, extracted design, reverse
engineering, system structure, dependencies.
Description: Concrete architecture of the Linux kernel,
automatically extracted from the source code. Very detailed. Good
figures. Gives good overall kernel understanding. This papers
focus on lower details than its predecessor (files, variables&mldr;).</p></li><li><p>Title: &ldquo;Linux as a Case Study: Its Extracted Software
Architecture&rdquo;
Author: Ivan T. Bowman, Richard C. Holt and Neil V. Brewster.
URL: http://plg.uwaterloo.ca/
Keywords: software architecture, architecture recovery,
redocumentation.
Description: Paper appeared at ICSE'99, Los Angeles, May 16-22,</p></li></ul><ol start=1999><li>A mixture of the previous two documents from the same
author.</li></ol><ul><li><p>Title: &ldquo;Overview of the Virtual File System&rdquo;
Author: Richard Gooch.
URL: http://www.mjmwired.net/kernel/Documentation/filesystems/vfs.txt
Keywords: VFS, File System, mounting filesystems, opening files,
dentries, dcache.
Description: Brief introduction to the Linux Virtual File System.
What is it, how it works, operations taken when opening a file or
mounting a file system and description of important data
structures explaining the purpose of each of their entries.</p></li><li><p>Title: &ldquo;The Linux RAID-1, 4, 5 Code&rdquo;
Author: Ingo Molnar, Gadi Oxman and Miguel de Icaza.
URL: http://www.linuxjournal.com/article.php?sid=2391
Keywords: RAID, MD driver.
Description: Linux Journal Kernel Korner article. Here is its
abstract: &ldquo;A description of the implementation of the RAID-1,
RAID-4 and RAID-5 personalities of the MD device driver in the
Linux kernel, providing users with high performance and reliable,
secondary-storage capability using software&rdquo;.</p></li><li><p>Title: &ldquo;Dynamic Kernels: Modularized Device Drivers&rdquo;
Author: Alessandro Rubini.
URL: http://www.linuxjournal.com/article.php?sid=1219
Keywords: device driver, module, loading/unloading modules,
allocating resources.
Description: Linux Journal Kernel Korner article. Here is its
abstract: &ldquo;This is the first of a series of four articles
co-authored by Alessandro Rubini and Georg Zezchwitz which present
a practical approach to writing Linux device drivers as kernel
loadable modules. This installment presents an introduction to the
topic, preparing the reader to understand next month&rsquo;s
installment&rdquo;.</p></li><li><p>Title: &ldquo;Dynamic Kernels: Discovery&rdquo;
Author: Alessandro Rubini.
URL: http://www.linuxjournal.com/article.php?sid=1220
Keywords: character driver, init_module, clean_up module,
autodetection, mayor number, minor number, file operations,
open(), close().
Description: Linux Journal Kernel Korner article. Here is its
abstract: &ldquo;This article, the second of four, introduces part of
the actual code to create custom module implementing a character
device driver. It describes the code for module initialization and
cleanup, as well as the open() and close() system calls&rdquo;.</p></li><li><p>Title: &ldquo;The Devil&rsquo;s in the Details&rdquo;
Author: Georg v. Zezschwitz and Alessandro Rubini.
URL: http://www.linuxjournal.com/article.php?sid=1221
Keywords: read(), write(), select(), ioctl(), blocking/non
blocking mode, interrupt handler.
Description: Linux Journal Kernel Korner article. Here is its
abstract: &ldquo;This article, the third of four on writing character
device drivers, introduces concepts of reading, writing, and using
ioctl-calls&rdquo;.</p></li><li><p>Title: &ldquo;Dissecting Interrupts and Browsing DMA&rdquo;
Author: Alessandro Rubini and Georg v. Zezschwitz.
URL: http://www.linuxjournal.com/article.php?sid=1222
Keywords: interrupts, irqs, DMA, bottom halves, task queues.
Description: Linux Journal Kernel Korner article. Here is its
abstract: &ldquo;This is the fourth in a series of articles about
writing character device drivers as loadable kernel modules. This
month, we further investigate the field of interrupt handling.
Though it is conceptually simple, practical limitations and
constraints make this an ``interesting'' part of device driver
writing, and several different facilities have been provided for
different situations. We also investigate the complex topic of
DMA&rdquo;.</p></li><li><p>Title: &ldquo;Device Drivers Concluded&rdquo;
Author: Georg v. Zezschwitz.
URL: http://www.linuxjournal.com/article.php?sid=1287
Keywords: address spaces, pages, pagination, page management,
demand loading, swapping, memory protection, memory mapping, mmap,
virtual memory areas (VMAs), vremap, PCI.
Description: Finally, the above turned out into a five articles
series. This latest one&rsquo;s introduction reads: &ldquo;This is the last of
five articles about character device drivers. In this final
section, Georg deals with memory mapping devices, beginning with
an overall description of the Linux memory management concepts&rdquo;.</p></li><li><p>Title: &ldquo;Network Buffers And Memory Management&rdquo;
Author: Alan Cox.
URL: http://www.linuxjournal.com/article.php?sid=1312
Keywords: sk_buffs, network devices, protocol/link layer
variables, network devices flags, transmit, receive,
configuration, multicast.
Description: Linux Journal Kernel Korner. Here is the abstract:
&ldquo;Writing a network device driver for Linux is fundamentally
simple&mdash;most of the complexity (other than talking to the
hardware) involves managing network packets in memory&rdquo;.</p></li><li><p>Title: &ldquo;Writing Linux Device Drivers&rdquo;
Author: Michael K. Johnson.
URL: http://users.evitech.fi/~tk/rtos/writing_linux_device_d.html
Keywords: files, VFS, file operations, kernel interface, character
vs block devices, I/O access, hardware interrupts, DMA, access to
user memory, memory allocation, timers.
Description: Introductory 50-minutes (sic) tutorial on writing
device drivers. 12 pages written by the same author of the &ldquo;Kernel
Hackers' Guide&rdquo; which give a very good overview of the topic.</p></li><li><p>Title: &ldquo;The Venus kernel interface&rdquo;
Author: Peter J. Braam.
URL:
http://www.coda.cs.cmu.edu/doc/html/kernel-venus-protocol.html
Keywords: coda, filesystem, venus, cache manager.
Description: &ldquo;This document describes the communication between
Venus and kernel level file system code needed for the operation
of the Coda filesystem. This version document is meant to describe
the current interface (version 1.0) as well as improvements we
envisage&rdquo;.</p></li><li><p>Title: &ldquo;Programming PCI-Devices under Linux&rdquo;
Author: Claus Schroeter.
URL:
ftp://ftp.llp.fu-berlin.de/pub/linux/LINUX-LAB/whitepapers/pcip.ps.gz
Keywords: PCI, device, busmastering.
Description: 6 pages tutorial on PCI programming under Linux.
Gives the basic concepts on the architecture of the PCI subsystem,
as long as basic functions and macros to read/write the devices
and perform busmastering.</p></li><li><p>Title: &ldquo;Writing Character Device Driver for Linux&rdquo;
Author: R. Baruch and C. Schroeter.
URL:
ftp://ftp.llp.fu-berlin.de/pub/linux/LINUX-LAB/whitepapers/drivers.ps.gz
Keywords: character device drivers, I/O, signals, DMA, accessing
ports in user space, kernel environment.
Description: 68 pages paper on writing character drivers. A little
bit old (1.993, 1.994) although still useful.</p></li><li><p>Title: &ldquo;Design and Implementation of the Second Extended
Filesystem&rdquo;
Author: Rémy Card, Theodore Ts&rsquo;o, Stephen Tweedie.
URL: http://web.mit.edu/tytso/www/linux/ext2intro.html
Keywords: ext2, linux fs history, inode, directory, link, devices,
VFS, physical structure, performance, benchmarks, ext2fs library,
ext2fs tools, e2fsck.
Description: Paper written by three of the top ext2 hackers.
Covers Linux filesystems history, ext2 motivation, ext2 features,
design, physical structure on disk, performance, benchmarks,
e2fsck&rsquo;s passes description&mldr; A must read!
Notes: This paper was first published in the Proceedings of the
First Dutch International Symposium on Linux, ISBN 90-367-0385-9.</p></li><li><p>Title: &ldquo;Analysis of the Ext2fs structure&rdquo;
Author: Louis-Dominique Dubeau.
URL: http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
Keywords: ext2, filesystem, ext2fs.
Description: Description of ext2&rsquo;s blocks, directories, inodes,
bitmaps, invariants&mldr;</p></li><li><p>Title: &ldquo;Journaling the Linux ext2fs Filesystem&rdquo;
Author: Stephen C. Tweedie.
URL:
ftp://ftp.uk.linux.org/pub/linux/sct/fs/jfs/journal-design.ps.gz
Keywords: ext3, journaling.
Description: Excellent 8-pages paper explaining the journaling
capabilities added to ext2 by the author, showing different
problems faced and the alternatives chosen.</p></li><li><p>Title: &ldquo;Kernel API changes from 2.0 to 2.2&rdquo;
Author: Richard Gooch.
URL:
http://www.linuxhq.com/guides/LKMPG/node28.html
Keywords: 2.2, changes.
Description: Kernel functions/structures/variables which changed
from 2.0.x to 2.2.x.</p></li><li><p>Title: &ldquo;Kernel API changes from 2.2 to 2.4&rdquo;
Author: Richard Gooch.
Keywords: 2.4, changes.
Description: Kernel functions/structures/variables which changed
from 2.2.x to 2.4.x.</p></li><li><p>Title: &ldquo;Linux Kernel Module Programming Guide&rdquo;
Author: Ori Pomerantz.
URL: http://tldp.org/LDP/lkmpg/2.6/html/index.html
Keywords: modules, GPL book, /proc, ioctls, system calls,
interrupt handlers .
Description: Very nice 92 pages GPL book on the topic of modules
programming. Lots of examples.</p></li><li><p>Title: &ldquo;I/O Event Handling Under Linux&rdquo;
Author: Richard Gooch.
Keywords: IO, I/O, select(2), poll(2), FDs, aio_read(2), readiness
event queues.
Description: From the Introduction: &ldquo;I/O Event handling is about
how your Operating System allows you to manage a large number of
open files (file descriptors in UNIX/POSIX, or FDs) in your
application. You want the OS to notify you when FDs become active
(have data ready to be read or are ready for writing). Ideally you
want a mechanism that is scalable. This means a large number of
inactive FDs cost very little in memory and CPU time to manage&rdquo;.</p></li><li><p>Title: &ldquo;The Kernel Hacking HOWTO&rdquo;
Author: Various Talented People, and Rusty.
Location: in kernel tree, Documentation/DocBook/kernel-hacking.tmpl
(must be built as &ldquo;make {htmldocs | psdocs | pdfdocs})
Keywords: HOWTO, kernel contexts, deadlock, locking, modules,
symbols, return conventions.
Description: From the Introduction: &ldquo;Please understand that I
never wanted to write this document, being grossly underqualified,
but I always wanted to read it, and this was the only way. I
simply explain some best practices, and give reading entry-points
into the kernel sources. I avoid implementation details: that&rsquo;s
what the code is for, and I ignore whole tracts of useful
routines. This document assumes familiarity with C, and an
understanding of what the kernel is, and how it is used. It was
originally written for the 2.3 kernels, but nearly all of it
applies to 2.2 too; 2.0 is slightly different&rdquo;.</p></li><li><p>Title: &ldquo;Writing an ALSA Driver&rdquo;
Author: Takashi Iwai <a href=mailto:tiwai@suse.de>tiwai@suse.de</a>
URL: http://www.alsa-project.org/~iwai/writing-an-alsa-driver/index.html
Keywords: ALSA, sound, soundcard, driver, lowlevel, hardware.
Description: Advanced Linux Sound Architecture for developers,
both at kernel and user-level sides. ALSA is the Linux kernel
sound architecture in the 2.6 kernel version.</p></li><li><p>Title: &ldquo;Programming Guide for Linux USB Device Drivers&rdquo;
Author: Detlef Fliegl.
URL: http://usb.in.tum.de/usbdoc/
Keywords: USB, universal serial bus.
Description: A must-read. From the Preface: &ldquo;This document should
give detailed information about the current state of the USB
subsystem and its API for USB device drivers. The first section
will deal with the basics of USB devices. You will learn about
different types of devices and their properties. Going into detail
you will see how USB devices communicate on the bus. The second
section gives an overview of the Linux USB subsystem [2] and the
device driver framework. Then the API and its data structures will
be explained step by step. The last section of this document
contains a reference of all API calls and their return codes&rdquo;.
Notes: Beware: the main page states: &ldquo;This document may not be
published, printed or used in excerpts without explicit permission
of the author&rdquo;. Fortunately, it may still be read&mldr;</p></li><li><p>Title: &ldquo;Linux Kernel Mailing List Glossary&rdquo;
Author: various
URL: http://kernelnewbies.org/glossary/
Keywords: glossary, terms, linux-kernel.
Description: From the introduction: &ldquo;This glossary is intended as
a brief description of some of the acronyms and terms you may hear
during discussion of the Linux kernel&rdquo;.</p></li><li><p>Title: &ldquo;Linux Kernel Locking HOWTO&rdquo;
Author: Various Talented People, and Rusty.
Location: in kernel tree, Documentation/DocBook/kernel-locking.tmpl
(must be built as &ldquo;make {htmldocs | psdocs | pdfdocs})
Keywords: locks, locking, spinlock, semaphore, atomic, race
condition, bottom halves, tasklets, softirqs.
Description: The title says it all: document describing the
locking system in the Linux Kernel either in uniprocessor or SMP
systems.
Notes: &ldquo;It was originally written for the later (>2.3.47) 2.3
kernels, but most of it applies to 2.2 too; 2.0 is slightly
different&rdquo;. Freely redistributable under the conditions of the GNU
General Public License.</p></li><li><p>Title: &ldquo;Global spinlock list and usage&rdquo;
Author: Rick Lindsley.
URL: http://lse.sourceforge.net/lockhier/global-spin-lock
Keywords: spinlock.
Description: This is an attempt to document both the existence and
usage of the spinlocks in the Linux 2.4.5 kernel. Comprehensive
list of spinlocks showing when they are used, which functions
access them, how each lock is acquired, under what conditions it
is held, whether interrupts can occur or not while it is held&mldr;</p></li><li><p>Title: &ldquo;Porting Linux 2.0 Drivers To Linux 2.2: Changes and New
Features "
Author: Alan Cox.
URL: http://www.linux-mag.com/1999-05/gear_01.html
Keywords: ports, porting.
Description: Article from Linux Magazine on porting from 2.0 to
2.2 kernels.</p></li><li><p>Title: &ldquo;Porting Device Drivers To Linux 2.2: part II&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/238
Keywords: ports, porting.
Description: Second part on porting from 2.0 to 2.2 kernels.</p></li><li><p>Title: &ldquo;How To Make Sure Your Driver Will Work On The Power
Macintosh&rdquo;
Author: Paul Mackerras.
URL: http://www.linux-mag.com/id/261
Keywords: Mac, Power Macintosh, porting, drivers, compatibility.
Description: The title says it all.</p></li><li><p>Title: &ldquo;An Introduction to SCSI Drivers&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/284
Keywords: SCSI, device, driver.
Description: The title says it all.</p></li><li><p>Title: &ldquo;Advanced SCSI Drivers And Other Tales&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/307
Keywords: SCSI, device, driver, advanced.
Description: The title says it all.</p></li><li><p>Title: &ldquo;Writing Linux Mouse Drivers&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/330
Keywords: mouse, driver, gpm.
Description: The title says it all.</p></li><li><p>Title: &ldquo;More on Mouse Drivers&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/356
Keywords: mouse, driver, gpm, races, asynchronous I/O.
Description: The title still says it all.</p></li><li><p>Title: &ldquo;Writing Video4linux Radio Driver&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/381
Keywords: video4linux, driver, radio, radio devices.
Description: The title says it all.</p></li><li><p>Title: &ldquo;Video4linux Drivers, Part 1: Video-Capture Device&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/406
Keywords: video4linux, driver, video capture, capture devices,
camera driver.
Description: The title says it all.</p></li><li><p>Title: &ldquo;Video4linux Drivers, Part 2: Video-capture Devices&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/429
Keywords: video4linux, driver, video capture, capture devices,
camera driver, control, query capabilities, capability, facility.
Description: The title says it all.</p></li><li><p>Title: &ldquo;PCI Management in Linux 2.2&rdquo;
Author: Alan Cox.
URL: http://www.linux-mag.com/id/452
Keywords: PCI, bus, bus-mastering.
Description: The title says it all.</p></li><li><p>Title: &ldquo;Linux 2.4 Kernel Internals&rdquo;
Author: Tigran Aivazian and Christoph Hellwig.
URL: http://www.moses.uklinux.net/patches/lki.html
Keywords: Linux, kernel, booting, SMB boot, VFS, page cache.
Description: A little book used for a short training course.
Covers building the kernel image, booting (including SMP bootup),
process management, VFS and more.</p></li><li><p>Title: &ldquo;Linux IP Networking. A Guide to the Implementation and
Modification of the Linux Protocol Stack.&rdquo;
Author: Glenn Herrin.
URL: http://www.cs.unh.edu/cnrg/gherrin
Keywords: network, networking, protocol, IP, UDP, TCP, connection,
socket, receiving, transmitting, forwarding, routing, packets,
modules, /proc, sk_buff, FIB, tags.
Description: Excellent paper devoted to the Linux IP Networking,
explaining anything from the kernel&rsquo;s to the user space
configuration tools' code. Very good to get a general overview of
the kernel networking implementation and understand all steps
packets follow from the time they are received at the network
device till they are delivered to applications. The studied kernel
code is from 2.2.14 version. Provides code for a working packet
dropper example.</p></li><li><p>Title: &ldquo;Get those boards talking under Linux.&rdquo;
Author: Alex Ivchenko.
URL: http://www.edn.com/article/CA46968.html
Keywords: data-acquisition boards, drivers, modules, interrupts,
memory allocation.
Description: Article written for people wishing to make their data
acquisition boards work on their GNU/Linux machines. Gives a basic
overview on writing drivers, from the naming of functions to
interrupt handling.
Notes: Two-parts article. Part II is at
URL: http://www.edn.com/article/CA46998.html</p></li><li><p>Title: &ldquo;Linux PCMCIA Programmer&rsquo;s Guide&rdquo;
Author: David Hinds.
URL: http://pcmcia-cs.sourceforge.net/ftp/doc/PCMCIA-PROG.html
Keywords: PCMCIA.
Description: &ldquo;This document describes how to write kernel device
drivers for the Linux PCMCIA Card Services interface. It also
describes how to write user-mode utilities for communicating with
Card Services.</p></li><li><p>Title: &ldquo;The Linux Kernel NFSD Implementation&rdquo;
Author: Neil Brown.
URL:
http://www.cse.unsw.edu.au/~neilb/oss/linux-commentary/nfsd.html
Keywords: knfsd, nfsd, NFS, RPC, lockd, mountd, statd.
Description: The title says it all.
Notes: Covers knfsd&rsquo;s version 1.4.7 (patch against 2.2.7 kernel).</p></li><li><p>Title: &ldquo;A Linux vm README&rdquo;
Author: Kanoj Sarcar.
URL: http://kos.enix.org/pub/linux-vmm.html
Keywords: virtual memory, mm, pgd, vma, page, page flags, page
cache, swap cache, kswapd.
Description: Telegraphic, short descriptions and definitions
relating the Linux virtual memory implementation.</p></li><li><p>Title: &ldquo;(nearly) Complete Linux Loadable Kernel Modules. The
definitive guide for hackers, virus coders and system
administrators.&rdquo;
Author: pragmatic/THC.
URL: http://packetstormsecurity.org/docs/hack/LKM_HACKING.html
Keywords: syscalls, intercept, hide, abuse, symbol table.
Description: Interesting paper on how to abuse the Linux kernel in
order to intercept and modify syscalls, make
files/directories/processes invisible, become root, hijack ttys,
write kernel modules based virus&mldr; and solutions for admins to
avoid all those abuses.
Notes: For 2.0.x kernels. Gives guidances to port it to 2.2.x
kernels.</p></li></ul><p>BOOKS: (Not on-line)</p><ul><li><p>Title: &ldquo;Linux Device Drivers&rdquo;
Author: Alessandro Rubini.
Publisher: O&rsquo;Reilly & Associates.
Date: 1998.
Pages: 439.
ISBN: 1-56592-292-1</p></li><li><p>Title: &ldquo;Linux Device Drivers, 2nd Edition&rdquo;
Author: Alessandro Rubini and Jonathan Corbet.
Publisher: O&rsquo;Reilly & Associates.
Date: 2001.
Pages: 586.
ISBN: 0-59600-008-1
Notes: Further information in
http://www.oreilly.com/catalog/linuxdrive2/</p></li><li><p>Title: &ldquo;Linux Device Drivers, 3rd Edition&rdquo;
Authors: Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman
Publisher: O&rsquo;Reilly & Associates.
Date: 2005.
Pages: 636.
ISBN: 0-596-00590-3
Notes: Further information in
http://www.oreilly.com/catalog/linuxdrive3/
PDF format, URL: http://lwn.net/Kernel/LDD3/</p></li><li><p>Title: &ldquo;Linux Kernel Internals&rdquo;
Author: Michael Beck.
Publisher: Addison-Wesley.
Date: 1997.
ISBN: 0-201-33143-8 (second edition)</p></li><li><p>Title: &ldquo;The Design of the UNIX Operating System&rdquo;
Author: Maurice J. Bach.
Publisher: Prentice Hall.
Date: 1986.
Pages: 471.
ISBN: 0-13-201757-1</p></li><li><p>Title: &ldquo;The Design and Implementation of the 4.3 BSD UNIX
Operating System&rdquo;
Author: Samuel J. Leffler, Marshall Kirk McKusick, Michael J.
Karels, John S. Quarterman.
Publisher: Addison-Wesley.
Date: 1989 (reprinted with corrections on October, 1990).
ISBN: 0-201-06196-1</p></li><li><p>Title: &ldquo;The Design and Implementation of the 4.4 BSD UNIX
Operating System&rdquo;
Author: Marshall Kirk McKusick, Keith Bostic, Michael J. Karels,
John S. Quarterman.
Publisher: Addison-Wesley.
Date: 1996.
ISBN: 0-201-54979-4</p></li><li><p>Title: &ldquo;Programmation Linux 2.0 API systeme et fonctionnement du
noyau&rdquo;
Author: Remy Card, Eric Dumas, Franck Mevel.
Publisher: Eyrolles.
Date: 1997.
Pages: 520.
ISBN: 2-212-08932-5
Notes: French.</p></li><li><p>Title: &ldquo;Unix internals &ndash; the new frontiers&rdquo;
Author: Uresh Vahalia.
Publisher: Prentice Hall.
Date: 1996.
Pages: 600.
ISBN: 0-13-101908-2</p></li><li><p>Title: &ldquo;Programming for the real world - POSIX.4&rdquo;
Author: Bill O. Gallmeister.
Publisher: O&rsquo;Reilly & Associates, Inc..
Date: 1995.
Pages: ???.
ISBN: I-56592-074-0
Notes: Though not being directly about Linux, Linux aims to be
POSIX. Good reference.</p></li><li><p>Title: &ldquo;UNIX Systems for Modern Architectures: Symmetric
Multiprocessing and Caching for Kernel Programmers&rdquo;
Author: Curt Schimmel.
Publisher: Addison Wesley.
Date: June, 1994.
Pages: 432.
ISBN: 0-201-63338-8</p></li></ul><p>MISCELLANEOUS:</p><ul><li><p>Name: linux/Documentation
Author: Many.
URL: Just look inside your kernel sources.
Keywords: anything, DocBook.
Description: Documentation that comes with the kernel sources,
inside the Documentation directory. Some pages from this document
(including this document itself) have been moved there, and might
be more up to date than the web version.</p></li><li><p>Name: &ldquo;Linux Kernel Source Reference&rdquo;
Author: Thomas Graichen.
URL: http://marc.info/?l=linux-kernel&m=96446640102205&w=4
Keywords: CVS, web, cvsweb, browsing source code.
Description: Web interface to a CVS server with the kernel
sources. &ldquo;Here you can have a look at any file of the Linux kernel
sources of any version starting from 1.0 up to the (daily updated)
current version available. Also you can check the differences
between two versions of a file&rdquo;.</p></li><li><p>Name: &ldquo;Cross-Referencing Linux&rdquo;
URL: http://lxr.linux.no/source/
Keywords: Browsing source code.
Description: Another web-based Linux kernel source code browser.
Lots of cross references to variables and functions. You can see
where they are defined and where they are used.</p></li><li><p>Name: &ldquo;Linux Weekly News&rdquo;
URL: http://lwn.net
Keywords: latest kernel news.
Description: The title says it all. There&rsquo;s a fixed kernel section
summarizing developers' work, bug fixes, new features and versions
produced during the week. Published every Thursday.</p></li><li><p>Name: &ldquo;Kernel Traffic&rdquo;
URL: http://kt.earth.li/kernel-traffic/index.html
Keywords: linux-kernel mailing list, weekly kernel news.
Description: Weekly newsletter covering the most relevant
discussions of the linux-kernel mailing list.</p></li><li><p>Name: &ldquo;CuTTiNG.eDGe.LiNuX&rdquo;
URL: http://edge.kernelnotes.org
Keywords: changelist.
Description: Site which provides the changelist for every kernel
release. What&rsquo;s new, what&rsquo;s better, what&rsquo;s changed. Myrdraal reads
the patches and describes them. Pointers to the patches are there,
too.</p></li><li><p>Name: &ldquo;New linux-kernel Mailing List FAQ&rdquo;
URL: http://www.tux.org/lkml/
Keywords: linux-kernel mailing list FAQ.
Description: linux-kernel is a mailing list for developers to
communicate. This FAQ builds on the previous linux-kernel mailing
list FAQ maintained by Frohwalt Egerer, who no longer maintains
it. Read it to see how to join the mailing list. Dozens of
interesting questions regarding the list, Linux, developers (who
is &mldr;?), terms (what is&mldr;?) are answered here too. Just read it.</p></li><li><p>Name: &ldquo;Linux Virtual File System&rdquo;
Author: Peter J. Braam.
URL: http://www.coda.cs.cmu.edu/doc/talks/linuxvfs/
Keywords: slides, VFS, inode, superblock, dentry, dcache.
Description: Set of slides, presumably from a presentation on the
Linux VFS layer. Covers version 2.1.x, with dentries and the
dcache.</p></li><li><p>Name: &ldquo;Gary&rsquo;s Encyclopedia - The Linux Kernel&rdquo;
Author: Gary (I suppose&mldr;).
URL: http://slencyclopedia.berlios.de/index.html
Keywords: linux, community, everything!
Description: Gary&rsquo;s Encyclopedia exists to allow the rapid finding
of documentation and other information of interest to GNU/Linux
users. It has about 4000 links to external pages in 150 major
categories. This link is for kernel-specific links, documents,
sites&mldr; This list is now hosted by developer.Berlios.de,
but seems not to have been updated since sometime in 1999.</p></li><li><p>Name: &ldquo;The home page of Linux-MM&rdquo;
Author: The Linux-MM team.
URL: http://linux-mm.org/
Keywords: memory management, Linux-MM, mm patches, TODO, docs,
mailing list.
Description: Site devoted to Linux Memory Management development.
Memory related patches, HOWTOs, links, mm developers&mldr; Don&rsquo;t miss
it if you are interested in memory management development!</p></li><li><p>Name: &ldquo;Kernel Newbies IRC Channel&rdquo;
URL: http://www.kernelnewbies.org
Keywords: IRC, newbies, channel, asking doubts.
Description: #kernelnewbies on irc.openprojects.net. From the web
page: &ldquo;#kernelnewbies is an IRC network dedicated to the &lsquo;newbie&rsquo;
kernel hacker. The audience mostly consists of people who are
learning about the kernel, working on kernel projects or
professional kernel hackers that want to help less seasoned kernel
people. [&mldr;] #kernelnewbies is on the Open Projects IRC Network,
try irc.openprojects.net or irc.<country>.openprojects.net as your
server and then /join #kernelnewbies&rdquo;. It also hosts articles,
documents, FAQs&mldr;</p></li><li><p>Name: &ldquo;linux-kernel mailing list archives and search engines&rdquo;
URL: http://vger.kernel.org/vger-lists.html
URL: http://www.uwsg.indiana.edu/hypermail/linux/kernel/index.html
URL: http://marc.theaimsgroup.com/?l=linux-kernel
URL: http://groups.google.com/group/mlist.linux.kernel
URL: http://www.cs.helsinki.fi/linux/linux-kernel/
URL: http://www.lib.uaa.alaska.edu/linux-kernel/
Keywords: linux-kernel, archives, search.
Description: Some of the linux-kernel mailing list archivers. If
you have a better/another one, please let me know.</p></li></ul><p>[103] kernel-parameters.txt</p><p>parameters may be changed at runtime by the command
&ldquo;echo -n ${value} > /sys/module/${modulename}/parameters/${parm}&rdquo;.</p><p>内核参数可以通过上述命令进行调整，也可以在系统引导时通过grub传递内核参数。</p><p>The parameters listed in this document are only valid if certain kernel build
options were enabled and if respective hardware is present.</p><p>内核参数太多了，这里不予列出，请查看kernel-parameters.txt。</p><h1 id=mon-sep-29-101739-cst-2014>=============================================================================
Mon Sep 29 10:17:39 CST 2014 <a href=#mon-sep-29-101739-cst-2014 class=anchor aria-hidden=true>#</a></h1><p>[104] kmemcheck.txt</p><p>kmemcheck用于内核的未初始化内存的动态检测，它工作在内核态，与工作在用户态的
memcheck实现机制不同。虽然kmemcheck不如memcheck精确，但是已经足够使用的了。此外，kmemcheck会使用更多的内存，增加系统负载，仅适合用于内核的调试。</p><p>kmemcheck is a debugging feature for the Linux Kernel. More specifically, it
is a dynamic checker that detects and warns about some uses of uninitialized
memory.</p><p>Userspace programmers might be familiar with Valgrind&rsquo;s memcheck. The main
difference between memcheck and kmemcheck is that memcheck works for userspace
programs only, and kmemcheck works for the kernel only. The implementations
are of course vastly different. Because of this, kmemcheck is not as accurate
as memcheck, but it turns out to be good enough in practice to discover real
programmer errors that the compiler is not able to find through static
analysis.</p><p>Enabling kmemcheck on a kernel will probably slow it down to the extent that
the machine will not be usable for normal workloads such as e.g. an
interactive desktop. kmemcheck will also cause the kernel to use about twice
as much memory as normal. For this reason, kmemcheck is strictly a debugging
feature.</p><p>[105] kmemleak.txt</p><p>kmemleak是一个工作在内核态，用于检测内核中内存泄漏的工具，与工作态的内存泄漏检
测工具memcheck加参数&ndash;leak-check工作时效果类似。
为了加深对内存管理的理解，应该查看下这两个工具的源代码。</p><p>Kernel Memory Leak Detector</p><p>Kmemleak provides a way of detecting possible kernel memory leaks in a way
similar to a tracing garbage collector</p><p>(http://en.wikipedia.org/wiki/
Garbage_collection_%28computer_science%29#Tracing_garbage_collectors),
with the difference that the orphan objects are not freed but only reported
via /sys/kernel/debug/kmemleak. A similar method is used by the Valgrind tool
(memcheck &ndash;leak-check) to detect the memory leaks in user-space applications.</p><p>[106] kobject.txt</p><p>Everything you never wanted to know about kobjects, ksets, and ktypes</p><p>过去你不曾了解的关于kobjects\ksets\ktypes的一切。</p><p>Part of the difficulty in understanding the driver model - and the kobject
abstraction upon which it is built - is that there is no obvious starting
place. Dealing with kobjects requires understanding a few different types, all
of which make reference to each other. In an attempt to make things easier,
we&rsquo;ll take a multi-pass approach, starting with vague terms and adding detail
as we go. To that end, here are some quick definitions of some terms we will
be working with.</p><p>理解驱动模型以及在其上抽象出来的kobject的部分难点在于，没有明显的起始点。要想
理解kobjects，需要理解多种不同的类型，而这些类型都是相互不同的。为了尽可能使其
理解起来简单，我们将从头到尾讲解多遍，先讲述一些含糊的术语，然后再往其中添加相
应的细节。下面，是我们经常提到的一些常用术语的定义。</p><ul><li><p>A kobject is an object of type struct kobject. Kobjects have a name and a
reference count. A kobject also has a parent pointer (allowing objects to
be arranged into hierarchies), a specific type, and, usually, a
representation in the sysfs virtual filesystem.</p><p>一个kobject是一个kobject结构体类型。每一个kobject都有一个名字一个引用计数，
此外还具有一个指向parent指针（通过parent指针可以将多个kobject组织成不同的层
次）、特定的类型，通常，还包括一个在虚拟文件系统sysfs(/proc/sys)中的代表。</p><p>Kobjects are generally not interesting on their own; instead, they are
usually embedded within some other structure which contains the stuff the
code is really interested in.</p><p>kobjects本身是没有什么特别意义的，它们通常被嵌入在其他的结构体中，这些嵌入
了kobjects的结构体，再包含其他操作相关的数据结构，就变得有意义了。</p><p>No structure should EVER have more than one kobject embedded within it. If
it does, the reference counting for the object is sure to be messed up and
incorrect, and your code will be buggy. So do not do this.</p><p>任意一个结构体最多嵌套1个kobject，如果不这样的话，这个对象的引用计数就会出
错，代码就会出现bug，所以切忌嵌套超过1个kobject。</p></li><li><p>A ktype is the type of object that embeds a kobject. Every structure that
embeds a kobject needs a corresponding ktype. The ktype controls what
happens to the kobject when it is created and destroyed.</p><p>1个ktype是一个嵌套了kobject结构体的类型，每一个嵌套了kobject结构体的结构体
类型都需要一个相应的ktype。这个ktype在创建或销毁其嵌入的kobject时，可以对其
进行适当的操作。</p></li><li><p>A kset is a group of kobjects. These kobjects can be of the same ktype or
belong to different ktypes. The kset is the basic container type for
collections of kobjects. Ksets contain their own kobjects, but you can
safely ignore that implementation detail as the kset core code handles this
kobject automatically.</p><p>1个kset是一组kobjects。这些kobjects可以是相同的ktype类型，也可以分属不同的
ktype类型。这个kset是用于kobjects集合的一个基本的容器类型。ksets包含了它们
自己的kobjects，但是你可以简单地忽略这些细节，这是安全的，因为kset的核心代
码会自动处理kobject。</p><p>When you see a sysfs directory full of other directories, generally each of
those directories corresponds to a kobject in the same kset.</p><p>当你看到一个包含了其他目录的sysfs目录(一般为/proc/sys)的时候，通常这些目录
中的每一个都对应着相同kset中的一个kobject.</p></li></ul><p>We&rsquo;ll look at how to create and manipulate all of these types. A bottom-up
approach will be taken, so we&rsquo;ll go back to kobjects.</p><p>下面，我们将看一看如何创建和操作所有的这些类型，我们将自底向上地对其进行描述，
所以我们现回到kobjects。</p><p>Embedding kobjects</p><p>It is rare for kernel code to create a standalone kobject, with one major
exception explained below. Instead, kobjects are used to control access to a
larger, domain-specific object. To this end, kobjects will be found embedded
in other structures. If you are used to thinking of things in object-oriented
terms, kobjects can be seen as a top-level, abstract class from which other
classes are derived. A kobject implements a set of capabilities which are not
particularly useful by themselves, but which are nice to have in other
objects. The C language does not allow for the direct expression of
inheritance, so other techniques - such as structure embedding - must be used.</p><p>在内核代码中创建一个独立的kobject是很少见的，下面会介绍一种例外情况。一般地，
kobjects对象被用于控制对一个大对象、特定领域的对象。kobjects经长出现在其他结构
体中。如果你了解面向对象的相关术语、思想，kobjects可以被看作一个顶层的抽象类，
嵌套了该kobject的类则相当于kobject类的派生类。一个kobject实现了某些功能，这些
功能不是本身kobject需要的，但是如果将kobject嵌入到其他对象中之后，这些对
kobject本身来说不是特别关键的功能就变得非常有意义了。由于c语言不支持面向对象、
对象继承，因此必须通过其他手段来实现类似的继承机制，这里使用的是结构体嵌套。</p><p>(As an aside, for those familiar with the kernel linked list implementation,
this is analogous as to how &ldquo;list_head&rdquo; structs are rarely useful on their
own, but are invariably found embedded in the larger objects of interest.)</p><p>So, for example, the UIO code in drivers/uio/uio.c has a structure that
defines the memory region associated with a uio device:</p><pre><code>struct uio_map {
    struct kobject kobj;
    struct uio_mem *mem;
};
</code></pre><p>If you have a struct uio_map structure, finding its embedded kobject is just a
matter of using the kobj member. Code that works with kobjects will often
have the opposite problem, however: given a struct kobject pointer, what is
the pointer to the containing structure? You must avoid tricks (such as
assuming that the kobject is at the beginning of the structure) and, instead,
use the container_of() macro, found in &lt;linux/kernel.h>:</p><pre><code>container_of(pointer, type, member)
</code></pre><p>where:</p><ul><li>&ldquo;pointer&rdquo; is the pointer to the embedded kobject,</li><li>&ldquo;type&rdquo; is the type of the containing structure, and</li><li>&ldquo;member&rdquo; is the name of the structure field to which &ldquo;pointer&rdquo; points.</li></ul><p>The return value from container_of() is a pointer to the corresponding
container type. So, for example, a pointer &ldquo;kp&rdquo; to a struct kobject embedded
<em>within</em> a struct uio_map could be converted to a pointer to the <em>containing</em>
uio_map structure with:</p><pre><code>struct uio_map *u_map = container_of(kp, struct uio_map, kobj);
</code></pre><p>For convenience, programmers often define a simple macro for &ldquo;back-casting&rdquo;
kobject pointers to the containing type. Exactly this happens in the earlier
drivers/uio/uio.c, as you can see here:</p><pre><code>struct uio_map {
    struct kobject kobj;
    struct uio_mem *mem;
};

#define to_map(map) container_of(map, struct uio_map, kobj)
</code></pre><p>where the macro argument &ldquo;map&rdquo; is a pointer to the struct kobject in question.
That macro is subsequently invoked with:</p><pre><code>struct uio_map *map = to_map(kobj);
</code></pre><p>Initialization of kobjects</p><p>Code which creates a kobject must, of course, initialize that object. Some of
the internal fields are setup with a (mandatory) call to kobject_init():</p><pre><code>void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
</code></pre><p>The ktype is required for a kobject to be created properly, as every kobject
must have an associated kobj_type. After calling kobject_init(), to register
the kobject with sysfs, the function kobject_add() must be called:</p><pre><code>int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...);
</code></pre><p>This sets up the parent of the kobject and the name for the kobject properly.
If the kobject is to be associated with a specific kset, kobj->kset must be
assigned before calling kobject_add(). If a kset is associated with a
kobject, then the parent for the kobject can be set to NULL in the call to
kobject_add() and then the kobject&rsquo;s parent will be the kset itself.</p><p>As the name of the kobject is set when it is added to the kernel, the name of
the kobject should never be manipulated directly. If you must change the name
of the kobject, call kobject_rename():</p><pre><code>int kobject_rename(struct kobject *kobj, const char *new_name);
</code></pre><p>kobject_rename does not perform any locking or have a solid notion of what
names are valid so the caller must provide their own sanity checking and
serialization.</p><p>There is a function called kobject_set_name() but that is legacy cruft and is
being removed. If your code needs to call this function, it is incorrect and
needs to be fixed.</p><p>To properly access the name of the kobject, use the function kobject_name():</p><pre><code>const char *kobject_name(const struct kobject * kobj);
</code></pre><p>There is a helper function to both initialize and add the kobject to the
kernel at the same time, called surprisingly enough kobject_init_and_add():</p><pre><code>int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
                         struct kobject *parent, const char *fmt, ...);
</code></pre><p>The arguments are the same as the individual kobject_init() and kobject_add()
functions described above.</p><p>Uevents</p><p>After a kobject has been registered with the kobject core, you need to
announce to the world that it has been created. This can be done with a call
to kobject_uevent():</p><pre><code>int kobject_uevent(struct kobject *kobj, enum kobject_action action);
</code></pre><p>Use the KOBJ_ADD action for when the kobject is first added to the kernel.
This should be done only after any attributes or children of the kobject have
been initialized properly, as userspace will instantly start to look for them
when this call happens.</p><p>When the kobject is removed from the kernel (details on how to do that is
below), the uevent for KOBJ_REMOVE will be automatically created by the
kobject core, so the caller does not have to worry about doing that by hand.</p><p>Reference counts</p><p>One of the key functions of a kobject is to serve as a reference counter for
the object in which it is embedded. As long as references to the object exist,
the object (and the code which supports it) must continue to exist. The
low-level functions for manipulating a kobject&rsquo;s reference counts are:</p><p>kobject对象的一个关键作用就是充当嵌入它的对象的引用计数器，只要这个对象的引用
存在，这个对象就会一直存在。操作kobject引用计数的低级操作包括如下两个函数。</p><pre><code>struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);
</code></pre><p>A successful call to kobject_get() will increment the kobject&rsquo;s reference
counter and return the pointer to the kobject.</p><p>成功调用kobject_get将会增加kobject的引用技术，并返回指向kobject的指针。</p><p>When a reference is released, the call to kobject_put() will decrement the
reference count and, possibly, free the object. Note that kobject_init() sets
the reference count to one, so the code which sets up the kobject will need to
do a kobject_put() eventually to release that reference.</p><p>当一个引用被创建，kobject_put的一次成功调用将会使kobject的引用计数减1，如果减
为0，则会释放这个kobject。注意kobject_init将kobject引用计数设置为1，所以创建
kobject的相关代码最后应该调用一次kobject_put来释放这个kobject对象。</p><p>Because kobjects are dynamic, they must not be declared statically or on the
stack, but instead, always allocated dynamically. Future versions of the
kernel will contain a run-time check for kobjects that are created statically
and will warn the developer of this improper usage.</p><p>由于kobjects是根据需要动态创建的，不应该将其声明为静态的，或者在栈上创建，必须
动态分配创建在堆上。后续版本的内核将包含对kobjects的运行时检查，对于哪些静态创
建的kobjects，内核将给予警告。</p><p>If all that you want to use a kobject for is to provide a reference counter
for your structure, please use the struct kref instead; a kobject would be
overkill. For more information on how to use struct kref, please see the file
Documentation/kref.txt in the Linux kernel source tree.</p><p>如果使用kobject的目的仅仅是为某个结构体提供一个引用计数，请使用kref结构体代替
。使用kobject有点杀鸡用牛刀的味道，没有必要。关于如何使用kref，请参考linux内核
源代码树中的文档Documentation/kref.txt。</p><p>Creating &ldquo;simple&rdquo; kobjects</p><p>Sometimes all that a developer wants is a way to create a simple directory in
the sysfs hierarchy, and not have to mess with the whole complication of
ksets, show and store functions, and other details. This is the one exception
where a single kobject should be created. To create such an entry, use the
function:</p><p>有时，开发人员指向在sysfs目录中创建一个简单的目录，不需要ksets、显示和保存函数
等其他细节。这种情况下，就是我们前面提到的在内核代码中单独使用kobject的例外情
况。在sysfs中创建这样一个简单入口，使用如下函数:</p><pre><code>struct kobject *kobject_create_and_add(char *name, struct kobject *parent);
</code></pre><p>This function will create a kobject and place it in sysfs in the location
underneath the specified parent kobject. To create simple attributes
associated with this kobject, use:</p><p>这个函数创建一个kobject，并将其放置在sysfs目录中指定的parent kobject目录下面，
创建一个与该kobject相关联的简单属性，使用如下函数：</p><pre><code>int sysfs_create_file(struct kobject *kobj, struct attribute *attr);
    or
int sysfs_create_group(struct kobject *kobj, struct attribute_group *grp);
</code></pre><p>Both types of attributes used here, with a kobject that has been created with
the kobject_create_and_add(), can be of type kobj_attribute, so no special
custom attribute is needed to be created.</p><p>See the example module, samples/kobject/kobject-example.c for an
implementation of a simple kobject and attributes.</p><p>ktypes and release methods</p><p>One important thing still missing from the discussion is what happens to a
kobject when its reference count reaches zero. The code which created the
kobject generally does not know when that will happen; if it did, there would
be little point in using a kobject in the first place. Even predictable object
lifecycles become more complicated when sysfs is brought in as other portions
of the kernel can get a reference on any kobject that is registered in the
system.</p><p>还有一个非常重要的问题没有讨论，就是当kobject引用计数减为0时，该如何操作。创建
kobject的代码并不知道何时该kobject的引用计数会减为0.</p><p>The end result is that a structure protected by a kobject cannot be freed
before its reference count goes to zero. The reference count is not under the
direct control of the code which created the kobject. So that code must be
notified asynchronously whenever the last reference to one of its kobjects
goes away.</p><p>受kobject保护的结构体，只要kobject引用计数不为0，那么包含它的结构体就不应该被
释放。这个引用计数并不受创建kobject的代码的直接控制。所以当kobject引用计数被减
为0时，必须异步通知创建它的那段代码，才能让创建它的代码获知kobject引用计数为0。</p><p>Once you registered your kobject via kobject_add(), you must never use kfree()
to free it directly. The only safe way is to use kobject_put(). It is good
practice to always use kobject_put() after kobject_init() to avoid errors
creeping in.</p><p>一旦通过kobject_add注册了kobject，就不能再使用kfree直接释放包含了kobject的对象
。唯一安全的方式是调用kobject_put。为了避免忘记在创建kobject代码的最后部分调用
kobject_put（kobject_init初始引用计数为1），从而造成无法成功释放的后果，在实际
编程时，在kobject_init之后调用一次kobject_put是一个不错的方法</p><p>注：
如果init之后立即调用put不就导致引用计数为0了吗？
举个例子:
typedef struct T {
struct kobject kobj;
&mldr;.
}TT;
TT * tt = (TT *)malloc(sizeof(TT)); // kobj引用计数为0</p><pre><code>kobject *kp = 
    kobject_init(tt-&gt;kobj);            // init中初始化后kobj引用计数1
                                    // init返回指向kobj的指针，引用计数为2
kobject_put(tt-&gt;kobj);                // kobj引用计数--后，为1
如果是这样的话，那就不存在问题了。
</code></pre><p>This notification is done through a kobject&rsquo;s release() method. Usually such a
method has a form like:</p><pre><code>void my_object_release(struct kobject *kobj)
{
        struct my_object *mine = container_of(kobj, struct my_object, kobj);

        /* Perform any additional cleanup on this object, then... */
        kfree(mine);
}
</code></pre><p>这里的异步通知，是通过kobject提供的一个release方法实现，这里的通知好像通知的是
kobject自身，而不是包含它的结构体。kobject必须提供一个release方法，如上面的代
码所示，当kobject的引用计数为0时，就会调用kobject提供的release方法，在这个方法
体里面，通过前面提过的container_of方法获取嵌入该object对象的结构体的指针，然后
再调用kfree释放该结构体。</p><p>One important point cannot be overstated: every kobject must have a release()
method, and the kobject must persist (in a consistent state) until that method
is called. If these constraints are not met, the code is flawed. Note that
the kernel will warn you if you forget to provide a release() method. Do not
try to get rid of this warning by providing an &ldquo;empty&rdquo; release function; you
will be mocked mercilessly by the kobject maintainer if you attempt this.</p><p>一个在强调都不为过的重点：每一个kobject都必须拥有一个release方法。如果不提供该
方法，内核会发出警告，编程人员不应该提供一个空的release方法来避免该警告，必须
提供切实可行的代码。</p><p>Note, the name of the kobject is available in the release function, but it
must NOT be changed within this callback. Otherwise there will be a memory
leak in the kobject core, which makes people unhappy.</p><p>注意，在release函数中可以获取到kobject的名字，但是不应该在这个回调函数里面改变
它的名字，否则会造成内存泄漏。</p><p>Interestingly, the release() method is not stored in the kobject itself;
instead, it is associated with the ktype. So let us introduce struct
kobj_type:</p><p>release方法并不属于结构体kobject自身，而是与一个ktype关联起来的，现面是
kobj_type的结构体定义：</p><pre><code>struct kobj_type {
        void (*release)(struct kobject *);
        const struct sysfs_ops *sysfs_ops;
        struct attribute    **default_attrs;
};

从这个结构体定义中，我们看到它包括一个成员release，这是一个函数指针，即我
们前面提到的为每个kobject提供的release函数。
前面提及必须为每个kobject指定release函数，而release方法包含在ktype结构体里
面，这样我们就可以理解前面提及的“每个kobject都必须指定一个ktype”这个知识点
了。
</code></pre><p>This structure is used to describe a particular type of kobject (or, more
correctly, of containing object). Every kobject needs to have an associated
kobj_type structure; a pointer to that structure must be specified when you
call kobject_init() or kobject_init_and_add().</p><p>The release field in struct kobj_type is, of course, a pointer to the
release() method for this type of kobject. The other two fields (sysfs_ops
and default_attrs) control how objects of this type are represented in
sysfs; they are beyond the scope of this document.</p><p>The default_attrs pointer is a list of default attributes that will be
automatically created for any kobject that is registered with this ktype.</p><p>ksets</p><p>A kset is merely a collection of kobjects that want to be associated with each
other. There is no restriction that they be of the same ktype, but be very
careful if they are not.</p><p>kset仅仅是一系列希望相互间产生某种关联的kobjects的集合，kset并不限制其包含的
kobjects的种类是否相同。如果包含的kobjects类型如果不同的话，就要多加注意了。</p><p>A kset serves these functions:</p><p>kset提供了如下功能：</p><ul><li><p>It serves as a bag containing a group of objects. A kset can be used by
the kernel to track &ldquo;all block devices&rdquo; or &ldquo;all PCI device drivers.&rdquo;</p><p>kset可以充当一个包含了一组objects的包，可以让内核追踪所有的块设备或者所有的
pci设备。</p></li><li><p>A kset is also a subdirectory in sysfs, where the associated kobjects
with the kset can show up. Every kset contains a kobject which can be
set up to be the parent of other kobjects; the top-level directories of
the sysfs hierarchy are constructed in this way.</p><p>kset也是sysfs中的一个子目录，在这个子目录中，与当前kset对应的kobjects会被显
示出来。每个kset包含了一个比较特殊的kobject，这个kobject可以被设置成当前
kset下其他kobjects的parent。</p></li><li><p>Ksets can support the &ldquo;hotplugging&rdquo; of kobjects and influence how uevent
events are reported to user space.</p><p>ksets支持kobjects的热插拔，并且能够影响如何将uevent事件报道到用户空间。</p></li></ul><p>In object-oriented terms, &ldquo;kset&rdquo; is the top-level container class; ksets
contain their own kobject, but that kobject is managed by the kset code and
should not be manipulated by any other user.</p><p>A kset keeps its children in a standard kernel linked list. Kobjects point
back to their containing kset via their kset field. In almost all cases,
the kobjects belonging to a kset have that kset (or, strictly, its embedded
kobject) in their parent.</p><p>As a kset contains a kobject within it, it should always be dynamically
created and never declared statically or on the stack. To create a new kset
use:</p><p>前面我们提到过kobject必须被动态创建，由于kset也包含一个kobject，所以kset 也
必须被动态创建。</p><p>struct kset *kset_create_and_add(const char *name,
struct kset_uevent_ops *u,
struct kobject *parent);</p><p>When you are finished with the kset, call:
void kset_unregister(struct kset *kset);
to destroy it.</p><p>An example of using a kset can be seen in the samples/kobject/kset-example.c
file in the kernel tree.</p><p>If a kset wishes to control the uevent operations of the kobjects associated
with it, it can use the struct kset_uevent_ops to handle it:</p><p>struct kset_uevent_ops {
int (*filter)(struct kset *kset, struct kobject *kobj);
const char *(*name)(struct kset *kset, struct kobject *kobj);
int (*uevent)(struct kset *kset, struct kobject *kobj,
struct kobj_uevent_env *env);
};</p><p>The filter function allows a kset to prevent a uevent from being emitted to
userspace for a specific kobject. If the function returns 0, the uevent will
not be emitted.</p><p>The name function will be called to override the default name of the kset that
the uevent sends to userspace. By default, the name will be the same as the
kset itself, but this function, if present, can override that name.</p><p>The uevent function will be called when the uevent is about to be sent to
userspace to allow more environment variables to be added to the uevent.</p><p>One might ask how, exactly, a kobject is added to a kset, given that no
functions which perform that function have been presented. The answer is that
this task is handled by kobject_add(). When a kobject is passed to
kobject_add(), its kset member should point to the kset to which the kobject
will belong. kobject_add() will handle the rest.</p><p>If the kobject belonging to a kset has no parent kobject set, it will be added
to the kset&rsquo;s directory. Not all members of a kset do necessarily live in the
kset directory. If an explicit parent kobject is assigned before the kobject
is added, the kobject is registered with the kset, but added below the parent
kobject.</p><p>Kobject removal</p><p>After a kobject has been registered with the kobject core successfully, it
must be cleaned up when the code is finished with it. To do that, call
kobject_put(). By doing this, the kobject core will automatically clean up
all of the memory allocated by this kobject. If a KOBJ_ADD uevent has been
sent for the object, a corresponding KOBJ_REMOVE uevent will be sent, and any
other sysfs housekeeping will be handled for the caller properly.</p><p>If you need to do a two-stage delete of the kobject (say you are not allowed
to sleep when you need to destroy the object), then call kobject_del() which
will unregister the kobject from sysfs. This makes the kobject &ldquo;invisible&rdquo;,
but it is not cleaned up, and the reference count of the object is still the
same. At a later time call kobject_put() to finish the cleanup of the memory
associated with the kobject.</p><p>kobject_del() can be used to drop the reference to the parent object, if
circular references are constructed. It is valid in some cases, that a parent
objects references a child. Circular references <em>must</em> be broken with an
explicit call to kobject_del(), so that a release functions will be called,
and the objects in the former circle release each other.</p><p>Example code to copy from</p><p>For a more complete example of using ksets and kobjects properly, see the
example programs samples/kobject/{kobject-example.c,kset-example.c}, which
will be built as loadable modules if you select CONFIG_SAMPLE_KOBJECT.</p><p>[107] kprobes.txt</p><p>该文档中解释了内核调试中经常使用的三种探针kprobe\jprobe\rprobe，并解释了这几种
探针的工作原理，好好看一看。</p><p>Title : Kernel Probes (Kprobes)
Authors : Jim Keniston <a href=mailto:jkenisto@us.ibm.com>jkenisto@us.ibm.com</a>
: Prasanna S Panchamukhi <a href=mailto:prasanna.panchamukhi@gmail.com>prasanna.panchamukhi@gmail.com</a>
: Masami Hiramatsu <a href=mailto:mhiramat@redhat.com>mhiramat@redhat.com</a></p><p>CONTENTS</p><ol><li><p>Concepts: Kprobes, Jprobes, Return Probes</p></li><li><p>Architectures Supported</p></li><li><p>Configuring Kprobes</p></li><li><p>API Reference</p></li><li><p>Kprobes Features and Limitations</p></li><li><p>Probe Overhead</p></li><li><p>TODO</p></li><li><p>Kprobes Example</p></li><li><p>Jprobes Example</p></li><li><p>Kretprobes Example
Appendix A: The kprobes debugfs interface
Appendix B: The kprobes sysctl interface</p></li><li><p>Concepts: Kprobes, Jprobes, Return Probes</p></li></ol><p>Kprobes enables you to dynamically break into any kernel routine and
collect debugging and performance information non-disruptively. You
can trap at almost any kernel code address, specifying a handler
routine to be invoked when the breakpoint is hit.</p><p>There are currently three types of probes: kprobes, jprobes, and
kretprobes (also called return probes). A kprobe can be inserted
on virtually any instruction in the kernel. A jprobe is inserted at
the entry to a kernel function, and provides convenient access to the
function&rsquo;s arguments. A return probe fires when a specified function
returns.</p><p>In the typical case, Kprobes-based instrumentation is packaged as
a kernel module. The module&rsquo;s init function installs (&ldquo;registers&rdquo;)
one or more probes, and the exit function unregisters them. A
registration function such as register_kprobe() specifies where
the probe is to be inserted and what handler is to be called when
the probe is hit.</p><p>There are also register_/unregister_*probes() functions for batch
registration/unregistration of a group of *probes. These functions
can speed up unregistration process when you have to unregister
a lot of probes at once.</p><p>The next four subsections explain how the different types of
probes work and how jump optimization works. They explain certain
things that you&rsquo;ll need to know in order to make the best use of
Kprobes &ndash; e.g., the difference between a pre_handler and
a post_handler, and how to use the maxactive and nmissed fields of
a kretprobe. But if you&rsquo;re in a hurry to start using Kprobes, you
can skip ahead to section 2.</p><p>1.1 How Does a Kprobe Work?</p><p>When a kprobe is registered, Kprobes makes a copy of the probed
instruction and replaces the first byte(s) of the probed instruction
with a breakpoint instruction (e.g., int3 on i386 and x86_64).</p><p>When a CPU hits the breakpoint instruction, a trap occurs, the CPU&rsquo;s
registers are saved, and control passes to Kprobes via the
notifier_call_chain mechanism. Kprobes executes the &ldquo;pre_handler&rdquo;
associated with the kprobe, passing the handler the addresses of the
kprobe struct and the saved registers.</p><p>Next, Kprobes single-steps its copy of the probed instruction.
(It would be simpler to single-step the actual instruction in place,
but then Kprobes would have to temporarily remove the breakpoint
instruction. This would open a small time window when another CPU
could sail right past the probepoint.)</p><p>After the instruction is single-stepped, Kprobes executes the
&ldquo;post_handler,&rdquo; if any, that is associated with the kprobe.
Execution then continues with the instruction following the probepoint.</p><p>1.2 How Does a Jprobe Work?</p><p>A jprobe is implemented using a kprobe that is placed on a function&rsquo;s
entry point. It employs a simple mirroring principle to allow
seamless access to the probed function&rsquo;s arguments. The jprobe
handler routine should have the same signature (arg list and return
type) as the function being probed, and must always end by calling
the Kprobes function jprobe_return().</p><p>Here&rsquo;s how it works. When the probe is hit, Kprobes makes a copy of
the saved registers and a generous portion of the stack (see below).
Kprobes then points the saved instruction pointer at the jprobe&rsquo;s
handler routine, and returns from the trap. As a result, control
passes to the handler, which is presented with the same register and
stack contents as the probed function. When it is done, the handler
calls jprobe_return(), which traps again to restore the original stack
contents and processor state and switch to the probed function.</p><p>By convention, the callee owns its arguments, so gcc may produce code
that unexpectedly modifies that portion of the stack. This is why
Kprobes saves a copy of the stack and restores it after the jprobe
handler has run. Up to MAX_STACK_SIZE bytes are copied &ndash; e.g.,
64 bytes on i386.</p><p>Note that the probed function&rsquo;s args may be passed on the stack
or in registers. The jprobe will work in either case, so long as the
handler&rsquo;s prototype matches that of the probed function.</p><p>1.3 Return Probes</p><p>1.3.1 How Does a Return Probe Work?</p><p>When you call register_kretprobe(), Kprobes establishes a kprobe at
the entry to the function. When the probed function is called and this
probe is hit, Kprobes saves a copy of the return address, and replaces
the return address with the address of a &ldquo;trampoline.&rdquo; The trampoline
is an arbitrary piece of code &ndash; typically just a nop instruction.
At boot time, Kprobes registers a kprobe at the trampoline.</p><p>When the probed function executes its return instruction, control
passes to the trampoline and that probe is hit. Kprobes' trampoline
handler calls the user-specified return handler associated with the
kretprobe, then sets the saved instruction pointer to the saved return
address, and that&rsquo;s where execution resumes upon return from the trap.</p><p>While the probed function is executing, its return address is
stored in an object of type kretprobe_instance. Before calling
register_kretprobe(), the user sets the maxactive field of the
kretprobe struct to specify how many instances of the specified
function can be probed simultaneously. register_kretprobe()
pre-allocates the indicated number of kretprobe_instance objects.</p><p>For example, if the function is non-recursive and is called with a
spinlock held, maxactive = 1 should be enough. If the function is
non-recursive and can never relinquish the CPU (e.g., via a semaphore
or preemption), NR_CPUS should be enough. If maxactive &lt;= 0, it is
set to a default value. If CONFIG_PREEMPT is enabled, the default
is max(10, 2*NR_CPUS). Otherwise, the default is NR_CPUS.</p><p>It&rsquo;s not a disaster if you set maxactive too low; you&rsquo;ll just miss
some probes. In the kretprobe struct, the nmissed field is set to
zero when the return probe is registered, and is incremented every
time the probed function is entered but there is no kretprobe_instance
object available for establishing the return probe.</p><p>1.3.2 Kretprobe entry-handler</p><p>Kretprobes also provides an optional user-specified handler which runs
on function entry. This handler is specified by setting the entry_handler
field of the kretprobe struct. Whenever the kprobe placed by kretprobe at the
function entry is hit, the user-defined entry_handler, if any, is invoked.
If the entry_handler returns 0 (success) then a corresponding return handler
is guaranteed to be called upon function return. If the entry_handler
returns a non-zero error then Kprobes leaves the return address as is, and
the kretprobe has no further effect for that particular function instance.</p><p>Multiple entry and return handler invocations are matched using the unique
kretprobe_instance object associated with them. Additionally, a user
may also specify per return-instance private data to be part of each
kretprobe_instance object. This is especially useful when sharing private
data between corresponding user entry and return handlers. The size of each
private data object can be specified at kretprobe registration time by
setting the data_size field of the kretprobe struct. This data can be
accessed through the data field of each kretprobe_instance object.</p><p>In case probed function is entered but there is no kretprobe_instance
object available, then in addition to incrementing the nmissed count,
the user entry_handler invocation is also skipped.</p><p>1.4 How Does Jump Optimization Work?</p><p>If your kernel is built with CONFIG_OPTPROBES=y (currently this flag
is automatically set &lsquo;y&rsquo; on x86/x86-64, non-preemptive kernel) and
the &ldquo;debug.kprobes_optimization&rdquo; kernel parameter is set to 1 (see
sysctl(8)), Kprobes tries to reduce probe-hit overhead by using a jump
instruction instead of a breakpoint instruction at each probepoint.</p><p>1.4.1 Init a Kprobe</p><p>When a probe is registered, before attempting this optimization,
Kprobes inserts an ordinary, breakpoint-based kprobe at the specified
address. So, even if it&rsquo;s not possible to optimize this particular
probepoint, there&rsquo;ll be a probe there.</p><p>1.4.2 Safety Check</p><p>Before optimizing a probe, Kprobes performs the following safety checks:</p><ul><li><p>Kprobes verifies that the region that will be replaced by the jump
instruction (the &ldquo;optimized region&rdquo;) lies entirely within one function.
(A jump instruction is multiple bytes, and so may overlay multiple
instructions.)</p></li><li><p>Kprobes analyzes the entire function and verifies that there is no
jump into the optimized region. Specifically:</p><ul><li>the function contains no indirect jump;</li><li>the function contains no instruction that causes an exception (since
the fixup code triggered by the exception could jump back into the
optimized region &ndash; Kprobes checks the exception tables to verify this);
and</li><li>there is no near jump to the optimized region (other than to the first
byte).</li></ul></li><li><p>For each instruction in the optimized region, Kprobes verifies that
the instruction can be executed out of line.</p></li></ul><p>1.4.3 Preparing Detour Buffer</p><p>Next, Kprobes prepares a &ldquo;detour&rdquo; buffer, which contains the following
instruction sequence:</p><ul><li>code to push the CPU&rsquo;s registers (emulating a breakpoint trap)</li><li>a call to the trampoline code which calls user&rsquo;s probe handlers.</li><li>code to restore registers</li><li>the instructions from the optimized region</li><li>a jump back to the original execution path.</li></ul><p>1.4.4 Pre-optimization</p><p>After preparing the detour buffer, Kprobes verifies that none of the
following situations exist:</p><ul><li>The probe has either a break_handler (i.e., it&rsquo;s a jprobe) or a
post_handler.</li><li>Other instructions in the optimized region are probed.</li><li>The probe is disabled.
In any of the above cases, Kprobes won&rsquo;t start optimizing the probe.
Since these are temporary situations, Kprobes tries to start
optimizing it again if the situation is changed.</li></ul><p>If the kprobe can be optimized, Kprobes enqueues the kprobe to an
optimizing list, and kicks the kprobe-optimizer workqueue to optimize
it. If the to-be-optimized probepoint is hit before being optimized,
Kprobes returns control to the original instruction path by setting
the CPU&rsquo;s instruction pointer to the copied code in the detour buffer
&ndash; thus at least avoiding the single-step.</p><p>1.4.5 Optimization</p><p>The Kprobe-optimizer doesn&rsquo;t insert the jump instruction immediately;
rather, it calls synchronize_sched() for safety first, because it&rsquo;s
possible for a CPU to be interrupted in the middle of executing the
optimized region(*). As you know, synchronize_sched() can ensure
that all interruptions that were active when synchronize_sched()
was called are done, but only if CONFIG_PREEMPT=n. So, this version
of kprobe optimization supports only kernels with CONFIG_PREEMPT=n.(**)</p><p>After that, the Kprobe-optimizer calls stop_machine() to replace
the optimized region with a jump instruction to the detour buffer,
using text_poke_smp().</p><p>1.4.6 Unoptimization</p><p>When an optimized kprobe is unregistered, disabled, or blocked by
another kprobe, it will be unoptimized. If this happens before
the optimization is complete, the kprobe is just dequeued from the
optimized list. If the optimization has been done, the jump is
replaced with the original code (except for an int3 breakpoint in
the first byte) by using text_poke_smp().</p><p>(*)Please imagine that the 2nd instruction is interrupted and then
the optimizer replaces the 2nd instruction with the jump <em>address</em>
while the interrupt handler is running. When the interrupt
returns to original address, there is no valid instruction,
and it causes an unexpected result.</p><p>(**)This optimization-safety checking may be replaced with the
stop-machine method that ksplice uses for supporting a CONFIG_PREEMPT=y
kernel.</p><p>NOTE for geeks:
The jump optimization changes the kprobe&rsquo;s pre_handler behavior.
Without optimization, the pre_handler can change the kernel&rsquo;s execution
path by changing regs->ip and returning 1. However, when the probe
is optimized, that modification is ignored. Thus, if you want to
tweak the kernel&rsquo;s execution path, you need to suppress optimization,
using one of the following techniques:</p><ul><li>Specify an empty function for the kprobe&rsquo;s post_handler or break_handler.
or</li><li>Execute &lsquo;sysctl -w debug.kprobes_optimization=n&rsquo;</li></ul><ol start=2><li>Architectures Supported</li></ol><p>Kprobes, jprobes, and return probes are implemented on the following
architectures:</p><ul><li>i386 (Supports jump optimization)</li><li>x86_64 (AMD-64, EM64T) (Supports jump optimization)</li><li>ppc64</li><li>ia64 (Does not support probes on instruction slot1.)</li><li>sparc64 (Return probes not yet implemented.)</li><li>arm</li><li>ppc</li><li>mips</li></ul><ol start=3><li>Configuring Kprobes</li></ol><p>When configuring the kernel using make menuconfig/xconfig/oldconfig,
ensure that CONFIG_KPROBES is set to &ldquo;y&rdquo;. Under &ldquo;Instrumentation
Support&rdquo;, look for &ldquo;Kprobes&rdquo;.</p><p>So that you can load and unload Kprobes-based instrumentation modules,
make sure &ldquo;Loadable module support&rdquo; (CONFIG_MODULES) and &ldquo;Module
unloading&rdquo; (CONFIG_MODULE_UNLOAD) are set to &ldquo;y&rdquo;.</p><p>Also make sure that CONFIG_KALLSYMS and perhaps even CONFIG_KALLSYMS_ALL
are set to &ldquo;y&rdquo;, since kallsyms_lookup_name() is used by the in-kernel
kprobe address resolution code.</p><p>If you need to insert a probe in the middle of a function, you may find
it useful to &ldquo;Compile the kernel with debug info&rdquo; (CONFIG_DEBUG_INFO),
so you can use &ldquo;objdump -d -l vmlinux&rdquo; to see the source-to-object
code mapping.</p><ol start=4><li>API Reference</li></ol><p>The Kprobes API includes a &ldquo;register&rdquo; function and an &ldquo;unregister&rdquo;
function for each type of probe. The API also includes &ldquo;register_*probes&rdquo;
and &ldquo;unregister_*probes&rdquo; functions for (un)registering arrays of probes.
Here are terse, mini-man-page specifications for these functions and
the associated probe handlers that you&rsquo;ll write. See the files in the
samples/kprobes/ sub-directory for examples.</p><p>4.1 register_kprobe</p><p>#include &lt;linux/kprobes.h>
int register_kprobe(struct kprobe *kp);</p><p>Sets a breakpoint at the address kp->addr. When the breakpoint is
hit, Kprobes calls kp->pre_handler. After the probed instruction
is single-stepped, Kprobe calls kp->post_handler. If a fault
occurs during execution of kp->pre_handler or kp->post_handler,
or during single-stepping of the probed instruction, Kprobes calls
kp->fault_handler. Any or all handlers can be NULL. If kp->flags
is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled,
so, its handlers aren&rsquo;t hit until calling enable_kprobe(kp).</p><p>NOTE:</p><ol><li><p>With the introduction of the &ldquo;symbol_name&rdquo; field to struct kprobe,
the probepoint address resolution will now be taken care of by the kernel.
The following will now work:</p><pre><code> kp.symbol_name = &quot;symbol_name&quot;;
</code></pre></li></ol><p>(64-bit powerpc intricacies such as function descriptors are handled
transparently)</p><ol start=2><li><p>Use the &ldquo;offset&rdquo; field of struct kprobe if the offset into the symbol
to install a probepoint is known. This field is used to calculate the
probepoint.</p></li><li><p>Specify either the kprobe &ldquo;symbol_name&rdquo; OR the &ldquo;addr&rdquo;. If both are
specified, kprobe registration will fail with -EINVAL.</p></li><li><p>With CISC architectures (such as i386 and x86_64), the kprobes code
does not validate if the kprobe.addr is at an instruction boundary.
Use &ldquo;offset&rdquo; with caution.</p></li></ol><p>register_kprobe() returns 0 on success, or a negative errno otherwise.</p><p>User&rsquo;s pre-handler (kp->pre_handler):
#include &lt;linux/kprobes.h>
#include &lt;linux/ptrace.h>
int pre_handler(struct kprobe *p, struct pt_regs *regs);</p><p>Called with p pointing to the kprobe associated with the breakpoint,
and regs pointing to the struct containing the registers saved when
the breakpoint was hit. Return 0 here unless you&rsquo;re a Kprobes geek.</p><p>User&rsquo;s post-handler (kp->post_handler):
#include &lt;linux/kprobes.h>
#include &lt;linux/ptrace.h>
void post_handler(struct kprobe *p, struct pt_regs *regs,
unsigned long flags);</p><p>p and regs are as described for the pre_handler. flags always seems
to be zero.</p><p>User&rsquo;s fault-handler (kp->fault_handler):
#include &lt;linux/kprobes.h>
#include &lt;linux/ptrace.h>
int fault_handler(struct kprobe *p, struct pt_regs *regs, int trapnr);</p><p>p and regs are as described for the pre_handler. trapnr is the
architecture-specific trap number associated with the fault (e.g.,
on i386, 13 for a general protection fault or 14 for a page fault).
Returns 1 if it successfully handled the exception.</p><p>4.2 register_jprobe</p><p>#include &lt;linux/kprobes.h>
int register_jprobe(struct jprobe *jp)</p><p>Sets a breakpoint at the address jp->kp.addr, which must be the address
of the first instruction of a function. When the breakpoint is hit,
Kprobes runs the handler whose address is jp->entry.</p><p>The handler should have the same arg list and return type as the probed
function; and just before it returns, it must call jprobe_return().
(The handler never actually returns, since jprobe_return() returns
control to Kprobes.) If the probed function is declared asmlinkage
or anything else that affects how args are passed, the handler&rsquo;s
declaration must match.</p><p>register_jprobe() returns 0 on success, or a negative errno otherwise.</p><p>4.3 register_kretprobe</p><p>#include &lt;linux/kprobes.h>
int register_kretprobe(struct kretprobe *rp);</p><p>Establishes a return probe for the function whose address is
rp->kp.addr. When that function returns, Kprobes calls rp->handler.
You must set rp->maxactive appropriately before you call
register_kretprobe(); see &ldquo;How Does a Return Probe Work?&rdquo; for details.</p><p>register_kretprobe() returns 0 on success, or a negative errno
otherwise.</p><p>User&rsquo;s return-probe handler (rp->handler):
#include &lt;linux/kprobes.h>
#include &lt;linux/ptrace.h>
int kretprobe_handler(struct kretprobe_instance *ri, struct pt_regs *regs);</p><p>regs is as described for kprobe.pre_handler. ri points to the
kretprobe_instance object, of which the following fields may be
of interest:</p><ul><li>ret_addr: the return address</li><li>rp: points to the corresponding kretprobe object</li><li>task: points to the corresponding task struct</li><li>data: points to per return-instance private data; see &ldquo;Kretprobe
entry-handler&rdquo; for details.</li></ul><p>The regs_return_value(regs) macro provides a simple abstraction to
extract the return value from the appropriate register as defined by
the architecture&rsquo;s ABI.</p><p>The handler&rsquo;s return value is currently ignored.</p><p>4.4 unregister_*probe</p><p>#include &lt;linux/kprobes.h>
void unregister_kprobe(struct kprobe *kp);
void unregister_jprobe(struct jprobe *jp);
void unregister_kretprobe(struct kretprobe *rp);</p><p>Removes the specified probe. The unregister function can be called
at any time after the probe has been registered.</p><p>NOTE:
If the functions find an incorrect probe (ex. an unregistered probe),
they clear the addr field of the probe.</p><p>4.5 register_*probes</p><p>#include &lt;linux/kprobes.h>
int register_kprobes(struct kprobe **kps, int num);
int register_kretprobes(struct kretprobe **rps, int num);
int register_jprobes(struct jprobe **jps, int num);</p><p>Registers each of the num probes in the specified array. If any
error occurs during registration, all probes in the array, up to
the bad probe, are safely unregistered before the register_*probes
function returns.</p><ul><li>kps/rps/jps: an array of pointers to *probe data structures</li><li>num: the number of the array entries.</li></ul><p>NOTE:
You have to allocate(or define) an array of pointers and set all
of the array entries before using these functions.</p><p>4.6 unregister_*probes</p><p>#include &lt;linux/kprobes.h>
void unregister_kprobes(struct kprobe **kps, int num);
void unregister_kretprobes(struct kretprobe **rps, int num);
void unregister_jprobes(struct jprobe **jps, int num);</p><p>Removes each of the num probes in the specified array at once.</p><p>NOTE:
If the functions find some incorrect probes (ex. unregistered
probes) in the specified array, they clear the addr field of those
incorrect probes. However, other probes in the array are
unregistered correctly.</p><p>4.7 disable_*probe</p><p>#include &lt;linux/kprobes.h>
int disable_kprobe(struct kprobe *kp);
int disable_kretprobe(struct kretprobe *rp);
int disable_jprobe(struct jprobe *jp);</p><p>Temporarily disables the specified *probe. You can enable it again by using
enable_*probe(). You must specify the probe which has been registered.</p><p>4.8 enable_*probe</p><p>#include &lt;linux/kprobes.h>
int enable_kprobe(struct kprobe *kp);
int enable_kretprobe(struct kretprobe *rp);
int enable_jprobe(struct jprobe *jp);</p><p>Enables *probe which has been disabled by disable_*probe(). You must specify
the probe which has been registered.</p><ol start=5><li>Kprobes Features and Limitations</li></ol><p>Kprobes allows multiple probes at the same address. Currently,
however, there cannot be multiple jprobes on the same function at
the same time. Also, a probepoint for which there is a jprobe or
a post_handler cannot be optimized. So if you install a jprobe,
or a kprobe with a post_handler, at an optimized probepoint, the
probepoint will be unoptimized automatically.</p><p>In general, you can install a probe anywhere in the kernel.
In particular, you can probe interrupt handlers. Known exceptions
are discussed in this section.</p><p>The register_<em>probe functions will return -EINVAL if you attempt
to install a probe in the code that implements Kprobes (mostly
kernel/kprobes.c and arch/</em>/kernel/kprobes.c, but also functions such
as do_page_fault and notifier_call_chain).</p><p>If you install a probe in an inline-able function, Kprobes makes
no attempt to chase down all inline instances of the function and
install probes there. gcc may inline a function without being asked,
so keep this in mind if you&rsquo;re not seeing the probe hits you expect.</p><p>A probe handler can modify the environment of the probed function
&ndash; e.g., by modifying kernel data structures, or by modifying the
contents of the pt_regs struct (which are restored to the registers
upon return from the breakpoint). So Kprobes can be used, for example,
to install a bug fix or to inject faults for testing. Kprobes, of
course, has no way to distinguish the deliberately injected faults
from the accidental ones. Don&rsquo;t drink and probe.</p><p>Kprobes makes no attempt to prevent probe handlers from stepping on
each other &ndash; e.g., probing printk() and then calling printk() from a
probe handler. If a probe handler hits a probe, that second probe&rsquo;s
handlers won&rsquo;t be run in that instance, and the kprobe.nmissed member
of the second probe will be incremented.</p><p>As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of
the same handler) may run concurrently on different CPUs.</p><p>Kprobes does not use mutexes or allocate memory except during
registration and unregistration.</p><p>Probe handlers are run with preemption disabled. Depending on the
architecture and optimization state, handlers may also run with
interrupts disabled (e.g., kretprobe handlers and optimized kprobe
handlers run without interrupt disabled on x86/x86-64). In any case,
your handler should not yield the CPU (e.g., by attempting to acquire
a semaphore).</p><p>Since a return probe is implemented by replacing the return
address with the trampoline&rsquo;s address, stack backtraces and calls
to __builtin_return_address() will typically yield the trampoline&rsquo;s
address instead of the real return address for kretprobed functions.
(As far as we can tell, __builtin_return_address() is used only
for instrumentation and error reporting.)</p><p>If the number of times a function is called does not match the number
of times it returns, registering a return probe on that function may
produce undesirable results. In such a case, a line:
kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c
gets printed. With this information, one will be able to correlate the
exact instance of the kretprobe that caused the problem. We have the
do_exit() case covered. do_execve() and do_fork() are not an issue.
We&rsquo;re unaware of other specific cases where this could be a problem.</p><p>If, upon entry to or exit from a function, the CPU is running on
a stack other than that of the current task, registering a return
probe on that function may produce undesirable results. For this
reason, Kprobes doesn&rsquo;t support return probes (or kprobes or jprobes)
on the x86_64 version of __switch_to(); the registration functions
return -EINVAL.</p><p>On x86/x86-64, since the Jump Optimization of Kprobes modifies
instructions widely, there are some limitations to optimization. To
explain it, we introduce some terminology. Imagine a 3-instruction
sequence consisting of a two 2-byte instructions and one 3-byte
instruction.</p><pre><code>    IA
     |
</code></pre><p>[-2][-1][0][1][2][3][4][5][6][7]
[ins1][ins2][ ins3 ]
[&lt;- DCR ->]
[&lt;- JTPR ->]</p><p>ins1: 1st Instruction
ins2: 2nd Instruction
ins3: 3rd Instruction
IA: Insertion Address
JTPR: Jump Target Prohibition Region
DCR: Detoured Code Region</p><p>The instructions in DCR are copied to the out-of-line buffer
of the kprobe, because the bytes in DCR are replaced by
a 5-byte jump instruction. So there are several limitations.</p><p>a) The instructions in DCR must be relocatable.
b) The instructions in DCR must not include a call instruction.
c) JTPR must not be targeted by any jump or call instruction.
d) DCR must not straddle the border between functions.</p><p>Anyway, these limitations are checked by the in-kernel instruction
decoder, so you don&rsquo;t need to worry about that.</p><ol start=6><li>Probe Overhead</li></ol><p>On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0
microseconds to process. Specifically, a benchmark that hits the same
probepoint repeatedly, firing a simple handler each time, reports 1-2
million hits per second, depending on the architecture. A jprobe or
return-probe hit typically takes 50-75% longer than a kprobe hit.
When you have a return probe set on a function, adding a kprobe at
the entry to that function adds essentially no overhead.</p><p>Here are sample overhead figures (in usec) for different architectures.
k = kprobe; j = jprobe; r = return probe; kr = kprobe + return probe
on same function; jr = jprobe + return probe on same function</p><p>i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips
k = 0.57 usec; j = 1.00; r = 0.92; kr = 0.99; jr = 1.40</p><p>x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips
k = 0.49 usec; j = 0.76; r = 0.80; kr = 0.82; jr = 1.07</p><p>ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU)
k = 0.77 usec; j = 1.31; r = 1.26; kr = 1.45; jr = 1.99</p><p>6.1 Optimized Probe Overhead</p><p>Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to
process. Here are sample overhead figures (in usec) for x86 architectures.
k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe,
r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe.</p><p>i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33</p><p>x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30</p><ol start=7><li>TODO</li></ol><p>a. SystemTap (http://sourceware.org/systemtap): Provides a simplified
programming interface for probe-based instrumentation. Try it out.
b. Kernel return probes for sparc64.
c. Support for other architectures.
d. User-space probes.
e. Watchpoint probes (which fire on data references).</p><ol start=8><li>Kprobes Example</li></ol><p>See samples/kprobes/kprobe_example.c</p><ol start=9><li>Jprobes Example</li></ol><p>See samples/kprobes/jprobe_example.c</p><ol start=10><li>Kretprobes Example</li></ol><p>See samples/kprobes/kretprobe_example.c</p><p>For additional information on Kprobes, refer to the following URLs:
http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe
http://www.redhat.com/magazine/005mar05/features/kprobes/
http://www-users.cs.umn.edu/~boutcher/kprobes/
http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf (pages 101-115)</p><p>Appendix A: The kprobes debugfs interface</p><p>With recent kernels (> 2.6.20) the list of registered kprobes is visible
under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).</p><p>/sys/kernel/debug/kprobes/list: Lists all registered probes on the system</p><p>c015d71a k vfs_read+0x0
c011a316 j do_fork+0x0
c03dedc5 r tcp_v4_rcv+0x0</p><p>The first column provides the kernel address where the probe is inserted.
The second column identifies the type of probe (k - kprobe, r - kretprobe
and j - jprobe), while the third column specifies the symbol+offset of
the probe. If the probed function belongs to a module, the module name
is also specified. Following columns show probe status. If the probe is on
a virtual address that is no longer valid (module init sections, module
virtual addresses that correspond to modules that&rsquo;ve been unloaded),
such probes are marked with [GONE]. If the probe is temporarily disabled,
such probes are marked with [DISABLED]. If the probe is optimized, it is
marked with [OPTIMIZED].</p><p>/sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly.</p><p>Provides a knob to globally and forcibly turn registered kprobes ON or OFF.
By default, all kprobes are enabled. By echoing &ldquo;0&rdquo; to this file, all
registered probes will be disarmed, till such time a &ldquo;1&rdquo; is echoed to this
file. Note that this knob just disarms and arms all kprobes and doesn&rsquo;t
change each probe&rsquo;s disabling state. This means that disabled kprobes (marked
[DISABLED]) will be not enabled if you turn ON all kprobes by this knob.</p><p>Appendix B: The kprobes sysctl interface</p><p>/proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF.</p><p>When CONFIG_OPTPROBES=y, this sysctl interface appears and it provides
a knob to globally and forcibly turn jump optimization (see section
1.4) ON or OFF. By default, jump optimization is allowed (ON).
If you echo &ldquo;0&rdquo; to this file or set &ldquo;debug.kprobes_optimization&rdquo; to
0 via sysctl, all optimized probes will be unoptimized, and any new
probes registered after that will not be optimized. Note that this
knob <em>changes</em> the optimized state. This means that optimized probes
(marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be
removed). If the knob is turned on, they will be optimized again.</p><p>[108] kref.txt</p><p>kref可以为你自定义的结构体提供一个引用计数器，前面[106]中提到的kobject也可以实
现该功能，但是kobject比较复杂，如果只是提供一个简单的引用计数器的话，应该使用
kref而不是kobject。</p><p>krefs allow you to add reference counters to your objects. If you
have objects that are used in multiple places and passed around, and
you don&rsquo;t have refcounts, your code is almost certainly broken. If
you want refcounts, krefs are the way to go.</p><p>To use a kref, add one to your data structures like:</p><p>struct my_data
{
.
.
struct kref refcount;
.
.
};</p><p>The kref can occur anywhere within the data structure.</p><p>You must initialize the kref after you allocate it. To do this, call
kref_init as so:</p><pre><code> struct my_data *data;

 data = kmalloc(sizeof(*data), GFP_KERNEL);
 if (!data)
        return -ENOMEM;
 kref_init(&amp;data-&gt;refcount);
</code></pre><p>This sets the refcount in the kref to 1.</p><p>Once you have an initialized kref, you must follow the following
rules:</p><ol><li><p>If you make a non-temporary copy of a pointer, especially if
it can be passed to another thread of execution, you must
increment the refcount with kref_get() before passing it off:
kref_get(&data->refcount);
If you already have a valid pointer to a kref-ed structure (the
refcount cannot go to zero) you may do this without a lock.</p></li><li><p>When you are done with a pointer, you must call kref_put():
kref_put(&data->refcount, data_release);
If this is the last reference to the pointer, the release
routine will be called. If the code never tries to get
a valid pointer to a kref-ed structure without already
holding a valid pointer, it is safe to do this without
a lock.</p></li><li><p>If the code attempts to gain a reference to a kref-ed structure
without already holding a valid pointer, it must serialize access
where a kref_put() cannot occur during the kref_get(), and the
structure must remain valid during the kref_get().</p></li></ol><p>For example, if you allocate some data and then pass it to another
thread to process:</p><p>void data_release(struct kref *ref)
{
struct my_data *data = container_of(ref, struct my_data, refcount);
kfree(data);
}</p><p>void more_data_handling(void *cb_data)
{
struct my_data *data = cb_data;
.
. do stuff with data here
.
kref_put(&data->refcount, data_release);
}</p><p>int my_data_handler(void)
{
int rv = 0;
struct my_data *data;
struct task_struct *task;
data = kmalloc(sizeof(*data), GFP_KERNEL);
if (!data)
return -ENOMEM;
kref_init(&data->refcount);</p><pre><code>    kref_get(&amp;data-&gt;refcount);
    task = kthread_run(more_data_handling, data, &quot;more_data_handling&quot;);
    if (task == ERR_PTR(-ENOMEM)) {
            rv = -ENOMEM;
            goto out;
    }

    .
    . do stuff with data here
    .
</code></pre><p>out:
kref_put(&data->refcount, data_release);
return rv;
}</p><p>This way, it doesn&rsquo;t matter what order the two threads handle the
data, the kref_put() handles knowing when the data is not referenced
any more and releasing it. The kref_get() does not require a lock,
since we already have a valid pointer that we own a refcount for. The
put needs no lock because nothing tries to get the data without
already holding a pointer.</p><p>Note that the &ldquo;before&rdquo; in rule 1 is very important. You should never
do something like:</p><pre><code>    task = kthread_run(more_data_handling, data, &quot;more_data_handling&quot;);
    if (task == ERR_PTR(-ENOMEM)) {
            rv = -ENOMEM;
            goto out;
    } else
            /* BAD BAD BAD - get is after the handoff */
            kref_get(&amp;data-&gt;refcount);
</code></pre><p>Don&rsquo;t assume you know what you are doing and use the above construct.
First of all, you may not know what you are doing. Second, you may
know what you are doing (there are some situations where locking is
involved where the above may be legal) but someone else who doesn&rsquo;t
know what they are doing may change the code or copy the code. It&rsquo;s
bad style. Don&rsquo;t do it.</p><p>There are some situations where you can optimize the gets and puts.
For instance, if you are done with an object and enqueuing it for
something else or passing it off to something else, there is no reason
to do a get then a put:</p><pre><code>    /* Silly extra get and put */
    kref_get(&amp;obj-&gt;ref);
    enqueue(obj);
    kref_put(&amp;obj-&gt;ref, obj_cleanup);
</code></pre><p>Just do the enqueue. A comment about this is always welcome:</p><pre><code>    enqueue(obj);
    /* We are done with obj, so we pass our refcount off
       to the queue.  DON'T TOUCH obj AFTER HERE! */
</code></pre><p>The last rule (rule 3) is the nastiest one to handle. Say, for
instance, you have a list of items that are each kref-ed, and you wish
to get the first one. You can&rsquo;t just pull the first item off the list
and kref_get() it. That violates rule 3 because you are not already
holding a valid pointer. You must add a mutex (or some other lock).
For instance:</p><p>static DEFINE_MUTEX(mutex);
static LIST_HEAD(q);
struct my_data
{
struct kref refcount;
struct list_head link;
};</p><p>static struct my_data *get_entry()
{
struct my_data *entry = NULL;
mutex_lock(&mutex);
if (!list_empty(&q)) {
entry = container_of(q.next, struct my_data, link);
kref_get(&entry->refcount);
}
mutex_unlock(&mutex);
return entry;
}</p><p>static void release_entry(struct kref *ref)
{
struct my_data *entry = container_of(ref, struct my_data, refcount);</p><pre><code>    list_del(&amp;entry-&gt;link);
    kfree(entry);
</code></pre><p>}</p><p>static void put_entry(struct my_data *entry)
{
mutex_lock(&mutex);
kref_put(&entry->refcount, release_entry);
mutex_unlock(&mutex);
}</p><p>The kref_put() return value is useful if you do not want to hold the
lock during the whole release operation. Say you didn&rsquo;t want to call
kfree() with the lock held in the example above (since it is kind of
pointless to do so). You could use kref_put() as follows:</p><p>static void release_entry(struct kref <em>ref)
{
/</em> All work is done after the return from kref_put(). */
}</p><p>static void put_entry(struct my_data *entry)
{
mutex_lock(&mutex);
if (kref_put(&entry->refcount, release_entry)) {
list_del(&entry->link);
mutex_unlock(&mutex);
kfree(entry);
} else
mutex_unlock(&mutex);
}</p><p>This is really more useful if you have to call other routines as part
of the free operations that could take a long time or might claim the
same lock. Note that doing everything in the release routine is still
preferred as it is a little neater.</p><p>Corey Minyard <a href=mailto:minyard@acm.org>minyard@acm.org</a></p><p>A lot of this was lifted from Greg Kroah-Hartman&rsquo;s 2004 OLS paper and
presentation on krefs, which can be found at:
http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-OLS2004.pdf
and:
http://www.kroah.com/linux/talks/ols_2004_kref_talk/</p><p>[109] ldm.txt</p><h2 id=ldm---logical-disk-manager-dynamic-disks>LDM - Logical Disk Manager (Dynamic Disks) <a href=#ldm---logical-disk-manager-dynamic-disks class=anchor aria-hidden=true>#</a><a href=#ldm---logical-disk-manager-dynamic-disks class=anchor aria-hidden=true>#</a></h2><p>Originally Written by FlatCap - Richard Russon <a href=mailto:ldm@flatcap.org>ldm@flatcap.org</a>.
Last Updated by Anton Altaparmakov on 30 March 2007 for Windows Vista.</p><h2 id=overview>Overview <a href=#overview class=anchor aria-hidden=true>#</a><a href=#overview class=anchor aria-hidden=true>#</a></h2><p>Windows 2000, XP, and Vista use a new partitioning scheme. It is a complete
replacement for the MSDOS style partitions. It stores its information in a
1MiB journalled database at the end of the physical disk. The size of
partitions is limited only by disk space. The maximum number of partitions is
nearly 2000.</p><p>Any partitions created under the LDM are called &ldquo;Dynamic Disks&rdquo;. There are no
longer any primary or extended partitions. Normal MSDOS style partitions are
now known as Basic Disks.</p><p>If you wish to use Spanned, Striped, Mirrored or RAID 5 Volumes, you must use
Dynamic Disks. The journalling allows Windows to make changes to these
partitions and filesystems without the need to reboot.</p><p>Once the LDM driver has divided up the disk, you can use the MD driver to
assemble any multi-partition volumes, e.g. Stripes, RAID5.</p><p>To prevent legacy applications from repartitioning the disk, the LDM creates a
dummy MSDOS partition containing one disk-sized partition. This is what is
supported with the Linux LDM driver.</p><p>A newer approach that has been implemented with Vista is to put LDM on top of a
GPT label disk. This is not supported by the Linux LDM driver yet.</p><h2 id=example>Example <a href=#example class=anchor aria-hidden=true>#</a><a href=#example class=anchor aria-hidden=true>#</a></h2><p>Below we have a 50MiB disk, divided into seven partitions.
N.B. The missing 1MiB at the end of the disk is where the LDM database is
stored.</p><p>Device | Offset Bytes Sectors MiB | Size Bytes Sectors MiB
&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
hda | 0 0 0 | 52428800 102400 50
hda1 | 51380224 100352 49 | 1048576 2048 1
hda2 | 16384 32 0 | 6979584 13632 6
hda3 | 6995968 13664 6 | 10485760 20480 10
hda4 | 17481728 34144 16 | 4194304 8192 4
hda5 | 21676032 42336 20 | 5242880 10240 5
hda6 | 26918912 52576 25 | 10485760 20480 10
hda7 | 37404672 73056 35 | 13959168 27264 13</p><p>The LDM Database may not store the partitions in the order that they appear on
disk, but the driver will sort them.</p><p>When Linux boots, you will see something like:</p><p>hda: 102400 sectors w/32KiB Cache, CHS=50/64/32
hda: [LDM] hda1 hda2 hda3 hda4 hda5 hda6 hda7</p><h2 id=compiling-ldm-support>Compiling LDM Support <a href=#compiling-ldm-support class=anchor aria-hidden=true>#</a><a href=#compiling-ldm-support class=anchor aria-hidden=true>#</a></h2><p>To enable LDM, choose the following two options:</p><p>&ldquo;Advanced partition selection&rdquo; CONFIG_PARTITION_ADVANCED
&ldquo;Windows Logical Disk Manager (Dynamic Disk) support&rdquo; CONFIG_LDM_PARTITION</p><p>If you believe the driver isn&rsquo;t working as it should, you can enable the extra
debugging code. This will produce a LOT of output. The option is:</p><p>&ldquo;Windows LDM extra logging&rdquo; CONFIG_LDM_DEBUG</p><p>N.B. The partition code cannot be compiled as a module.</p><p>As with all the partition code, if the driver doesn&rsquo;t see signs of its type of
partition, it will pass control to another driver, so there is no harm in
enabling it.</p><p>If you have Dynamic Disks but don&rsquo;t enable the driver, then all you will see
is a dummy MSDOS partition filling the whole disk. You won&rsquo;t be able to mount
any of the volumes on the disk.</p><h2 id=booting>Booting <a href=#booting class=anchor aria-hidden=true>#</a><a href=#booting class=anchor aria-hidden=true>#</a></h2><p>If you enable LDM support, then lilo is capable of booting from any of the
discovered partitions. However, grub does not understand the LDM partitioning
and cannot boot from a Dynamic Disk.</p><h2 id=more-documentation>More Documentation <a href=#more-documentation class=anchor aria-hidden=true>#</a><a href=#more-documentation class=anchor aria-hidden=true>#</a></h2><p>There is an Overview of the LDM together with complete Technical Documentation.
It is available for download.</p><p>http://www.linux-ntfs.org/</p><p>If you have any LDM questions that aren&rsquo;t answered in the documentation, email
me.</p><p>Cheers,
FlatCap - Richard Russon
ldm@flatcap.org</p><p>[110] local_ops.txt</p><p>前面了解了x86上non-irq自旋锁的实现，理解起来没有问题！
但是现在问的是，多核cpu如何实现同步？？？可能要cpu提供支持或者内存控制器进行支
持。
有人提问过，可以参考下。
http://stackoverflow.com/questions/8188649/
in-multi-core-multi-processor-architecture-what-part-of-the-system-synchronize
http://stackoverflow.com/questions/20858260/
how-can-synchronize-data-between-differernt-cores-on-xeon-linux-how-to-use-memo</p><div class=edit-page><a href=https://github.com/hitzhangjie/myspace/blob/master/content/blog/study/2014-10-24-linux%e5%86%85%e6%a0%b8%e6%96%87%e6%a1%a3%e7%b4%a2%e5%bc%95.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div><div class="docs-navigation d-flex justify-content-between"><a href=/blog/2016-05-07-linux%E6%A1%8C%E9%9D%A2%E5%8F%91%E8%A1%8C%E7%89%88%E4%BD%93%E9%AA%8C/><div class="card my-1"><div class="card-body py-2">&larr; Linux桌面发行版分享</div></div></a><a class=ms-auto href=/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/><div class="card my-1"><div class="card-body py-2">Linux内联汇编基础 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted mt-auto"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div><div class=col-lg-8 align=right><p><font size=-1>站点构建版本：v0.2.3</font></p></div></div></div></footer><script src=/js/bootstrap.min.fdbe9b9ba88a036135318f3c721784d684ac9e3280fe282cc80d7d49f7f9c82780cd54228c1608685a230c09984300d7946fc471734d566fcebc148b65bd16db.js integrity="sha512-/b6bm6iKA2E1MY88cheE1oSsnjKA/igsyA19Sff5yCeAzVQijBYIaFojDAmYQwDXlG/EcXNNVm/OvBSLZb0W2w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.b64f1e7517e5839396950ceee4ef937fbbd3ff20aa1fdd261ce87fa457863404f35a6e5239dd57b20b37f39c2401b933deeef60af180195b16941c88f10e948d.js integrity="sha512-tk8edRflg5OWlQzu5O+Tf7vT/yCqH90mHOh/pFeGNATzWm5SOd1Xsgs385wkAbkz3u72CvGAGVsWlByI8Q6UjQ==" crossorigin=anonymous defer></script>
<script src=/main.min.f16ffd9b364013a1df84be9cd7a45c470cb48639766bf5551e05bba845fe4ab150cb6436de43609bfed9af47c23bd5e395e9a10b932fa6fb2c4ee8f6cc78d7a3.js integrity="sha512-8W/9mzZAE6HfhL6c16RcRwy0hjl2a/VVHgW7qEX+SrFQy2Q23kNgm/7Zr0fCO9XjlemhC5MvpvssTuj2zHjXow==" crossorigin=anonymous defer></script>
<script src=/index.min.ce0602c51877abe319d769aa42c9b1f1f80ab4a21ea31ba77af9584d8308ff358f1959c0a8024d3157e51a43435343c0088d49f4b63a46582bfaa2c9b954badf.js integrity="sha512-zgYCxRh3q+MZ12mqQsmx8fgKtKIeoxunevlYTYMI/zWPGVnAqAJNMVflGkNDU0PACI1J9LY6Rlgr+qLJuVS63w==" crossorigin=anonymous defer></script></body></html>