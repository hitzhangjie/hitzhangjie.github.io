<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c on</title><link>/tags/c/</link><description>Recent content in c on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 28 Jun 2022 23:08:51 +0800</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>mac/win下linux c/c++开发</title><link>/blog/2022-06-28-linux-cc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</link><pubDate>Tue, 28 Jun 2022 23:08:51 +0800</pubDate><guid>/blog/2022-06-28-linux-cc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</guid><description>问题背景 # 我们很多人主力操作系统是macOS或者Windows，用Linux作为主力操作系统的少吧，不过之前确实有连续7年多是用Fedora作为主力操作系统 :)
现在很多人开发人员使用MacBook Pro作为自己的开发机，大厂标配，我们很多后台呢，开发的程序一般最后还是要跑在Linux系统上的，尤其是c/c++开发涉及到这里的跨平台开发的问题，很多开发人员用着非常原始的方式在开发，开发体验比较差。
借这个契机，我调研了下现在比较好的一些开发方式，总结分享下。
先定一个要实现的小目标：
能基于IDE进行开发，比如VSCode; 另外，编译构建必须能够 vscode: add dockerfile to workspace # 在vscode中cmd+p，输入add dockerfile to workspace并执行，此时会选择基础镜像，如面向c++开发的基础镜像，此时会生成默认的dockerfile。 然后在dockerfile选中后点击右键，选择build image，此时就完成镜像构建了，该默认dockerfile默认是一个编译镜像，里面包含了编译构建产物。 直接运行上述镜像默认就是运行程序，运行的方式可以在docker explorer里面找到镜像，右键菜单中选择Run，或者命令行执行。 这个镜像只是用来编译构建、测试运行的，还不能满足我们开发阶段的需求，因为开发阶段需要考虑头文件、库的搜索问题。
解决思路：
至少要构建一个支持开发的镜像，如c/c++镜像； 启动这个镜像，并将当前工程以volume的形式挂在到容器中，或者在容器中clone下来这个项目。提交代码要注意随时提交； 开发通过vscode remote连接到vscode server进行开发，其实是本地vscode通过ssh连接传输vscode server软件包到容器中并安装启动； 如果开发镜像支持类似WebIDE的方式进行开发，也可以代替3这种方式，只是一些本地vscode的快捷配置等可能不是很好同步。 docker desktop: New Dev environment # Docker Desktop的这种实现方式，就是上面提到的2\3这几步的组合，基本满足我们希望实现的目标了（支持开发容器Mount local directory或者容器中Clone git repository）。
这种方式也有不足，就是假设后续有人要接手这个项目，或者有人和你协作，你怎么办呢？ 我们可以直接提交一个镜像push到registry，他只要能拉代码，又能拉镜像就基本能还原之前的开发环境。
但是我为什么非要push一个镜像上去呢（包括自定义的基础镜像、开发阶段的分享镜像）？ 如果不push镜像而docker destop默认的开发镜像调整了或者我希望定制一个统一的怎么办？
Docker Desktop创建新的开发镜像的时候有一种方式，允许指定一个基础镜像，但是这个基础镜像要push到远程registry。代码会被clone到这个 容器内部，我们就通过vscode remote进行开发即可。
尽管vscode鼓励非Linux用户尽量通过这种方式，因为fs操作更快，但是还是有点不方便，因为这数据卷相当于额外浪费一份存储，考虑到之前已经克隆过的情况下。 有没有办法既能自定义基础镜像，又能挂载本地磁盘目录为数据卷的方式来解决呢？可以，请看方式3。
vscode: Remote-Containers # vscode中Command Pallete中Remote-Containers: Add Development Container Configuration Files，执行这个我们可以为工程指定一个配置文件.</description></item><item><title>gdb调试常用操作</title><link>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sun, 28 May 2017 23:56:48 +0800</pubDate><guid>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是gdb调试的常用操作。
### execute and trace step by step help &amp;lt;topic/cmd&amp;gt; list list - : list lines before last printed list + : list lines after last printed list 3 list 3,7 list filename:3,7 list function list filename:function list *address n/ni/next : next s/si/step : next exactly rni : reverse ni, see also mozilla rr sni : reverse si, see also mozilla rr r/run start finish : finish current function bt/backtrace : look stack frame and parameters f/frame 2 : select stack frame i/info locals : show local vars p/print var/expression : print var value set var varname=value ### breakpoints display var undisplay varNum b/break lineNum/function b/break lineNum/function [if expression] delete breakpoints : delete all breakpoints delete breakpoints bpNum : delete specified breakpoint disable breakpoints bpNum enable breakpoints bpNum c/continue info breakpoints ### watchpoints x/7b baseAddress : print mem data watch varName/expression i/info watchpoints ### backtrace segmentation faults generally are caused by addresses of memory spaces.</description></item><item><title>Linux内联汇编基础</title><link>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 01 Oct 2014 00:16:34 +0800</pubDate><guid>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是阅读内核源码《Linux内核源码情景分析》时对内联汇编的一些总结。
1.full template __asm__(assembler template :output operands /* optional */ :input operands /* optional */ :list of clobbered registers /* optional */ ); 2.x86 registers eax,ebx,ecx,edx edi,esi ebp,esp eip eflags 3.linux代码中很多地方都使用了这种形式的汇编语言，嵌入汇编程序的格式如下： __asm__ __volatile__ ( asm statements : outputs : inputs : registers-modified ); asm statements是一组AT&amp;amp;T格式的汇编语言语句，每个语句一行，由\n分隔各行。所有的语句都被包裹在一对双引号内。其中使用的寄存器前面要加两个%%做前缀(%n表示参数,n:数字)；转移指令多是局部转移，因此多使用数字标号。 inputs指明程序的输入参数，每个输入参数都括在一对圆括号内，各参数用逗号分开。每个参数前加一个用双引号括起来的标志，告诉编译器把该参数装入到何处。 可用的标志有： “g”：让编译器决定如何装入它； “a”：装入到ax/eax； “b”：装入到bx/ebx； “c”：装入到cx/ecx； “d”：装入到dx/edx； “D”：装入到di/edi； “S”：装入到si/esi； “q”：a、b、c、d寄存器等； “r”：任一通用寄存器； “i”：整立即数； “I”：0-31 之间的立即数（用于32位移位指令）； “J”：0-63 之间的立即数（用于64 位移位指令）； “N”：0-255 ，之间的立即数（用于out 指令）； “n”：立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”； “p”：有效内存地址； “m”：内存变量； “o”：操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址； “V”：操作数为内存变量，但寻址方式不是偏移量类型； “,”：操作数为内存变量，但寻址方式为自动增量； “X”：操作数可以是任何类型； “f”：浮点数； “t”：第一个浮点寄存器； “u”：第二个浮点寄存器； “G”：标准的80387； % ：浮点常数,该操作数可以和下一个操作数交换位置； “=”：输出； “+”：既是输入又是输出； “&amp;amp;”：改变其值之前写,分配一个独立的寄存器,使得函数返回值和该变量不因为重复使用同一个寄存器,出现数据覆盖； “%”：与下一个操作数之间可互换； “#”：忽略其后的字符，直到逗号； “*”：当优先选择寄存器时，忽略下面的字符； “0”~“9”：指定一个操作数，它既做输入又做输出。通常用“g”； outputs指明程序的输出位置，通常是变量。每个输出变量都括在一对圆括号内，各个输出变量间用逗号隔开。每个输出变量前加一个标志，告诉编译器从何处输出。 可用的标志与输入参数用的标志相同，只是前面加“=”。如“=g”。输出操作数必须是左值，而且必须是只写的。如果一个操作数即做输出又做输 入，那么必须将它们分开：一个只写操作数，一个输入操作数。输入操作数前加一个数字限制（0~9），指出输出操作数的序号，告诉编译器它们必须在同一个物 理位置。两个操作数可以是同一个表达式，也可以是不同的表达式。 registers-modified告诉编译器程序中将要修改的寄存器。每个寄存器都用双引号括起来，并用逗号隔开。如“ax”。如果汇编程 序中引用了某个特定的硬件寄存器，就应该在此处列出这些寄存器，以告诉编译器这些寄存器的值被改变了。如果汇编程序中用某种不可预测的方式修改了内存，应 该在此处加上“memory”。这样以来，在整个汇编程序中，编译器就不会把它的值缓存在寄存器中了。 如: “cc”：你使用的指令会改变CPU的条件寄存器cc； “memory”：你使用的指令会修改内存； __volatile__是可选的，它防止编译器修改该段汇编语句（重排序、重组、删除等）。 输入参数和输出变量按顺序编号，先输出后输入，编号从0开始。程序中用编号代表输入参数和输出变量（加%做前缀）。 输入、输出、寄存器部分都可有可无。如有，顺序不能变；如无，应保留“：”，除非不引起二意性。 看一个在C语言中使用at&amp;amp;t的嵌入汇编程序的例子，c语言中的3个int变量，一般会是三个内存地址。每个操作数的长度则要根据操作系统和编译器来决定，一般32位操作系统为32位，则每个操作数占用4个字节： int i=0, j=1, k=0; __asm__ __volatile__(&amp;quot; pushl %%eax\n //asm statement movl %1, %%eax\n //asm statement addl %2, %%eax\n //asm statement movl %%eax, %0\n //.</description></item><item><title>C++核心知识点总结</title><link>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2014 08:00:00 +0800</pubDate><guid>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是C++编程里的一些知识要点。
============================================================================= Sun Sep 7 16:50:05 CST 2014 ============================================================================= 为了开启c++11的某些特性，需要在g++编译时添加参数：-std=c++0x。 c++语言里面，除了char类型被明确规定为占1个字节之外，其他的数据类型都没有指定其 具体的尺寸，这样做的原因是，在不同的编译器实现中，编译器会根据运行平台的特点， 自动为各个类型指定所占用的字节数，以使得编译后的程序能够尽可能适应运行平台。这 样做的好处是，使得编写的c++程序，不仅能够适应现在的机器结构，也能适应将来的机 器结构，实在是高明！ c++11标准中变量的初始化方式有3种，这3中初始化方式是等价的： type varname = varvalue; type varname (varvalue); type varname {varvalue}; auto varname = varvalue; 变量auto会根据初始化时初值varvalue的类新，自动指定varname的类型； decltype(varname)可以获取变量varname的类型，例如可以这样使用： newvar； 这样变量newvar与新变量oldvar是相同的类型，decltype主要是用于模板中根据模板参数 的类型创建其他相同变量。 c++中有专门的字符串类string，需要包含头文件string。 cout输出时追加endl的作用不仅仅是输出换行符，考虑一下缓冲机制就明白了，在终端中 ，缓冲一般是采用行缓冲，因此在cout中追加endl不仅输出了换行符，还进行了行缓冲， 从而确保信息被输出到cout上。 如果在通过cout输出某些信息时不在末尾追加endl，如果输出信息中没有换行符做结尾， 那么信息就不会输出到终端上，因为终端采用行缓冲，不碰到换行符或者待输出信息没有 超过缓冲区的长度，信息不会被输出到终端上。 std::cout，std是一个命名空间，c++标准库中的所有东西都包含在std这个命名空间中， cout指定了设备是输出设备，c++中常用的cin\cout\cerr就等效于c中的 stdin\stdout\stderr。 常量类型 整型常量，常用的包括十进制、八进制、十六进制，分别如123,0234,0xffff；整型常量 可以在末尾追加合适的字符表示该常量应该用什么类型进行存储： u/U表示unsigned； l/L表示long； ll/LL表示long long； 浮点常量，常用的包括float、double、long double，浮点常量的形式包括3.1415、 3.14e23，其中e表示10的多少次方，浮点常量默认是用一个double类型进行存储，也可以 在浮点常量的末尾追加字符表示使用什么类型进行存储，例如： f/F表示float类型； l/L表示long double类型； 什么都不加，即采用默认的double类型； 在c++ shell中的测试结果显示，double表示8字节，long double表示16字节，这个跟编 译器有关。 字符常量、字符串常量'x',&amp;quot;xxxxx&amp;quot;，注意一些特殊的转义字符，例如： \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \a alert (beep) \' single quote (') \&amp;quot; double quote (&amp;quot;) \?</description></item><item><title>Unix环境高级编程</title><link>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 11 Jun 2014 08:00:00 +0800</pubDate><guid>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Unix环境高级编程里的一些知识要点。
# Advanced Programming in Unix Environment ############################################################################ Mon Jun 9 09:22:41 CST 2014 ############################################################################ M1 Unix基础知识 1. man man 1)user commands 2)system calls 3)c library functions 4)devices and special files 5)file formats and conventions 6)games 7)miscellanea 8)system admistration tools and daemons 2. c return values 1)return 0, 正常结束 2)return 1-255，表示错误代码 3. 工作目录 char *getcwd(char *buf, size_t size); int chdir(char *path); 4. libc与glibc的关系 libc是泛指c库，glibc是gnu组织对libc的一种实现，是unix、linux的根基，微软也有自 己对libc的实现，叫msvcrt。 5. read system call return 0, 表示到达了文件的结尾。 6.</description></item></channel></rss>