<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on</title><link>/tags/cpp/</link><description>Recent content in cpp on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sun, 28 May 2017 23:56:48 +0800</lastBuildDate><atom:link href="/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>gdb调试常用操作</title><link>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Sun, 28 May 2017 23:56:48 +0800</pubDate><guid>/blog/2022-07-09-gdb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是gdb调试的常用操作。
### execute and trace step by step help &amp;lt;topic/cmd&amp;gt; list list - : list lines before last printed list + : list lines after last printed list 3 list 3,7 list filename:3,7 list function list filename:function list *address n/ni/next : next s/si/step : next exactly rni : reverse ni, see also mozilla rr sni : reverse si, see also mozilla rr r/run start finish : finish current function bt/backtrace : look stack frame and parameters f/frame 2 : select stack frame i/info locals : show local vars p/print var/expression : print var value set var varname=value ### breakpoints display var undisplay varNum b/break lineNum/function b/break lineNum/function [if expression] delete breakpoints : delete all breakpoints delete breakpoints bpNum : delete specified breakpoint disable breakpoints bpNum enable breakpoints bpNum c/continue info breakpoints ### watchpoints x/7b baseAddress : print mem data watch varName/expression i/info watchpoints ### backtrace segmentation faults generally are caused by addresses of memory spaces.</description></item><item><title>Linux内联汇编基础</title><link>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 01 Oct 2014 00:16:34 +0800</pubDate><guid>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是阅读内核源码《Linux内核源码情景分析》时对内联汇编的一些总结。
1.full template __asm__(assembler template :output operands /* optional */ :input operands /* optional */ :list of clobbered registers /* optional */ ); 2.x86 registers eax,ebx,ecx,edx edi,esi ebp,esp eip eflags 3.linux代码中很多地方都使用了这种形式的汇编语言，嵌入汇编程序的格式如下： __asm__ __volatile__ ( asm statements : outputs : inputs : registers-modified ); asm statements是一组AT&amp;amp;T格式的汇编语言语句，每个语句一行，由\n分隔各行。所有的语句都被包裹在一对双引号内。其中使用的寄存器前面要加两个%%做前缀(%n表示参数,n:数字)；转移指令多是局部转移，因此多使用数字标号。 inputs指明程序的输入参数，每个输入参数都括在一对圆括号内，各参数用逗号分开。每个参数前加一个用双引号括起来的标志，告诉编译器把该参数装入到何处。 可用的标志有： “g”：让编译器决定如何装入它； “a”：装入到ax/eax； “b”：装入到bx/ebx； “c”：装入到cx/ecx； “d”：装入到dx/edx； “D”：装入到di/edi； “S”：装入到si/esi； “q”：a、b、c、d寄存器等； “r”：任一通用寄存器； “i”：整立即数； “I”：0-31 之间的立即数（用于32位移位指令）； “J”：0-63 之间的立即数（用于64 位移位指令）； “N”：0-255 ，之间的立即数（用于out 指令）； “n”：立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”； “p”：有效内存地址； “m”：内存变量； “o”：操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址； “V”：操作数为内存变量，但寻址方式不是偏移量类型； “,”：操作数为内存变量，但寻址方式为自动增量； “X”：操作数可以是任何类型； “f”：浮点数； “t”：第一个浮点寄存器； “u”：第二个浮点寄存器； “G”：标准的80387； % ：浮点常数,该操作数可以和下一个操作数交换位置； “=”：输出； “+”：既是输入又是输出； “&amp;amp;”：改变其值之前写,分配一个独立的寄存器,使得函数返回值和该变量不因为重复使用同一个寄存器,出现数据覆盖； “%”：与下一个操作数之间可互换； “#”：忽略其后的字符，直到逗号； “*”：当优先选择寄存器时，忽略下面的字符； “0”~“9”：指定一个操作数，它既做输入又做输出。通常用“g”； outputs指明程序的输出位置，通常是变量。每个输出变量都括在一对圆括号内，各个输出变量间用逗号隔开。每个输出变量前加一个标志，告诉编译器从何处输出。 可用的标志与输入参数用的标志相同，只是前面加“=”。如“=g”。输出操作数必须是左值，而且必须是只写的。如果一个操作数即做输出又做输 入，那么必须将它们分开：一个只写操作数，一个输入操作数。输入操作数前加一个数字限制（0~9），指出输出操作数的序号，告诉编译器它们必须在同一个物 理位置。两个操作数可以是同一个表达式，也可以是不同的表达式。 registers-modified告诉编译器程序中将要修改的寄存器。每个寄存器都用双引号括起来，并用逗号隔开。如“ax”。如果汇编程 序中引用了某个特定的硬件寄存器，就应该在此处列出这些寄存器，以告诉编译器这些寄存器的值被改变了。如果汇编程序中用某种不可预测的方式修改了内存，应 该在此处加上“memory”。这样以来，在整个汇编程序中，编译器就不会把它的值缓存在寄存器中了。 如: “cc”：你使用的指令会改变CPU的条件寄存器cc； “memory”：你使用的指令会修改内存； __volatile__是可选的，它防止编译器修改该段汇编语句（重排序、重组、删除等）。 输入参数和输出变量按顺序编号，先输出后输入，编号从0开始。程序中用编号代表输入参数和输出变量（加%做前缀）。 输入、输出、寄存器部分都可有可无。如有，顺序不能变；如无，应保留“：”，除非不引起二意性。 看一个在C语言中使用at&amp;amp;t的嵌入汇编程序的例子，c语言中的3个int变量，一般会是三个内存地址。每个操作数的长度则要根据操作系统和编译器来决定，一般32位操作系统为32位，则每个操作数占用4个字节： int i=0, j=1, k=0; __asm__ __volatile__(&amp;quot; pushl %%eax\n //asm statement movl %1, %%eax\n //asm statement addl %2, %%eax\n //asm statement movl %%eax, %0\n //.</description></item><item><title>C++核心知识点总结</title><link>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2014 08:00:00 +0800</pubDate><guid>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是C++编程里的一些知识要点。
============================================================================= Sun Sep 7 16:50:05 CST 2014 ============================================================================= 为了开启c++11的某些特性，需要在g++编译时添加参数：-std=c++0x。 c++语言里面，除了char类型被明确规定为占1个字节之外，其他的数据类型都没有指定其 具体的尺寸，这样做的原因是，在不同的编译器实现中，编译器会根据运行平台的特点， 自动为各个类型指定所占用的字节数，以使得编译后的程序能够尽可能适应运行平台。这 样做的好处是，使得编写的c++程序，不仅能够适应现在的机器结构，也能适应将来的机 器结构，实在是高明！ c++11标准中变量的初始化方式有3种，这3中初始化方式是等价的： type varname = varvalue; type varname (varvalue); type varname {varvalue}; auto varname = varvalue; 变量auto会根据初始化时初值varvalue的类新，自动指定varname的类型； decltype(varname)可以获取变量varname的类型，例如可以这样使用： newvar； 这样变量newvar与新变量oldvar是相同的类型，decltype主要是用于模板中根据模板参数 的类型创建其他相同变量。 c++中有专门的字符串类string，需要包含头文件string。 cout输出时追加endl的作用不仅仅是输出换行符，考虑一下缓冲机制就明白了，在终端中 ，缓冲一般是采用行缓冲，因此在cout中追加endl不仅输出了换行符，还进行了行缓冲， 从而确保信息被输出到cout上。 如果在通过cout输出某些信息时不在末尾追加endl，如果输出信息中没有换行符做结尾， 那么信息就不会输出到终端上，因为终端采用行缓冲，不碰到换行符或者待输出信息没有 超过缓冲区的长度，信息不会被输出到终端上。 std::cout，std是一个命名空间，c++标准库中的所有东西都包含在std这个命名空间中， cout指定了设备是输出设备，c++中常用的cin\cout\cerr就等效于c中的 stdin\stdout\stderr。 常量类型 整型常量，常用的包括十进制、八进制、十六进制，分别如123,0234,0xffff；整型常量 可以在末尾追加合适的字符表示该常量应该用什么类型进行存储： u/U表示unsigned； l/L表示long； ll/LL表示long long； 浮点常量，常用的包括float、double、long double，浮点常量的形式包括3.1415、 3.14e23，其中e表示10的多少次方，浮点常量默认是用一个double类型进行存储，也可以 在浮点常量的末尾追加字符表示使用什么类型进行存储，例如： f/F表示float类型； l/L表示long double类型； 什么都不加，即采用默认的double类型； 在c++ shell中的测试结果显示，double表示8字节，long double表示16字节，这个跟编 译器有关。 字符常量、字符串常量'x',&amp;quot;xxxxx&amp;quot;，注意一些特殊的转义字符，例如： \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \a alert (beep) \' single quote (') \&amp;quot; double quote (&amp;quot;) \?</description></item></channel></rss>