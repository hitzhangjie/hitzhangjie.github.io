<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unix on</title><link>/tags/unix/</link><description>Recent content in unix on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 24 Oct 2014 00:10:00 +0800</lastBuildDate><atom:link href="/tags/unix/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux内核文档索引</title><link>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</link><pubDate>Fri, 24 Oct 2014 00:10:00 +0800</pubDate><guid>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。
============================================================================= Fri Sep 18 12:23:06 CST 2014 # Documentation/
[1] zorro.txt zorro bus ii\iiioZorro II is the name of the general purpose expansion bus used by the Amiga 2000 computer. The bus is mainly a buffered extension of the Motorola 68000 bus, with support for bus mastering DMA. The expansion slots use a 100-pin connector and the card form factor is the same as the IBM PC. Zorro II cards implement the Autoconfig protocol for automatic address space assignment (designed before, yet similar to, Plug and Play on the PC).</description></item><item><title>Linux内联汇编基础</title><link>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 01 Oct 2014 00:16:34 +0800</pubDate><guid>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是阅读内核源码《Linux内核源码情景分析》时对内联汇编的一些总结。
1.full template __asm__(assembler template :output operands /* optional */ :input operands /* optional */ :list of clobbered registers /* optional */ ); 2.x86 registers eax,ebx,ecx,edx edi,esi ebp,esp eip eflags 3.linux代码中很多地方都使用了这种形式的汇编语言，嵌入汇编程序的格式如下： __asm__ __volatile__ ( asm statements : outputs : inputs : registers-modified ); asm statements是一组AT&amp;amp;T格式的汇编语言语句，每个语句一行，由\n分隔各行。所有的语句都被包裹在一对双引号内。其中使用的寄存器前面要加两个%%做前缀(%n表示参数,n:数字)；转移指令多是局部转移，因此多使用数字标号。 inputs指明程序的输入参数，每个输入参数都括在一对圆括号内，各参数用逗号分开。每个参数前加一个用双引号括起来的标志，告诉编译器把该参数装入到何处。 可用的标志有： “g”：让编译器决定如何装入它； “a”：装入到ax/eax； “b”：装入到bx/ebx； “c”：装入到cx/ecx； “d”：装入到dx/edx； “D”：装入到di/edi； “S”：装入到si/esi； “q”：a、b、c、d寄存器等； “r”：任一通用寄存器； “i”：整立即数； “I”：0-31 之间的立即数（用于32位移位指令）； “J”：0-63 之间的立即数（用于64 位移位指令）； “N”：0-255 ，之间的立即数（用于out 指令）； “n”：立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”； “p”：有效内存地址； “m”：内存变量； “o”：操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址； “V”：操作数为内存变量，但寻址方式不是偏移量类型； “,”：操作数为内存变量，但寻址方式为自动增量； “X”：操作数可以是任何类型； “f”：浮点数； “t”：第一个浮点寄存器； “u”：第二个浮点寄存器； “G”：标准的80387； % ：浮点常数,该操作数可以和下一个操作数交换位置； “=”：输出； “+”：既是输入又是输出； “&amp;amp;”：改变其值之前写,分配一个独立的寄存器,使得函数返回值和该变量不因为重复使用同一个寄存器,出现数据覆盖； “%”：与下一个操作数之间可互换； “#”：忽略其后的字符，直到逗号； “*”：当优先选择寄存器时，忽略下面的字符； “0”~“9”：指定一个操作数，它既做输入又做输出。通常用“g”； outputs指明程序的输出位置，通常是变量。每个输出变量都括在一对圆括号内，各个输出变量间用逗号隔开。每个输出变量前加一个标志，告诉编译器从何处输出。 可用的标志与输入参数用的标志相同，只是前面加“=”。如“=g”。输出操作数必须是左值，而且必须是只写的。如果一个操作数即做输出又做输 入，那么必须将它们分开：一个只写操作数，一个输入操作数。输入操作数前加一个数字限制（0~9），指出输出操作数的序号，告诉编译器它们必须在同一个物 理位置。两个操作数可以是同一个表达式，也可以是不同的表达式。 registers-modified告诉编译器程序中将要修改的寄存器。每个寄存器都用双引号括起来，并用逗号隔开。如“ax”。如果汇编程 序中引用了某个特定的硬件寄存器，就应该在此处列出这些寄存器，以告诉编译器这些寄存器的值被改变了。如果汇编程序中用某种不可预测的方式修改了内存，应 该在此处加上“memory”。这样以来，在整个汇编程序中，编译器就不会把它的值缓存在寄存器中了。 如: “cc”：你使用的指令会改变CPU的条件寄存器cc； “memory”：你使用的指令会修改内存； __volatile__是可选的，它防止编译器修改该段汇编语句（重排序、重组、删除等）。 输入参数和输出变量按顺序编号，先输出后输入，编号从0开始。程序中用编号代表输入参数和输出变量（加%做前缀）。 输入、输出、寄存器部分都可有可无。如有，顺序不能变；如无，应保留“：”，除非不引起二意性。 看一个在C语言中使用at&amp;amp;t的嵌入汇编程序的例子，c语言中的3个int变量，一般会是三个内存地址。每个操作数的长度则要根据操作系统和编译器来决定，一般32位操作系统为32位，则每个操作数占用4个字节： int i=0, j=1, k=0; __asm__ __volatile__(&amp;quot; pushl %%eax\n //asm statement movl %1, %%eax\n //asm statement addl %2, %%eax\n //asm statement movl %%eax, %0\n //.</description></item><item><title>C++核心知识点总结</title><link>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2014 08:00:00 +0800</pubDate><guid>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是C++编程里的一些知识要点。
============================================================================= Sun Sep 7 16:50:05 CST 2014 ============================================================================= 为了开启c++11的某些特性，需要在g++编译时添加参数：-std=c++0x。 c++语言里面，除了char类型被明确规定为占1个字节之外，其他的数据类型都没有指定其 具体的尺寸，这样做的原因是，在不同的编译器实现中，编译器会根据运行平台的特点， 自动为各个类型指定所占用的字节数，以使得编译后的程序能够尽可能适应运行平台。这 样做的好处是，使得编写的c++程序，不仅能够适应现在的机器结构，也能适应将来的机 器结构，实在是高明！ c++11标准中变量的初始化方式有3种，这3中初始化方式是等价的： type varname = varvalue; type varname (varvalue); type varname {varvalue}; auto varname = varvalue; 变量auto会根据初始化时初值varvalue的类新，自动指定varname的类型； decltype(varname)可以获取变量varname的类型，例如可以这样使用： newvar； 这样变量newvar与新变量oldvar是相同的类型，decltype主要是用于模板中根据模板参数 的类型创建其他相同变量。 c++中有专门的字符串类string，需要包含头文件string。 cout输出时追加endl的作用不仅仅是输出换行符，考虑一下缓冲机制就明白了，在终端中 ，缓冲一般是采用行缓冲，因此在cout中追加endl不仅输出了换行符，还进行了行缓冲， 从而确保信息被输出到cout上。 如果在通过cout输出某些信息时不在末尾追加endl，如果输出信息中没有换行符做结尾， 那么信息就不会输出到终端上，因为终端采用行缓冲，不碰到换行符或者待输出信息没有 超过缓冲区的长度，信息不会被输出到终端上。 std::cout，std是一个命名空间，c++标准库中的所有东西都包含在std这个命名空间中， cout指定了设备是输出设备，c++中常用的cin\cout\cerr就等效于c中的 stdin\stdout\stderr。 常量类型 整型常量，常用的包括十进制、八进制、十六进制，分别如123,0234,0xffff；整型常量 可以在末尾追加合适的字符表示该常量应该用什么类型进行存储： u/U表示unsigned； l/L表示long； ll/LL表示long long； 浮点常量，常用的包括float、double、long double，浮点常量的形式包括3.1415、 3.14e23，其中e表示10的多少次方，浮点常量默认是用一个double类型进行存储，也可以 在浮点常量的末尾追加字符表示使用什么类型进行存储，例如： f/F表示float类型； l/L表示long double类型； 什么都不加，即采用默认的double类型； 在c++ shell中的测试结果显示，double表示8字节，long double表示16字节，这个跟编 译器有关。 字符常量、字符串常量'x',&amp;quot;xxxxx&amp;quot;，注意一些特殊的转义字符，例如： \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \a alert (beep) \' single quote (') \&amp;quot; double quote (&amp;quot;) \?</description></item><item><title>Unix环境高级编程</title><link>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 11 Jun 2014 08:00:00 +0800</pubDate><guid>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Unix环境高级编程里的一些知识要点。
# Advanced Programming in Unix Environment ############################################################################ Mon Jun 9 09:22:41 CST 2014 ############################################################################ M1 Unix基础知识 1. man man 1)user commands 2)system calls 3)c library functions 4)devices and special files 5)file formats and conventions 6)games 7)miscellanea 8)system admistration tools and daemons 2. c return values 1)return 0, 正常结束 2)return 1-255，表示错误代码 3. 工作目录 char *getcwd(char *buf, size_t size); int chdir(char *path); 4. libc与glibc的关系 libc是泛指c库，glibc是gnu组织对libc的一种实现，是unix、linux的根基，微软也有自 己对libc的实现，叫msvcrt。 5. read system call return 0, 表示到达了文件的结尾。 6.</description></item><item><title>Linux系统最佳实践 - 命令行技术</title><link>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</link><pubDate>Thu, 21 Jun 2012 08:00:00 +0800</pubDate><guid>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是《Linux系统最佳实践工具-命令行技术》里的一些知识要点。
# 《Linux系统最佳实践》学习笔记 &amp;gt; 参考书目： 《Linux 系统最佳实践工具 —— 命令行技术 》 &amp;gt; 本文撰写： 张 杰 &amp;gt; 截至日期： 2012-6-21 &amp;gt; 总结 ： &amp;gt; 这是我在学习linux过程中，对本书重点内容的一点总结。谈不上心得，只是一点总结，便于以后查阅。在理解/实践的基础上，回头看这些总结的内容会轻松许多。 &amp;gt; 如果你想从本文中获取到丁点帮助，恐怕你必须付出实践，必须肯花时间。 &amp;gt; 有句话叫做“纸上得来终觉浅，绝知此事要躬行”。如果想进步，想获得实质性的进步，必须付出实践。 &amp;gt; linux系统的强大之处不在于它的桌面环境，可能linux现在众多的发行版本中没有任何一款可以与微软抗衡。也许你觉得linux很酷，是的，它的确很酷。 &amp;gt; 它给予了你无穷尽的自由，从内核到桌面，每一个使用linux的人都从中尝到了甜头。但是说真的，linux的“酷”不是靠桌面打下的口碑，这是我们都深知的。 &amp;gt; 当你学习过linux的命令行之后，也许，你才会大彻大悟，linux真是非一般的强悍。而这是windows望尘莫及的。 &amp;gt; 如果你渴望自由，如果你渴望高效，如果…… &amp;gt; 欢迎你加入linux大家庭中来！ # 第一章 Linux简介 ## 1.查看内核版本 uname -r，主版本号/次版本号/修订次数/编译次数 # 第二章 Linux文件系统及其相关处理命令 ## 1.file system - /:文件系统根目录 - /bin:最小系统所需要的命令，其中的文件都是可执行的 - /boot:包含一些启动文件 - /dev:接口设备文件目录 - /etc:系统配置文件所在目录,Editable Text Configuration - /home:用户的主目录 - /lib:库文件目录，例如在执行/bin，/sbin目录下的二进制命令文件时可能会调用的库文件 - /mnt:各项装置的文件系统挂载点，如/mnt/cdrom是光驱的挂载点 - /opt:可以在这里安装自定义软件包（较大的且固定的） - /proc:系统运行时，进程信息以及内核信息（cpu/disk/memory等）都存放在这里。它是一个伪文件系统，存在于内存中，而非硬盘中，通过这个虚拟的文件系统可以在系统运行时调整内核参数，改变内核行为。不用重新启动查看cmos，即可查看系统信息。 - /root:管理员的主目录 - /sbin:目录sbin下的程序都是root权限才可以执行的 - /tmp:存放暂存盘的目录 - /usr:这是系统存放程序的目录，比如命令/配置文件等。当我们安装一个linux发行版提供提供的软件包时，大多安装在这里。这个目录下包含字体文件目录/usr/share/fonts,帮助目录/usr/share/man,/usr/share/doc，普通用户可执行目录/usr/bin,/usr/local/bin,/usr/X11R6/bin,超级用户可执行命令目录/usr/sbin,usr/X11R6/sbin,/usr/local/sbin等。还包含程序的头文件目录/usr/include。 ## 2.</description></item><item><title>Linux系统使用杂谈 - 经验技巧</title><link>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 01 Jan 2012 10:25:37 +0800</pubDate><guid>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是日常使用Linux发行版过程中遇到的问题及解决办法。
/* vim: set ft=text: */ ############################################################################## config codeblocks for wxwidgets if you want to compile and link wxwidgets project,do as following: compiler and debugger--&amp;gt;compiler settings--&amp;gt;other options: add `wx-config --cflags` compiler and debugger--&amp;gt;linker settings--&amp;gt;other options: add `wx-config --libs` note: if you want to build normal c/c++ project rather than wxwidgets projects, you must remove `wx-config --cflags` and `wx-config --libs`. a better choice is to set the target project's properties including compiler and linker options where you can set `wx-config --cflags` and `wx-config --libs`.</description></item></channel></rss>