<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.919d32897099d0335611840e8de8126598e04dec08600b11dc58a2217f4a8223a0719340de3efeedf96217230bed172fe5d3b4dc7b9b6b5065e74c49a2539323.css integrity="sha512-kZ0yiXCZ0DNWEYQOjegSZZjgTewIYAsR3FiiIX9KgiOgcZNA3j7+7fliFyML7Rcv5dO03Huba1Bl50xJolOTIw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>eBPF原理及实践：什么是eBPF - MySpace</title><meta name=description content="eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。本文先介绍下ebpf是什么，也是作者学习过程中的一点总结。"><link rel=canonical href=/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="eBPF原理及实践：什么是eBPF"><meta property="og:description" content="eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。本文先介绍下ebpf是什么，也是作者学习过程中的一点总结。"><meta property="og:url" content="/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/"><meta property="og:site_name" content="MySpace"><meta property="article:published_time" content="2023-09-15T11:57:13+08:00"><meta property="article:modified_time" content="2023-09-15T11:57:13+08:00"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="MySpace"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@hitzhangjie"><meta name=twitter:creator content="@hitzhangjie"><meta name=twitter:title content="eBPF原理及实践：什么是eBPF"><meta name=twitter:description content="eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。本文先介绍下ebpf是什么，也是作者学习过程中的一点总结。"><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="eBPF原理及实践：什么是eBPF"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":["https://twitter.com/hitzhangjie","https://www.linkedin.com/in/hitzhangjie/","https://github.com/hitzhangjie"],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"MySpace","description":"MySpace is a hitzhangjie\u0027s personal space, for blogs, books, journey, thinkings.","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/","url":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/","name":"eBPF原理及实践：什么是eBPF","description":"eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。本文先介绍下ebpf是什么，也是作者学习过程中的一点总结。","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2023-09-15T11:57:13CET","dateModified":"2023-09-15T11:57:13CET","breadcrumb":{"@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/"]}]},{"@type":"BreadcrumbList","@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/blog2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"eBPF原理及实践：什么是eBPF","description":"eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。本文先介绍下ebpf是什么，也是作者学习过程中的一点总结。","isPartOf":{"@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/"},"mainEntityOfPage":{"@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/"},"datePublished":"2023-09-15T11:57:13CET","dateModified":"2023-09-15T11:57:13CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/person/1"},"image":{"@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/2023-09-15-ebpf%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%E4%BB%80%E4%B9%88%E6%98%AFebpf/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"eBPF原理及实践：什么是eBPF"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=607868a58d7101001829a8df&product=sop" async></script><style>[alt~=sharing]{border:0;box-shadow:none}div#st-1{text-align:unset}div#st-1 .st-btn{height:24px;padding:0 4px}div#st-1 .st-btn>img{top:4.2px}div#st-2 .st-btn{height:24px;padding:0 4px}div#st-2 .st-btn>img{top:4.2px}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-168027530-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-168027530-1')</script></head><body class="blog single d-flex flex-column min-vh-100"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=MySpace>MySpace</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>MySpace</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/books/>Books</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/landscape>Landscape</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://twitter.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-lg-none">Twitter</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Tag List</h3><ol><li><a href=/tags/ebpf/>ebpf</a></li></ol></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#ebpf的前身bpf>eBPF的前身：bpf</a></li><li><a href=#从bpf到ebpf>从BPF到eBPF</a></li><li><a href=#ebpf到生产系统>eBPF到生产系统</a></li><li><a href=#起名有点难>起名有点难</a></li><li><a href=#ebpf诞生崛起的原因>eBPF诞生崛起的原因</a></li><li><a href=#关心点内核系统调用>关心点：内核系统调用</a></li><li><a href=#困难点内核增加功能>困难点：内核增加功能</a></li><li><a href=#困难点内核模块扩展>困难点：内核模块扩展</a></li><li><a href=#优势ebpf程序动态加载>优势：eBPF程序动态加载</a></li><li><a href=#优势ebpf程序的高性能>优势：eBPF程序的高性能</a></li><li><a href=#优势云原生领域>优势：云原生领域</a></li><li><a href=#本文小结>本文小结</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>eBPF原理及实践：什么是eBPF</h1><p><small>Posted 2023-09-15 11:57 +0800 by <a class="stretched-link position-relative" href>ZhangJie</a>&nbsp;&dash;&nbsp;<strong>1&nbsp;min read</strong></small><p><div style=display:flex><div>分享:&nbsp;&nbsp;</div><div><div class=sharethis-inline-share-buttons></div></div></div><hr><p class=lead></p><p>eBPF是一项革命性的内核技术，它允许开发人员编写自定义的代码，然后被内核动态加载后执行，以此来改变内核的执行行为。它的这个特点能够帮助实现高性能网络、更好的可观测性、更细致的安全分析工具。</p><h2 id=ebpf的前身bpf>eBPF的前身：bpf <a href=#ebpf%e7%9a%84%e5%89%8d%e8%ba%abbpf class=anchor aria-hidden=true>#</a><a href=#ebpf的前身bpf class=anchor aria-hidden=true>#</a></h2><p>1、eBPF的前身是bpf（BSD Packet Filter），最早它在1993年论文中有Lawrence Berkeley National Laboratory的Steven McCanne和Van Jacobson提出，它是一种类似字节码虚拟机的东西，有自己的指令集，你可以通过它来编写程序然后交给这个小的虚拟机去执行，这个指令集非常像汇编。比如你可以用它来写包过滤的逻辑（接受或者拒绝一个网络分组）。在这篇论文中可以找到其他一些更加复杂的示例程序，论文名：The BSD Packet Filter: A New Architecture for User-level Packet Capture。</p><p>2、1997年，Linux内核版本2.1.75首次引入了BPF，BPF也就开始成为了Berkeley Packet Filter的简称，主要用在tcpdump这些工具中来实现高效的网络包的跟踪。</p><p>3、时间快进到2012年，Linux内核版本3.5中引入了seccomp-bpf，它能够控制是否允许用户态应用程序执行系统调用，举个例子，我们启动一个docker容器，如果不添加特殊的选项控制，在docker容器内部去调试程序的时候是执行不了的，因为Linux系统中程序调试需要利用系统调用ptrace，但是ptrace往往都是被默认不允许的，发挥作用的就是seccomp-bpf，这里有一篇文章介绍了seccomp+ptrace调试原理的文章：https://zhuanlan.zhihu.com/p/606317619。seccomp-bpf是首次开始将bpf从包过滤这个范畴开始向其他范畴扩展。到今天发展到eBPF这个阶段，其实与最早的“包过滤”已经没有多大关系了。</p><h2 id=从bpf到ebpf>从BPF到eBPF <a href=#%e4%bb%8ebpf%e5%88%b0ebpf class=anchor aria-hidden=true>#</a><a href=#从bpf到ebpf class=anchor aria-hidden=true>#</a></h2><p>随着BPF在Linux内核中的演进，到了2014年，从版本3.18开始可以使用eBPF将来称呼这项技术，全程就是extended BPF，这包含了几个比较明显的改变：</p><ul><li>BPF指令级对64位机器做了高度的优化，解释器也基本上重写了；</li><li>eBPF中增加了maps，BPF程序执行时可以访问它记录一些数据，这些数据可以在BPF程序间共享，也可以允许用户态程序访问它获取结果；</li><li>增加了bpf()系统调用，用户态程序通过它可以和eBPF程序进行交互，比如加载到内核、从内核卸载、访问maps数据等；</li><li>增加了bpf_这样的一些helper函数；</li><li>增加了eBPF程序验证器，验证安全的程序才可以被执行；</li></ul><p>这是eBPF首次正式放出，但是不是结束，此后就开始了它的快速发展之路。</p><h2 id=ebpf到生产系统>eBPF到生产系统 <a href=#ebpf%e5%88%b0%e7%94%9f%e4%ba%a7%e7%b3%bb%e7%bb%9f class=anchor aria-hidden=true>#</a><a href=#ebpf到生产系统 class=anchor aria-hidden=true>#</a></h2><p>这里介绍下eBPF技术演进过程中的一些关键事件：</p><ul><li>2005年Linux中就引入了特性kprobe，它允许在任意指令地址处设置trap，当执行到此处时允许回调用户自定义的函数。开发人员可以编写内核模块，将其中的函数设置为kprobe的回调以执行调试。
ps: 调试器一般也是使用这种指令patch的方式，区别在于kprobe回调函数是内核处理的，而调试器tracee执行时触发断点是内核通过信号通知tracer由tracer来执行的。</li><li>2015年的时候允许将eBPF程序连接到kprobe，kprobe可以回调eBPF程序了，这使得在Linux中tracing变得简单，为了更好的追踪Linux内核网络栈的各类事件，Linux中开始增加各种hooks允许eBPF程序进行更细致的观测。</li><li>2016年，Netflix的工程师Gregg大佬公开了他和团队在eBPF基础上的大量性能观测工具及实践，让基础设施、运维领域认识到了eBPF在这方面的巨大潜力。</li><li>2017年，Facebook开源了Katran这个基于eBPF的高性能L4负载均衡器，也是这一年，Liz Rice这位女强人对此也产生了浓厚的兴趣，并开始研究。
ps: Liz Rice 经常做些技术方面的分享，目前是 the chief open source officer with eBPF specialists at Isovalent, 也是 the Cilium cloud native networking, security and observability project 的创建者.</li><li>2018年，Netflix、Meta的几个工程师为Linux eBPF做了大量贡献，使得eBPF成为了Linux内核的一个独立子系统，同年BTF（bpf type format）成为了ebpf的格式类型，使得ebpf程序更加兼容。</li><li>2020年，Linux内核支持了LSM BPF允许将eBPF程序和Linux安全模型LSM（Linux Security Model）连接起来，这意味着eBPF的用途又进一步清晰了、扩大了，就是安全工具、网络、可观测性。</li><li>近些年，更是有越来越多的项目诞生，cilium、aya等等，很多开发者都对此做出了贡献，业界的实践也越来越多、越来越成熟。</li></ul><h2 id=起名有点难>起名有点难 <a href=#%e8%b5%b7%e5%90%8d%e6%9c%89%e7%82%b9%e9%9a%be class=anchor aria-hidden=true>#</a><a href=#起名有点难 class=anchor aria-hidden=true>#</a></h2><p>到现在的话，ebpf中的字母e已经没有太大意义了，它已经不仅仅是对bpf的扩展了，它成为了一个独立的子系统。现在提起ebpf的时候，有些人也会用bpf来称呼。但是在Linux内核中，包括操作ebpf程序的系统调用bpf()以及相关的helper函数bpf_xxx，都是直接以bpf来称呼的，这说明Linux内核开发人员已经认可了bpf来代指ebpf，它的含义已经变了，直接代指这个子系统了。但是在Linux内核社区外，还有些人会使用ebpf来称呼，比如ebpf.io这类站点。</p><h2 id=ebpf诞生崛起的原因>eBPF诞生崛起的原因 <a href=#ebpf%e8%af%9e%e7%94%9f%e5%b4%9b%e8%b5%b7%e7%9a%84%e5%8e%9f%e5%9b%a0 class=anchor aria-hidden=true>#</a><a href=#ebpf诞生崛起的原因 class=anchor aria-hidden=true>#</a></h2><p>前面的介绍，让大家知道了ebpf演进过程中的一些关键事件，不禁要问为什么它会诞生？或者说它有哪些优点？</p><h2 id=关心点内核系统调用>关心点：内核系统调用 <a href=#%e5%85%b3%e5%bf%83%e7%82%b9%e5%86%85%e6%a0%b8%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 class=anchor aria-hidden=true>#</a><a href=#关心点内核系统调用 class=anchor aria-hidden=true>#</a></h2><p>大家对Linux内核可能比较陌生，但是对操作系统应该不陌生，毕竟大学都学过。用户程序在执行某些操作时，离不开操作系统的支持，操作系统充当的就是用户程序、硬件之间的一个服务人员，用户程序和服务人员之间传话的窗口就是syscall（系统调用）。</p><p>通常用户程序，并不会直接使用系统调用，或者说直接调用的场景比较少，大家一般是通过标准库或者其他库函数的方式来间接使用系统调用。以golang为例，所有网络层面的系统调用都被封装到了标准库net中。</p><p>系统调用，比大家的认识可能要复杂些，它包括阻塞性系统调用、非阻塞性系统调用，不同系统调用对程序执行的影响是不一样的，所以go为什么是一门工程化很好的语言，就是它在运行时层面屏蔽了这些，即使某个线程因为系统调用阻塞了，程序还可以继续跑。</p><p>因为系统调用如此重要，开发人员会想知道程序中到底在执行哪些系统调用，此时就会借助strace之类的一些工具来跟踪、统计系统调用的执行情况，这样我们能更好了解程序的执行情况。</p><h2 id=困难点内核增加功能>困难点：内核增加功能 <a href=#%e5%9b%b0%e9%9a%be%e7%82%b9%e5%86%85%e6%a0%b8%e5%a2%9e%e5%8a%a0%e5%8a%9f%e8%83%bd class=anchor aria-hidden=true>#</a><a href=#困难点内核增加功能 class=anchor aria-hidden=true>#</a></h2><p>Linux内核的代码规模已经达到了3kw+了，相当大的规模了，如果自己不是Linux内核开发人员或者说对感兴趣的模块不是不熟悉，你很难去修改它的。即使你修改了还要考虑另一个问题，你可能只解决了在你这个情景下、平台下的问题，但是Linux内核是一个通用操作系统，意味着我们的修改可能不一定能解决其他情景、平台下的问题。往往你修改个东西，要经过社区、Torvalds的同意才行，这个周期会非常常。根据统计，Linux内核社区贡献的所有patches也就只有1/3能够进入主线。</p><p>即使进入了这个主线，可能已经过去一段时间了，你还要考虑发行版的问题，因为我们大部分开发人员、企业使用的都是某个发行版，发行版使用的内核版本又不一样了，什么时候主线代码被发行版使用了发布了，你才能考虑升级机器上的操作系统。这里就又过去一段时间了。</p><p>也就是说，即使你发现内核代码有缺陷，或者想做功能扩展，即使你很有能力开发内核代码（大部分开发估计并不擅长还是需要多年沉淀才行），即使被合入主线、被发行版使用、机器也顺利升级了，但是时间不等人，这种方式满足不了需求方快速变化的需要。</p><h2 id=困难点内核模块扩展>困难点：内核模块扩展 <a href=#%e5%9b%b0%e9%9a%be%e7%82%b9%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e6%89%a9%e5%b1%95 class=anchor aria-hidden=true>#</a><a href=#困难点内核模块扩展 class=anchor aria-hidden=true>#</a></h2><p>内核开发人员可以考虑通过内核模块的方式（但是开发内核模块也比较困难），来代替直接修改内核代码贡献到上游这个方式，这个路子更敏捷更快，时间成本大大缩短。</p><p>内核模块也可以动态加载、卸载，不需要升级系统时停止机器。</p><p>但是内核模块的安全性一直是大家比较担心的：</p><ul><li>它运行在特权用户级别，</li><li>这个模块经过大家充分CR吗，有漏洞吗，会给攻击吗</li><li>这个作者值得信任吗</li><li>这个模块万一有bug会影响到整机稳定性吗</li></ul><p>大家对于内核模块的使用慎之又慎，eBPF通过验证器来尽可能保证字节码程序的安全性，至少不会影响到内核本身的健壮性。又可以独立开发的方式来增强内核功能、快速响应需求变化，相比之下就有很大的吸引力。</p><h2 id=优势ebpf程序动态加载>优势：eBPF程序动态加载 <a href=#%e4%bc%98%e5%8a%bfebpf%e7%a8%8b%e5%ba%8f%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd class=anchor aria-hidden=true>#</a><a href=#优势ebpf程序动态加载 class=anchor aria-hidden=true>#</a></h2><p>ebpf程序支持动态加载、移除，不需要升级内核来获得要扩展的特性，也不需要重启机器来应用这些特性，这对于进行性能方面的观测、实现并应用安全工具就非常好。</p><h2 id=优势ebpf程序的高性能>优势：eBPF程序的高性能 <a href=#%e4%bc%98%e5%8a%bfebpf%e7%a8%8b%e5%ba%8f%e7%9a%84%e9%ab%98%e6%80%a7%e8%83%bd class=anchor aria-hidden=true>#</a><a href=#优势ebpf程序的高性能 class=anchor aria-hidden=true>#</a></h2><p>ebpf程序（可能用c写、用rust写），写完的ebpf程序会被编译器编译为target为ebpf的字节码程序，被ebpf子系统加载后会被JIT（即时编译器）编译为机器指令，执行的是机器指令。</p><p>ebpf程序最终执行时，可以最小化用户态、内核态的频繁切换、减少上下文切换的开销，数据记录在ebpf maps，用户程序要获取数据就从ebpf maps中取。</p><p>所以ebpf程序的性能是比较高的。</p><h2 id=优势云原生领域>优势：云原生领域 <a href=#%e4%bc%98%e5%8a%bf%e4%ba%91%e5%8e%9f%e7%94%9f%e9%a2%86%e5%9f%9f class=anchor aria-hidden=true>#</a><a href=#优势云原生领域 class=anchor aria-hidden=true>#</a></h2><p>在云原生领域，ebpf这种对业务代码无侵入、无需编排配置的方式，使得它在可观测性等方面具有很大的优势。</p><p>之前大伙也是一般通过sidecar（边车）模式来增强pod的功能，比如logging、trcacing等，servicemesh也会通过sidecar实现network的能力，sidecar有它的灵活性和优势，但是也有它的局限性：</p><ul><li>添加sidecar时，要使其生效（如果一开始忘了加），pod必须整个重启；</li><li>需要修改k8s的编排配置的yaml来增加这个sidecar，尽管这个过程功过鼠标勾勾点点就可以、配置是自动化的，但是如果不小心勾选错误还是不会被织入这个sidecar；</li><li>pod内如果有多个容器，有可能是需要指定启动顺序的，否则可能会发生竞态条件或者故障发生，这样的话也意味着pod启动更慢；</li><li>servicemesh中通过sidecar来实现network的功能，所有的网络流量都需要经过一个pod中网络代理容器的中转，这增加了传输延迟，影响网络性能；</li></ul><p>这些问题也确实是sidecar模式的一些问题，幸运的是ebpf作为一种平台能力，就可以比较好的解决这些问题。</p><h2 id=本文小结>本文小结 <a href=#%e6%9c%ac%e6%96%87%e5%b0%8f%e7%bb%93 class=anchor aria-hidden=true>#</a><a href=#本文小结 class=anchor aria-hidden=true>#</a></h2><p>这里介绍了什么是ebpf，包括它的前身、演进的一些关键过程，以及相对于传统的方式，当我们希望做些可观测性、内核功能增强、缺陷修复时相比修改主线内核、写内核模块所具有的一些优势。然后，如果能将ebpf作为一种平台能力进行建设，这将使得在可观测性、安全工具、网络性能优化方面做出一些比较大的效果，不管你的机器是裸金属机器、虚拟机，还是容器化应用，它都能统统搞定，而且不需要你侵入业务代码、部署配置也不需要重启机器、pod。</p><div class=edit-page><a href=https://github.com/hitzhangjie/myspace/blob/master/content/blog/ebpf/2023-09-15-eBPF%e5%8e%9f%e7%90%86%e5%8f%8a%e5%ae%9e%e8%b7%b5%ef%bc%9a%e4%bb%80%e4%b9%88%e6%98%afebpf.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div><div class="docs-navigation d-flex justify-content-between"><a href=/blog/2023-09-15-ebpf_bcc%E6%A1%86%E6%9E%B6helloworld/><div class="card my-1"><div class="card-body py-2">&larr; eBPF BCC框架：helloworld</div></div></a><a class=ms-auto href=/blog/2023-09-08-linux%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A560s/><div class="card my-1"><div class="card-body py-2">Linux性能问题排查60s &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted mt-auto"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div><div class=col-lg-8 align=right><p><font size=-1>站点构建版本：v0.2.3</font></p></div></div></div></footer><script src=/js/bootstrap.min.fdbe9b9ba88a036135318f3c721784d684ac9e3280fe282cc80d7d49f7f9c82780cd54228c1608685a230c09984300d7946fc471734d566fcebc148b65bd16db.js integrity="sha512-/b6bm6iKA2E1MY88cheE1oSsnjKA/igsyA19Sff5yCeAzVQijBYIaFojDAmYQwDXlG/EcXNNVm/OvBSLZb0W2w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.b64f1e7517e5839396950ceee4ef937fbbd3ff20aa1fdd261ce87fa457863404f35a6e5239dd57b20b37f39c2401b933deeef60af180195b16941c88f10e948d.js integrity="sha512-tk8edRflg5OWlQzu5O+Tf7vT/yCqH90mHOh/pFeGNATzWm5SOd1Xsgs385wkAbkz3u72CvGAGVsWlByI8Q6UjQ==" crossorigin=anonymous defer></script>
<script src=/main.min.f16ffd9b364013a1df84be9cd7a45c470cb48639766bf5551e05bba845fe4ab150cb6436de43609bfed9af47c23bd5e395e9a10b932fa6fb2c4ee8f6cc78d7a3.js integrity="sha512-8W/9mzZAE6HfhL6c16RcRwy0hjl2a/VVHgW7qEX+SrFQy2Q23kNgm/7Zr0fCO9XjlemhC5MvpvssTuj2zHjXow==" crossorigin=anonymous defer></script>
<script src=/index.min.a03b720b3d89559b9659fc304bdb3399b1767a4879b0caac94de2ba2be0b2c726d0eb64a3dee16141123409f2a5612d617b57e999d32bfa9a2e5d894cb417fca.js integrity="sha512-oDtyCz2JVZuWWfwwS9szmbF2ekh5sMqslN4ror4LLHJtDrZKPe4WFBEjQJ8qVhLWF7V+mZ0yv6mi5diUy0F/yg==" crossorigin=anonymous defer></script></body></html>