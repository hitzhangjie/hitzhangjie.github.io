<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>varint on</title><link>/tags/varint/</link><description>Recent content in varint on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 09 Feb 2017 15:11:38 +0800</lastBuildDate><atom:link href="/tags/varint/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf编解码</title><link>/blog/2017-02-09-protobuf%E7%BC%96%E8%A7%A3%E7%A0%81/</link><pubDate>Thu, 09 Feb 2017 15:11:38 +0800</pubDate><guid>/blog/2017-02-09-protobuf%E7%BC%96%E8%A7%A3%E7%A0%81/</guid><description>img { width: 680px; padding-bottom: 1rem; } 开发过程中学习学习的一点protobuf编解码的知识，以及对遇到的一些编解码相关问题的总结。
1.pb数据类型 # protobuf对message进行编码时，是将message中的各个成员按照key、value组合成一个字节流，这里的key并不是属性的名字，而是varint(tag&amp;laquo;3 | datatype)，其低3位表示字段类型，类型描述见下图。
当protobuf对一个字节流进行解码的时候，对于那些它不认识的字段会直接跳过，对字节流反串行化操作的代码主要是依赖于各个Message子类的MergePartialFromCodedStream方法实现，常用的ParseFromString或者ParseFromArray方法最终都是调用该方法来完成反串行化任务。MergePartialFromCodedStream方法中包括了对unknown tag的处理，这部分代码都是protoc自动插入的，所以每个Message子类的对未知tag的处理方式也是一样的，下面通过一个简单的proto文件进行说明。
文件名：T.proto
package kn.feeds; enum FeedType { TYPE_RECORD_LIVE = 1; TYPE_RECORD_VIDEO = 2; //TYPE_RECORD_DAYMOMENT = 3; }; message Feed { optional string name = 1; optional int32 time = 2; optional FeedType type = 3; }; 使用protobuf --cpp_out=. T.proto进行处理，生成的T.pb.cc中kn::feeds::Feed::MergePartialFromCodedStream方法的源码如下图所示，其中对不相关代码进行了折叠。switch(....GetFieldNumber(tag))获取到了tag的编号并进行分别处理，如果是一个unknown tag则进入default处理分支，一般情况下是执行DO_(&amp;hellip;)将这个unknown tag保存到一个unknown_fields vector中。
文件名：T.pb.cc，见下图：
如果新需求中要求改造旧有的pb协议，例如在message中新追加了一些字段，旧代码在进行反串行化的时候并不会读取到新追加的字段，协议改造对旧有服务是不会产生不良影响的。
另外，大家一般习惯于使用optional对字段进行修饰，这里就optional字段值是否设置对数据传输的影响也进行一下说明：
对于message中定义的optional类型的字段field，A给B发消息时，如果A没有显示设置field的值，那么B收到的字节流里面不会包括field字段的信息，B会自动使用proto文件中定义的该字段的默认值。 而当A显示设置字段field的值与默认值相同时，传输给B的字节流里面会包括field字段的信息。设置和不设置optional字段对于串行化数据的编码、传输是不同的。 PS：对于pb2而言，上述描述是正确的。对于pb3的情况，对编码及网络传输数据量又进行了优化，所有的0值都不会在编码时进行编码。如果系统中涉及到pb2、pb3共用，且存在使用pb2的代码中通过判断字段值是否为nil来做特殊逻辑，这里就容易引入问题。而如果全部是pb3协议则不需要考虑这种兼容问题。
2.varint &amp;amp; zigzag编解码 # 前面列出了protobuf数据类型编码规则，当tag低3位为0时表示varint类型，对于有符号类型、无符号类型其实差别还是挺大的。</description></item></channel></rss>