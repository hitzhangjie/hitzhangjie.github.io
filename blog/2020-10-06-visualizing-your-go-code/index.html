<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.9993c28e78e2b97295168fcf849d2f51737e9ec4a7ebb3269cb03931f3b82608f15850b40b5e7193a6e4b55ee97ddd832e74adfef5efc824274693480cf308f4.css integrity="sha512-mZPCjnjiuXKVFo/PhJ0vUXN+nsSn67MmnLA5MfO4JgjxWFC0C15xk6bktV7pfd2DLnSt/vXvyCQnRpNIDPMI9A==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Visualizing Your Go Code - MySpace</title><meta name=description content="代码可读性 # 作为一名开发人员，代码可读性是我们常常挂在嘴边的。代码写出来除了让计算机能够正常执行以外，终究还是要让人能够理解它，后续才能做进一步的维护工作。如果代码写出来，只有它的作者能够看得懂，那只能说明这个作者逻辑表达能力有问题，透过其代码难以看出解决问题的思路。这是软件工程中要尽力避免的。
在软件工程方法论指导下，为了尽可能让代码可读性达标，我们往往会根据一些最佳实践拟定一些大多数人认可的标准，让所有开发人员遵守，然后通过代码评审、代码规范检查、持续集成交付流水线等综合起来，以尽可能逼近这一目标。当绝大多数人能够在约定的框架下，保质保量提交代码时，我们已经在代码可读性、可维护性方面前进了一大步。
然而，这样足够了吗？我认为还不够。
代码是思维的表达 # 代码，不过是通过一种大家都理解的语言书写出来的篇章。就好比写文章一样，要有中心思想，然后围绕中心思想要展开层层描述。写代码一样，中心思想就是我们要解决的问题，围绕中心思想的层层描述就是我们解决问题的思路。所以，代码没有什么神秘的，它是人类思维的表达。
我们是如何快速理解一篇文章的呢？
 先看标题，掌握其核心关键词； 看下第一段落的内容，往往第一段会引出问题； 看下其余段落的首句、末句，往往会给出该段落的中心思想； 看下最后一段的内容，一般会给出一个结论； 通篇串下，了解文章整体含义；  为什么我们会通过这种方式？因为一篇好的文章一定有承上启下、过渡。这种循序渐进的方式，步步逼近中心思想。
那代码呢？某种程度上，代码也是类似的。
 以go语言为例，通常对于一个package，我们会提供package注释来表示当前package要解决的问题； 每个package内部又包含了不同的types、variables、functions，它们结合起来来解决一个问题； 每一个function内部又分为多个步骤，每一步完成一个小功能，为下一步做好准备； 每一个小功能、步骤可能是if-else, switch-case, for-loop……之类的语言结构； 同时，我们还会提供测试用例，来验证上述方案的正确性。  有没有觉得很相似，或许我们应该采用已有的读书的经验来辅助更好地理解程序？
OOP思想认识世界 # 代码，和文章不同的是，它虽然有明显的程序构造，但是却没有明显的段落之分。
那我如何才能借鉴多年来养成的还不错的阅读习惯，来帮助我理解代码呢？当然不能盲目套用，不过俗话说，能工摹形，巧匠窃意，思想很多地方还是可以相通的。
如何更好地理解这个世界，对各种各样的问题进行抽象呢？比如一辆摩托车，它有离合器、发动机、链条、轮毂、轮胎、减震、油箱、排气等很多部件构成，我听说宝马水鸟电子控制很厉害，可以实现无人驾驶，那可是两轮的400多斤的大机器。那它的电子控制系统怎么做到的？至少要能理解一个摩托车有核心部件，整体运转起来如何理解其状态，如何控制个别部件以影响其他部件进而控制整体状态。那它如何控制部件呢？电子操作或机械操作。
扯远了，我只是有点喜欢水鸟而已。整个世界可以看做是一个个对象及其之间的联系所构成，代码也不例外。
道法自然，OOP的思想不过是借鉴了人类认识世界的方式，将其运用到了软件工程领域，以更好地对问题进行抽象，从而构建出设计更合理的软件。那代码里面有哪些语言构造体现了OOP的思想呢。
 类型与对象，生物学里区分物种、种群、个体，那是因为它们既有共性，也有个性； 通信的方式，自然界个体之间的交互也有多种方式，比如雄狮撒泡尿标记领地也不管入侵者认不认同，或者低吼驱赶入侵者离开，人和人用听得懂的语言沟通； 隐私与距离，每个人都有自己的隐私，如果你的朋友跟你借100块钱你可能给了，但是他如果问是你老婆给的还是你自己的，你可能就不想借给他了，给你就行了你管那么多干嘛呢，我还不想拿自家的借你呢，说不定借你老婆的给你的呢。每个人在一副外表下总有些不愿意被人触碰、靠近的地方。  了解一个人，其实你不需要深入他的家庭本身去了解，看看他天天接触什么人，说些什么话，你也就大致清楚了。感兴趣就继续了解，不感兴趣也就拉倒了。我想绝大多数人都不是窥视狂，在拥有一定判断力的基础上，通过一些局部的信息是可以了解大致的整体信息的。
理解代码有相同之处？
流程控制 + 组件交互 # 某种程度上，我认为理解代码也有相似之处。
如果能够拎出那些比较重要的对象（objects），以及他们之间的通信（function call, chan send/recv），或者他们的私密信息（注释），是不是也能够大致有个了解呢？
如果想更深入了解下，加上事情的脉络（控制结构，if-else, switch-case, for-loop）呢？
其他信息? 我相信还有其他有用的有用信息，能够通过一些更加有效率的方式呈现出来。
认识 go/ast # 计算机编程语言，有多少种？我认为只有一种，就是人类可以理解的语言。有趣的是，编程语言之多可以覆盖元素周期表，不信来瞧瞧。
       语言是什么？语言有精确的数学定义，它不是胡编乱造，尤其是编程语言； 编程语言更精确？那倒未必，人类社会多姿多彩之处，就在于会演绎出更加丰富多彩的内容，包括对语言的破坏性“创造”，人脑纠错能力太强了，我们甚至没有察觉到自己犯了错误，如网上津津乐道的山东人倒装玩法； 我能发明一门语言吗？当然，只要你能给出严谨的数学定义，没有歧义，找到一群人学会并开始用它交流，姑且可以称为语言了，比如生活大爆炸谢耳朵他老婆； 语言不是主谓宾之类的吗？主谓宾也可以进一步形式化，数学之美也让我感到惊叹；  So&amp;hellip;假如我用编程语言写了一段代码，如何知道我有没有犯错误呢？那就是编译器的工作，词法分析、语法分析、语义分析，一切OK之后会进入中间代码生成、代码优化、生成最终代码。通常一般在语法分析会构建语法分析树AST（Abstract Syntax Tree），如果能够正常构建出AST，表示代码是按照语言对应生成规则来写的，就没什么大问题，反之则可能又自我“发挥”犯错了。"><link rel=canonical href=/blog/2020-10-06-visualizing-your-go-code/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Visualizing Your Go Code"><meta property="og:description" content="代码可读性 # 作为一名开发人员，代码可读性是我们常常挂在嘴边的。代码写出来除了让计算机能够正常执行以外，终究还是要让人能够理解它，后续才能做进一步的维护工作。如果代码写出来，只有它的作者能够看得懂，那只能说明这个作者逻辑表达能力有问题，透过其代码难以看出解决问题的思路。这是软件工程中要尽力避免的。
在软件工程方法论指导下，为了尽可能让代码可读性达标，我们往往会根据一些最佳实践拟定一些大多数人认可的标准，让所有开发人员遵守，然后通过代码评审、代码规范检查、持续集成交付流水线等综合起来，以尽可能逼近这一目标。当绝大多数人能够在约定的框架下，保质保量提交代码时，我们已经在代码可读性、可维护性方面前进了一大步。
然而，这样足够了吗？我认为还不够。
代码是思维的表达 # 代码，不过是通过一种大家都理解的语言书写出来的篇章。就好比写文章一样，要有中心思想，然后围绕中心思想要展开层层描述。写代码一样，中心思想就是我们要解决的问题，围绕中心思想的层层描述就是我们解决问题的思路。所以，代码没有什么神秘的，它是人类思维的表达。
我们是如何快速理解一篇文章的呢？
 先看标题，掌握其核心关键词； 看下第一段落的内容，往往第一段会引出问题； 看下其余段落的首句、末句，往往会给出该段落的中心思想； 看下最后一段的内容，一般会给出一个结论； 通篇串下，了解文章整体含义；  为什么我们会通过这种方式？因为一篇好的文章一定有承上启下、过渡。这种循序渐进的方式，步步逼近中心思想。
那代码呢？某种程度上，代码也是类似的。
 以go语言为例，通常对于一个package，我们会提供package注释来表示当前package要解决的问题； 每个package内部又包含了不同的types、variables、functions，它们结合起来来解决一个问题； 每一个function内部又分为多个步骤，每一步完成一个小功能，为下一步做好准备； 每一个小功能、步骤可能是if-else, switch-case, for-loop……之类的语言结构； 同时，我们还会提供测试用例，来验证上述方案的正确性。  有没有觉得很相似，或许我们应该采用已有的读书的经验来辅助更好地理解程序？
OOP思想认识世界 # 代码，和文章不同的是，它虽然有明显的程序构造，但是却没有明显的段落之分。
那我如何才能借鉴多年来养成的还不错的阅读习惯，来帮助我理解代码呢？当然不能盲目套用，不过俗话说，能工摹形，巧匠窃意，思想很多地方还是可以相通的。
如何更好地理解这个世界，对各种各样的问题进行抽象呢？比如一辆摩托车，它有离合器、发动机、链条、轮毂、轮胎、减震、油箱、排气等很多部件构成，我听说宝马水鸟电子控制很厉害，可以实现无人驾驶，那可是两轮的400多斤的大机器。那它的电子控制系统怎么做到的？至少要能理解一个摩托车有核心部件，整体运转起来如何理解其状态，如何控制个别部件以影响其他部件进而控制整体状态。那它如何控制部件呢？电子操作或机械操作。
扯远了，我只是有点喜欢水鸟而已。整个世界可以看做是一个个对象及其之间的联系所构成，代码也不例外。
道法自然，OOP的思想不过是借鉴了人类认识世界的方式，将其运用到了软件工程领域，以更好地对问题进行抽象，从而构建出设计更合理的软件。那代码里面有哪些语言构造体现了OOP的思想呢。
 类型与对象，生物学里区分物种、种群、个体，那是因为它们既有共性，也有个性； 通信的方式，自然界个体之间的交互也有多种方式，比如雄狮撒泡尿标记领地也不管入侵者认不认同，或者低吼驱赶入侵者离开，人和人用听得懂的语言沟通； 隐私与距离，每个人都有自己的隐私，如果你的朋友跟你借100块钱你可能给了，但是他如果问是你老婆给的还是你自己的，你可能就不想借给他了，给你就行了你管那么多干嘛呢，我还不想拿自家的借你呢，说不定借你老婆的给你的呢。每个人在一副外表下总有些不愿意被人触碰、靠近的地方。  了解一个人，其实你不需要深入他的家庭本身去了解，看看他天天接触什么人，说些什么话，你也就大致清楚了。感兴趣就继续了解，不感兴趣也就拉倒了。我想绝大多数人都不是窥视狂，在拥有一定判断力的基础上，通过一些局部的信息是可以了解大致的整体信息的。
理解代码有相同之处？
流程控制 + 组件交互 # 某种程度上，我认为理解代码也有相似之处。
如果能够拎出那些比较重要的对象（objects），以及他们之间的通信（function call, chan send/recv），或者他们的私密信息（注释），是不是也能够大致有个了解呢？
如果想更深入了解下，加上事情的脉络（控制结构，if-else, switch-case, for-loop）呢？
其他信息? 我相信还有其他有用的有用信息，能够通过一些更加有效率的方式呈现出来。
认识 go/ast # 计算机编程语言，有多少种？我认为只有一种，就是人类可以理解的语言。有趣的是，编程语言之多可以覆盖元素周期表，不信来瞧瞧。
       语言是什么？语言有精确的数学定义，它不是胡编乱造，尤其是编程语言； 编程语言更精确？那倒未必，人类社会多姿多彩之处，就在于会演绎出更加丰富多彩的内容，包括对语言的破坏性“创造”，人脑纠错能力太强了，我们甚至没有察觉到自己犯了错误，如网上津津乐道的山东人倒装玩法； 我能发明一门语言吗？当然，只要你能给出严谨的数学定义，没有歧义，找到一群人学会并开始用它交流，姑且可以称为语言了，比如生活大爆炸谢耳朵他老婆； 语言不是主谓宾之类的吗？主谓宾也可以进一步形式化，数学之美也让我感到惊叹；  So&mldr;假如我用编程语言写了一段代码，如何知道我有没有犯错误呢？那就是编译器的工作，词法分析、语法分析、语义分析，一切OK之后会进入中间代码生成、代码优化、生成最终代码。通常一般在语法分析会构建语法分析树AST（Abstract Syntax Tree），如果能够正常构建出AST，表示代码是按照语言对应生成规则来写的，就没什么大问题，反之则可能又自我“发挥”犯错了。"><meta property="og:url" content="/blog/2020-10-06-visualizing-your-go-code/"><meta property="og:site_name" content="MySpace"><meta property="article:published_time" content="2020-10-06T23:13:52+08:00"><meta property="article:modified_time" content="2020-10-06T23:13:52+08:00"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="MySpace"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@hitzhangjie"><meta name=twitter:creator content="@hitzhangjie"><meta name=twitter:title content="Visualizing Your Go Code"><meta name=twitter:description content><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="Visualizing Your Go Code"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":["https://twitter.com/hitzhangjie","https://www.linkedin.com/in/hitzhangjie/","https://github.com/hitzhangjie"],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"MySpace","description":"MySpace is a hitzhangjie\u0027s personal space, for blogs, books, journey, thinkings.","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/blog/2020-10-06-visualizing-your-go-code/","url":"/blog/2020-10-06-visualizing-your-go-code/","name":"Visualizing Your Go Code","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2020-10-06T23:13:52CET","dateModified":"2020-10-06T23:13:52CET","breadcrumb":{"@id":"/blog/2020-10-06-visualizing-your-go-code/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/2020-10-06-visualizing-your-go-code/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/blog/2020-10-06-visualizing-your-go-code/"]}]},{"@type":"BreadcrumbList","@id":"/blog/2020-10-06-visualizing-your-go-code/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/blog2020-10-06-visualizing-your-go-code/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"Visualizing Your Go Code","description":"","isPartOf":{"@id":"/blog/2020-10-06-visualizing-your-go-code/"},"mainEntityOfPage":{"@id":"/blog/2020-10-06-visualizing-your-go-code/"},"datePublished":"2020-10-06T23:13:52CET","dateModified":"2020-10-06T23:13:52CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/person/1"},"image":{"@id":"/blog/2020-10-06-visualizing-your-go-code/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/2020-10-06-visualizing-your-go-code/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"Visualizing Your Go Code"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=607868a58d7101001829a8df&product=sop" async></script><style>[alt~=sharing]{border:0;box-shadow:none}div#st-1{text-align:unset}div#st-1 .st-btn{height:24px;padding:0 4px}div#st-1 .st-btn>img{top:4.2px}div#st-2 .st-btn{height:24px;padding:0 4px}div#st-2 .st-btn>img{top:4.2px}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-168027530-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-168027530-1')</script></head><body class="blog single d-flex flex-column min-vh-100"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=MySpace>MySpace</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>MySpace</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/books/>Books</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://twitter.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-lg-none">Twitter</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Tag List</h3><ol><li><a href=/tags/go/>go</a></li><li><a href=/tags/go/ast/>go/ast</a></li><li><a href=/tags/visualize/>visualize</a></li><li><a href=/tags/uml/>uml</a></li></ol></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#代码可读性>代码可读性</a></li><li><a href=#代码是思维的表达>代码是思维的表达</a></li><li><a href=#oop思想认识世界>OOP思想认识世界</a></li><li><a href=#流程控制--组件交互>流程控制 + 组件交互</a></li><li><a href=#认识-goast>认识 go/ast</a></li><li><a href=#微服务可视化>微服务可视化</a><ul><li><a href=#找到关心的入口点>找到关心的入口点</a></li><li><a href=#从入口点处开始层层展开>从入口点处开始层层展开</a></li><li><a href=#增加通信过程的说明信息>增加通信过程的说明信息</a></li><li><a href=#何时何地以及如何触发>何时何地以及如何触发</a></li><li><a href=#put-it-together>Put It Together</a></li></ul></li></ul></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>Visualizing Your Go Code</h1><div style=display:flex><div>分享:&nbsp;&nbsp;</div><div><div class=sharethis-inline-share-buttons></div></div></div><hr><p class=lead></p><h3 id=代码可读性>代码可读性 <a href=#%e4%bb%a3%e7%a0%81%e5%8f%af%e8%af%bb%e6%80%a7 class=anchor aria-hidden=true>#</a><a href=#代码可读性 class=anchor aria-hidden=true>#</a></h3><p>作为一名开发人员，代码可读性是我们常常挂在嘴边的。代码写出来除了让计算机能够正常执行以外，终究还是要让人能够理解它，后续才能做进一步的维护工作。如果代码写出来，只有它的作者能够看得懂，那只能说明这个作者逻辑表达能力有问题，透过其代码难以看出解决问题的思路。这是软件工程中要尽力避免的。</p><p>在软件工程方法论指导下，为了尽可能让代码可读性达标，我们往往会根据一些最佳实践拟定一些大多数人认可的标准，让所有开发人员遵守，然后通过代码评审、代码规范检查、持续集成交付流水线等综合起来，以尽可能逼近这一目标。当绝大多数人能够在约定的框架下，保质保量提交代码时，我们已经在代码可读性、可维护性方面前进了一大步。</p><p>然而，这样足够了吗？我认为还不够。</p><h3 id=代码是思维的表达>代码是思维的表达 <a href=#%e4%bb%a3%e7%a0%81%e6%98%af%e6%80%9d%e7%bb%b4%e7%9a%84%e8%a1%a8%e8%be%be class=anchor aria-hidden=true>#</a><a href=#代码是思维的表达 class=anchor aria-hidden=true>#</a></h3><p>代码，不过是通过一种大家都理解的语言书写出来的篇章。就好比写文章一样，要有中心思想，然后围绕中心思想要展开层层描述。写代码一样，中心思想就是我们要解决的问题，围绕中心思想的层层描述就是我们解决问题的思路。所以，代码没有什么神秘的，它是人类思维的表达。</p><p>我们是如何快速理解一篇文章的呢？</p><ul><li>先看标题，掌握其核心关键词；</li><li>看下第一段落的内容，往往第一段会引出问题；</li><li>看下其余段落的首句、末句，往往会给出该段落的中心思想；</li><li>看下最后一段的内容，一般会给出一个结论；</li><li>通篇串下，了解文章整体含义；</li></ul><p>为什么我们会通过这种方式？因为一篇好的文章一定有承上启下、过渡。这种循序渐进的方式，步步逼近中心思想。</p><p>那代码呢？某种程度上，代码也是类似的。</p><ul><li>以go语言为例，通常对于一个package，我们会提供package注释来表示当前package要解决的问题；</li><li>每个package内部又包含了不同的types、variables、functions，它们结合起来来解决一个问题；</li><li>每一个function内部又分为多个步骤，每一步完成一个小功能，为下一步做好准备；</li><li>每一个小功能、步骤可能是if-else, switch-case, for-loop……之类的语言结构；</li><li>同时，我们还会提供测试用例，来验证上述方案的正确性。</li></ul><p>有没有觉得很相似，或许我们应该采用已有的读书的经验来辅助更好地理解程序？</p><h3 id=oop思想认识世界>OOP思想认识世界 <a href=#oop%e6%80%9d%e6%83%b3%e8%ae%a4%e8%af%86%e4%b8%96%e7%95%8c class=anchor aria-hidden=true>#</a><a href=#oop思想认识世界 class=anchor aria-hidden=true>#</a></h3><p>代码，和文章不同的是，它虽然有明显的程序构造，但是却没有明显的段落之分。</p><p>那我如何才能借鉴多年来养成的还不错的阅读习惯，来帮助我理解代码呢？当然不能盲目套用，不过俗话说，能工摹形，巧匠窃意，思想很多地方还是可以相通的。</p><p>如何更好地理解这个世界，对各种各样的问题进行抽象呢？比如一辆摩托车，它有离合器、发动机、链条、轮毂、轮胎、减震、油箱、排气等很多部件构成，我听说宝马水鸟电子控制很厉害，可以实现无人驾驶，那可是两轮的400多斤的大机器。那它的电子控制系统怎么做到的？至少要能理解一个摩托车有核心部件，整体运转起来如何理解其状态，如何控制个别部件以影响其他部件进而控制整体状态。那它如何控制部件呢？电子操作或机械操作。</p><p>扯远了，我只是有点喜欢水鸟而已。整个世界可以看做是一个个对象及其之间的联系所构成，代码也不例外。</p><p>道法自然，OOP的思想不过是借鉴了人类认识世界的方式，将其运用到了软件工程领域，以更好地对问题进行抽象，从而构建出设计更合理的软件。那代码里面有哪些语言构造体现了OOP的思想呢。</p><ul><li>类型与对象，生物学里区分物种、种群、个体，那是因为它们既有共性，也有个性；</li><li>通信的方式，自然界个体之间的交互也有多种方式，比如雄狮撒泡尿标记领地也不管入侵者认不认同，或者低吼驱赶入侵者离开，人和人用听得懂的语言沟通；</li><li>隐私与距离，每个人都有自己的隐私，如果你的朋友跟你借100块钱你可能给了，但是他如果问是你老婆给的还是你自己的，你可能就不想借给他了，给你就行了你管那么多干嘛呢，我还不想拿自家的借你呢，说不定借你老婆的给你的呢。每个人在一副外表下总有些不愿意被人触碰、靠近的地方。</li></ul><p>了解一个人，其实你不需要深入他的家庭本身去了解，看看他天天接触什么人，说些什么话，你也就大致清楚了。感兴趣就继续了解，不感兴趣也就拉倒了。我想绝大多数人都不是窥视狂，在拥有一定判断力的基础上，通过一些局部的信息是可以了解大致的整体信息的。</p><p>理解代码有相同之处？</p><h3 id=流程控制--组件交互>流程控制 + 组件交互 <a href=#%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6--%e7%bb%84%e4%bb%b6%e4%ba%a4%e4%ba%92 class=anchor aria-hidden=true>#</a><a href=#流程控制--组件交互 class=anchor aria-hidden=true>#</a></h3><p>某种程度上，我认为理解代码也有相似之处。</p><p>如果能够拎出那些比较重要的对象（objects），以及他们之间的通信（function call, chan send/recv），或者他们的私密信息（注释），是不是也能够大致有个了解呢？</p><p>如果想更深入了解下，加上事情的脉络（控制结构，if-else, switch-case, for-loop）呢？</p><p>其他信息? 我相信还有其他有用的有用信息，能够通过一些更加有效率的方式呈现出来。</p><h3 id=认识-goast>认识 go/ast <a href=#%e8%ae%a4%e8%af%86-goast class=anchor aria-hidden=true>#</a><a href=#认识-goast class=anchor aria-hidden=true>#</a></h3><p>计算机编程语言，有多少种？我认为只有一种，就是人类可以理解的语言。有趣的是，编程语言之多可以覆盖元素周期表，不信来瞧瞧。</p><table><tr><td><img alt=languages src=https://i.pinimg.com/originals/bb/3a/d0/bb3ad028960fb7345df89057ff071437.jpg width=340px></td><td><img alt="goast example" src=https://upload.wikimedia.org/wikipedia/commons/a/ac/Python_add5_parse.png width=340px></td></tr></table><ul><li>语言是什么？语言有精确的数学定义，它不是胡编乱造，尤其是编程语言；</li><li>编程语言更精确？那倒未必，人类社会多姿多彩之处，就在于会演绎出更加丰富多彩的内容，包括对语言的破坏性“创造”，人脑纠错能力太强了，我们甚至没有察觉到自己犯了错误，如网上津津乐道的山东人倒装玩法；</li><li>我能发明一门语言吗？当然，只要你能给出严谨的数学定义，没有歧义，找到一群人学会并开始用它交流，姑且可以称为语言了，比如生活大爆炸谢耳朵他老婆；</li><li>语言不是主谓宾之类的吗？主谓宾也可以进一步形式化，数学之美也让我感到惊叹；</li></ul><p>So&mldr;假如我用编程语言写了一段代码，如何知道我有没有犯错误呢？那就是编译器的工作，词法分析、语法分析、语义分析，一切OK之后会进入中间代码生成、代码优化、生成最终代码。通常一般在语法分析会构建语法分析树AST（Abstract Syntax Tree），如果能够正常构建出AST，表示代码是按照语言对应生成规则来写的，就没什么大问题，反之则可能又自我“发挥”犯错了。</p><p>以下面的go程序为例：</p><pre><code class=language-go>package main

import (
    &quot;fmt&quot;
)

func add(a, b int) int {
    return a + b
}

func main() {
    c := add(1, 2)
    fmt.Printf(&quot;1 + 2 = %d\n&quot;, c)
}
</code></pre><p>以下是两个不错的ast可视化工具，可以将上述代码拷贝以下以查看对应的AST。</p><ul><li><a href=https://astexplorer.net>ast-explorer</a></li><li><a href=https://yuroyoro.github.io/goast-viewer/index.html>goast-viewer</a></li></ul><p>ps: 推荐前者，实现了类似chrome inspect element时选中区域查看对应代码的操作，光标移到对应代码区域，即可高亮显示对应的AST部分区域。</p><p>比如现在我们选中了import相关的部分，对应右边展示出了import声明对应的AST中的部分子树，对应的就是一个GenDecl结构。函数声明也有对应的FuncDecl，类型也有对应的&mldr;</p><img alt="goast example" src=/blog/assets/goast/goast.png width=680px><p>ps: AST展示形式竟然不是一棵树？它确实是一棵树，只不过，AST是非常庞大的，如果通过树的形式来展示，篇幅太大，反而不方便查看。</p><p>go标准库提供了一个package go/ast，用它来对源码进行分析并构建出AST，然后基于AST可以对源码结构进行理解加工，举几个常见的用途：</p><ul><li>go标准库有频率不高的package迁移、方法签名变化、其他情况，<code>go fix</code>实现了旧代码像新代码的快速迁移，其实就是通过对AST操作实现的；</li><li>代码中检测error处理、是否有合理注释等，也可以基于AST进行分析，开发可能一不小心忽略对error处理、goroutine panic处理，有些三方库就可以基于AST分析有没有上述情况，以对源码中的问题进行自动修复；</li><li>提取关键操作信息进行可视化，如<a href=https://infinityworks.com/insights/sequence-diagrams/>apitest.dev</a>将HTTP操作、DB操作作为重点关注对象对代码中的相关交互进行提取、可视化展示，<a href=https://ballerina.io/>Ballerina</a>框架中也有类似实现。</li><li>提取关键的网络调用操作，自动化opentracing埋点，<a href=https://developers.mattermost.com/blog/instrumenting-go-code-via-ast/>Instrumenting Go code via AST</a>。</li><li>其他；</li></ul><p>可见了解 go/ast，将有助于我们更好地理解代码，并作出一些更有创意的工具。</p><h3 id=微服务可视化>微服务可视化 <a href=#%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%8f%af%e8%a7%86%e5%8c%96 class=anchor aria-hidden=true>#</a><a href=#微服务可视化 class=anchor aria-hidden=true>#</a></h3><p>我正在调研一些业界流行的微服务框架，吸收一些比较好的创意，在我从事的团队，现在基本都是采用微服务架构设计、开发、部署了，某种程度上，微服务一点都不微，有些逻辑也很复杂，而且业务代码真的没什么好看的。绝大多数时候，我希望1min了解其逻辑，超过10min我还看不懂的，心里已经开始在犯嘀咕了，这写的啥？</p><p>是我“没耐心”？我倒是不这么认为，如果一个操作我每天要人肉重复几十遍，我就得想办法“偷偷懒”提高下效率了。身为工程师，卖肉是耻辱。</p><p>再回想一下哪些语言构造比较重要，rpc、对象之间的通信（方法调用）、包方法调用、goroutine之间通信（chan send/recv），还有控制逻辑if-else、switch-case、for-loop。</p><p>我们可以先从实用又简单点的开始，比如rpc、对象方法调用、包方法调用，其他的后续再完善。OK!</p><h4 id=找到关心的入口点>找到关心的入口点 <a href=#%e6%89%be%e5%88%b0%e5%85%b3%e5%bf%83%e7%9a%84%e5%85%a5%e5%8f%a3%e7%82%b9 class=anchor aria-hidden=true>#</a><a href=#找到关心的入口点 class=anchor aria-hidden=true>#</a></h4><p>按照一些微服务框架的编码风格，通常main.go里面会注册service接口级实现，这里就可以作为一个入口，我们可以找出AST中main.go中注册的所有service及其实现，并分析service接口中定义的方法，然后再将service实现中的对应方法作为入口点。</p><p>找到这些入口点之后，我们将可以从AST中遍历所有的方法定义，直到匹配到receiver type、method signature匹配的定义。</p><p>file: main.go</p><pre><code class=language-go>func main() {

	s := gorpc.NewServer()

	pb.RegisterHelloService(s, &amp;helloServiceImpl{})

	if err := s.Serve(); err != nil {
		log.Fatal(err)
	}
}
</code></pre><h4 id=从入口点处开始层层展开>从入口点处开始层层展开 <a href=#%e4%bb%8e%e5%85%a5%e5%8f%a3%e7%82%b9%e5%a4%84%e5%bc%80%e5%a7%8b%e5%b1%82%e5%b1%82%e5%b1%95%e5%bc%80 class=anchor aria-hidden=true>#</a><a href=#从入口点处开始层层展开 class=anchor aria-hidden=true>#</a></h4><p>每个函数在AST中都有对应的结构，函数体内包括的每一条语句也是这样，那还有什么不能干的？</p><p>我们可以递归地将一条语句层层展开，抽丝剥茧，直到看到关心的脉络。刚才我们说先只考虑rpc、对象方法调用、包导出函数调用就可以了，这类基本可以形式化成<code>xxx.Func(args...)</code>的形式，就覆盖了上面这几种情况。</p><p>只要碰到这样的语句，我们就记录一下，并将其递归地展开，展开过程中依然记录所有<code>xxx.Func(args...)</code>形式的函数调用……直到没什么可继续展开为止。</p><p>这样，我们就可以大致实现最初的设想：看到对象之间的所有通信过程。</p><h4 id=增加通信过程的说明信息>增加通信过程的说明信息 <a href=#%e5%a2%9e%e5%8a%a0%e9%80%9a%e4%bf%a1%e8%bf%87%e7%a8%8b%e7%9a%84%e8%af%b4%e6%98%8e%e4%bf%a1%e6%81%af class=anchor aria-hidden=true>#</a><a href=#增加通信过程的说明信息 class=anchor aria-hidden=true>#</a></h4><p>在go代码规范里面，对于导出方法、导出函数、导出类型通常都是需要添加godoc注释的，这些注释本身就具有一定的说明性。那当我们通过对象间的调用关系进行可视化时，是否可以将这些注释信息添加上，以提供更好的说明呢？当然。</p><h4 id=何时何地以及如何触发>何时何地以及如何触发 <a href=#%e4%bd%95%e6%97%b6%e4%bd%95%e5%9c%b0%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e8%a7%a6%e5%8f%91 class=anchor aria-hidden=true>#</a><a href=#何时何地以及如何触发 class=anchor aria-hidden=true>#</a></h4><p>何时何地以及如何触发了特定的函数调用？</p><ul><li>何时何地？filename:lineno:columnno，每一个ast对象都有一个Pos()方法，配合<code>token.Position(astobj.Pos())</code>就可以计算出源码位置；</li><li>如何触发？函数调用时的参数信息，函数调用发生的作用域（function scope）；</li></ul><h4 id=put-it-together>Put It Together <a href=#put-it-together class=anchor aria-hidden=true>#</a><a href=#put-it-together class=anchor aria-hidden=true>#</a></h4><p>当我们将上述提及的操作全部组织在一起，就可以实现大致如下效果，篇幅以及时间原因，这里就不再一步步详细描述代码逻辑了。</p><table><tr><td><img src=https://user-images.githubusercontent.com/3725760/95085402-c2fc6b80-0751-11eb-9db1-a9d201a7dadc.png width=340px ;></td><td><img src=https://user-images.githubusercontent.com/3725760/95085465-d8719580-0751-11eb-8cbc-a6e04a270fdd.png width=340px ;></td></tr></table><p>如果您对这里的实现确实感兴趣，您可以查看这里的代码来进一步了解<a href=https://github.com/hitzhangjie/gorpc-cli/commit/58e8d8fe25e3f0b72592c40f2d623793f46a5115>MR: gorpc support visualize subcmd</a>。</p><p>ps: 我也在做一些gorpc101教程之类的材料准备，包括书籍、框架、工具、插件之类的小玩意，一方面是为了沉淀自己，一方面是为了验证想法，如果能有些许建议或者愿意参与进来，那我先表示欢迎。</p><ul><li><a href=github.com/debugger101>debugger101</a></li><li><a href=github.com/gorpc101>gorpc101</a></li></ul><div class=edit-page><a href=https://github.com/hitzhangjie/myspace/blob/master/content/blog/2020-10-06-Visualizing-Your-Go-Code.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div><div class="docs-navigation d-flex justify-content-between"><a href=/blog/2020-10-16-%E5%81%B7%E6%87%92%E4%BB%8E%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%BC%80%E5%A7%8B/><div class="card my-1"><div class="card-body py-2">&larr; 如何“偷懒”：从提升代码质量开始</div></div></a><a class=ms-auto href=/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/><div class="card my-1"><div class="card-body py-2">go源码剖析 - go命令 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted mt-auto"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div><div class=col-lg-8 align=right><p><font size=-1>站点构建版本：v0.2.3</font></p></div></div></div></footer><script src=/js/bootstrap.min.fdbe9b9ba88a036135318f3c721784d684ac9e3280fe282cc80d7d49f7f9c82780cd54228c1608685a230c09984300d7946fc471734d566fcebc148b65bd16db.js integrity="sha512-/b6bm6iKA2E1MY88cheE1oSsnjKA/igsyA19Sff5yCeAzVQijBYIaFojDAmYQwDXlG/EcXNNVm/OvBSLZb0W2w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.b64f1e7517e5839396950ceee4ef937fbbd3ff20aa1fdd261ce87fa457863404f35a6e5239dd57b20b37f39c2401b933deeef60af180195b16941c88f10e948d.js integrity="sha512-tk8edRflg5OWlQzu5O+Tf7vT/yCqH90mHOh/pFeGNATzWm5SOd1Xsgs385wkAbkz3u72CvGAGVsWlByI8Q6UjQ==" crossorigin=anonymous defer></script>
<script src=/main.min.f16ffd9b364013a1df84be9cd7a45c470cb48639766bf5551e05bba845fe4ab150cb6436de43609bfed9af47c23bd5e395e9a10b932fa6fb2c4ee8f6cc78d7a3.js integrity="sha512-8W/9mzZAE6HfhL6c16RcRwy0hjl2a/VVHgW7qEX+SrFQy2Q23kNgm/7Zr0fCO9XjlemhC5MvpvssTuj2zHjXow==" crossorigin=anonymous defer></script>
<script src=/index.min.d62c20b17017051a54aa6972ae84eda32621e7b7421e29178d76e326b678dca4fbb971ac432558234e509b383990296316d1ef300e4746c234a5df95b64c1c79.js integrity="sha512-1iwgsXAXBRpUqmlyroTtoyYh57dCHikXjXbjJrZ43KT7uXGsQyVYI05Qmzg5kCljFtHvMA5HRsI0pd+VtkwceQ==" crossorigin=anonymous defer></script></body></html>