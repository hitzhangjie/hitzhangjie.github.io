<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kvstore on</title><link>/tags/kvstore/</link><description>Recent content in kvstore on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sun, 05 Sep 2021 00:47:15 +0800</lastBuildDate><atom:link href="/tags/kvstore/index.xml" rel="self" type="application/rss+xml"/><item><title>如何使用raft算法开发强一致kv存储系统</title><link>/blog/2021-09-04-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raft%E5%BC%80%E5%8F%91%E5%BC%BA%E4%B8%80%E8%87%B4kv%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 05 Sep 2021 00:47:15 +0800</pubDate><guid>/blog/2021-09-04-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raft%E5%BC%80%E5%8F%91%E5%BC%BA%E4%B8%80%E8%87%B4kv%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid><description>本文内容 # 本文结合etcd源码来进行介绍，etcd/contrib/raftexample提供了一个基于etcd/raft实现的kv存储系统。从该示例出发，我们来看一看如何基于raft算法开发一个强一致的kv存储系统。
看完本文的源码分析后，上手一个raft强一致系统开发就不是什么难事了。
ps：假定读者已经阅读并理解了raft论文，这里有我的批注版的In Search of an Understandable Consensus Algorithm.pdf，读起来可能会好理解点。
etcd/raft # etcd服务端程序入口：see 源码
启动过程中区分当前节点类型：根据data-dir目录下的目录名member/proxy/empty来区分，然后启动etcd实例或者proxy； 启动etcd服务节点：startEtcd这个函数，逻辑主要包括启动供集群节点间通信的rafthttp服务，以及供客户端请求的服务； 启动etcd proxy：startProxy这个函数，逻辑主要是启动etcd代理； etcd哪些部分值得学习：
etcd proxy从项目功能上来说虽然很重要，但是从学习角度来说没那么有价值，不看这个； etcd server从项目功能上来说是核心，但是我们也没有必要学习所有的请求处理逻辑，重点是关注读写操作时如何基于raft实现强一致； raft：这部分是raft算法的核心实现，从理解raft论文到算法工程化需要额外做出巨大的优化，这些知识点往往是通用的，重点掌握； raft部分：
pb协议： raft peers的通信协议，see 源码； raft算法中提到核心的几个rpc就是Vote、AppendEntries，但是工程中需要考虑更多，详见上述pb中的enum MessageType； 上述pb中的message Message类型定义了rpc通信过程中的请求/响应，不同rpc通过MessageType type字段区分； 状态机： raft实现数据一致性是通过replicated log（复制日志）实现的，这里的replicated log有时也称为WAL（write ahead log）； raft算法中，每个节点raftnode可能处于以下状态中的一种：follower、candidate、precandidate、leader； raft算法中，每个节点的状态可以通过一个状态机来建模； 了解了这些基础知识之后，我们结合etcd/contrib/raftexample来解释下raft如何选举，以及leader遇到写操作如何保证数据强一致。
etcd/raft如何进行leader选举 # newRaftNode newRaftNode，see 源码，这个函数包括创建一个var rc raftNode，然后rc.startRaft()，这个函数包含非常重要的几个部分：
startNode，see 源码，这个主要是建立好raftnode启动时的一些初始状态转换，有一个for事件循环处理，如改变raftnode的状态：tick函数、step函数，以及一些message的处理等等； serveRaft： serveChannels：see 源码 startNode:</description></item></channel></rss>