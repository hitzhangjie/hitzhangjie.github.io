<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.63b6b8ff933309fcc94a30e21d69932290c8643fa1a32893f5681778c776ed3e51c237a1acd00b42426b3bf780c351b4a6ce75b3b659915ef0dd610b2e027a8c.css integrity="sha512-Y7a4/5MzCfzJSjDiHWmTIpDIZD+hoyiT9WgXeMd27T5RwjehrNALQkJrO/eAw1G0ps51s7ZZkV7w3WELLgJ6jA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>go源码剖析 - go命令 - MySpace</title><meta name=description content="1. 本文简介 # 首先我们看下go命令行有哪些功能，运行go help可以查看go命令的详细帮助信息，go命令有很多子命令，每个子命令有特定的功能。go命令功能之丰富涵盖了源文件编译、汇编、连接、反汇编、逃逸分析、代码生成、模块解析等等非常系统性的功能，了解go命令的实现将有助于系统性掌握整个go编译工具链。本文介绍下go命令的详细功能及大致实现，供后续参考。
2. go子命令列表 # go支持的子命令列表如下，下面我们逐一来简单说下。
 bug, start a bug report build, compile packages and dependencies clean, remove object files and cached files doc, show documentation for package or symbol env, print Go environment information fix, update packages to use new APIs fmt, gofmt (reformat) package sources generate, generate Go files by processing source get, add dependencies to current module and install them install, compile and install packages and dependencies list, list packages or modules mod, module maintenance run, compile and run Go program test, test packages tool, run specified go tool version, print Go version vet, report likely mistakes in packages  3."><link rel=canonical href=/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="go源码剖析 - go命令"><meta property="og:description" content="1. 本文简介 # 首先我们看下go命令行有哪些功能，运行go help可以查看go命令的详细帮助信息，go命令有很多子命令，每个子命令有特定的功能。go命令功能之丰富涵盖了源文件编译、汇编、连接、反汇编、逃逸分析、代码生成、模块解析等等非常系统性的功能，了解go命令的实现将有助于系统性掌握整个go编译工具链。本文介绍下go命令的详细功能及大致实现，供后续参考。
2. go子命令列表 # go支持的子命令列表如下，下面我们逐一来简单说下。
 bug, start a bug report build, compile packages and dependencies clean, remove object files and cached files doc, show documentation for package or symbol env, print Go environment information fix, update packages to use new APIs fmt, gofmt (reformat) package sources generate, generate Go files by processing source get, add dependencies to current module and install them install, compile and install packages and dependencies list, list packages or modules mod, module maintenance run, compile and run Go program test, test packages tool, run specified go tool version, print Go version vet, report likely mistakes in packages  3."><meta property="og:url" content="/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/"><meta property="og:site_name" content="MySpace"><meta property="article:published_time" content="2020-09-28T22:18:43+08:00"><meta property="article:modified_time" content="2020-09-28T22:18:43+08:00"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="MySpace"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@hitzhangjie"><meta name=twitter:creator content="@hitzhangjie"><meta name=twitter:title content="go源码剖析 - go命令"><meta name=twitter:description content><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="go源码剖析 - go命令"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":["https://twitter.com/hitzhangjie","https://www.linkedin.com/in/hitzhangjie/","https://github.com/hitzhangjie"],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"MySpace","description":"MySpace is a hitzhangjie\u0027s personal space, for blogs, books, journey, thinkings.","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/","url":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/","name":"go源码剖析 - go命令","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2020-09-28T22:18:43CET","dateModified":"2020-09-28T22:18:43CET","breadcrumb":{"@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/"]}]},{"@type":"BreadcrumbList","@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/blog2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"go源码剖析 - go命令","description":"","isPartOf":{"@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/"},"mainEntityOfPage":{"@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/"},"datePublished":"2020-09-28T22:18:43CET","dateModified":"2020-09-28T22:18:43CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/person/1"},"image":{"@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/2020-09-28-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-go%E5%91%BD%E4%BB%A4/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"go源码剖析 - go命令"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=607868a58d7101001829a8df&product=sop" async></script><style>[alt~=sharing]{border:0;box-shadow:none}div#st-1{text-align:unset}div#st-1 .st-btn{height:24px;padding:0 4px}div#st-1 .st-btn>img{top:4.2px}div#st-2 .st-btn{height:24px;padding:0 4px}div#st-2 .st-btn>img{top:4.2px}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-168027530-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-168027530-1')</script></head><body class="blog single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=MySpace>MySpace</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>MySpace</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/books/>Books</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://twitter.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-lg-none">Twitter</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/hitzhangjie><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Tag List</h3><ol><li><a href=/tags/go/>go</a></li><li><a href=/tags/toolchain/>toolchain</a></li></ol></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1-本文简介>1. 本文简介</a></li><li><a href=#2-go子命令列表>2. go子命令列表</a></li><li><a href=#3-go-subcmds>3. go subcmds</a><ul><li><a href=#go-bug>go bug</a></li><li><a href=#go-build>go build</a></li><li><a href=#go-clean>go clean</a></li><li><a href=#go-doc>go doc</a></li><li><a href=#go-env>go env</a></li><li><a href=#go-fix>go fix</a></li><li><a href=#go-fmt>go fmt</a></li><li><a href=#go-generate>go generate</a></li><li><a href=#go-get>go get</a></li><li><a href=#go-install>go install</a></li><li><a href=#go-list>go list</a></li><li><a href=#go-mod>go mod</a></li><li><a href=#go-run>go run</a></li><li><a href=#go-test>go test</a></li><li><a href=#go-tool>go tool</a></li><li><a href=#go-version>go version</a></li><li><a href=#go-vet>go vet</a></li></ul></li><li><a href=#4-总结>4. 总结</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>go源码剖析 - go命令</h1><div style=display:flex><div>分享:&nbsp;&nbsp;</div><div><div class=sharethis-inline-share-buttons></div></div></div><hr><p class=lead></p><h2 id=1-本文简介>1. 本文简介 <a href=#1-%e6%9c%ac%e6%96%87%e7%ae%80%e4%bb%8b class=anchor aria-hidden=true>#</a><a href=#1-本文简介 class=anchor aria-hidden=true>#</a></h2><p>首先我们看下go命令行有哪些功能，运行<code>go help</code>可以查看go命令的详细帮助信息，go命令有很多子命令，每个子命令有特定的功能。go命令功能之丰富涵盖了源文件编译、汇编、连接、反汇编、逃逸分析、代码生成、模块解析等等非常系统性的功能，了解go命令的实现将有助于系统性掌握整个go编译工具链。本文介绍下go命令的详细功能及大致实现，供后续参考。</p><h2 id=2-go子命令列表>2. go子命令列表 <a href=#2-go%e5%ad%90%e5%91%bd%e4%bb%a4%e5%88%97%e8%a1%a8 class=anchor aria-hidden=true>#</a><a href=#2-go子命令列表 class=anchor aria-hidden=true>#</a></h2><p>go支持的子命令列表如下，下面我们逐一来简单说下。</p><ul><li>bug, start a bug report</li><li>build, compile packages and dependencies</li><li>clean, remove object files and cached files</li><li>doc, show documentation for package or symbol</li><li>env, print Go environment information</li><li>fix, update packages to use new APIs</li><li>fmt, gofmt (reformat) package sources</li><li>generate, generate Go files by processing source</li><li>get, add dependencies to current module and install them</li><li>install, compile and install packages and dependencies</li><li>list, list packages or modules</li><li>mod, module maintenance</li><li>run, compile and run Go program</li><li>test, test packages</li><li>tool, run specified go tool</li><li>version, print Go version</li><li>vet, report likely mistakes in packages</li></ul><h2 id=3-go-subcmds>3. go subcmds <a href=#3-go-subcmds class=anchor aria-hidden=true>#</a><a href=#3-go-subcmds class=anchor aria-hidden=true>#</a></h2><h3 id=go-bug>go bug <a href=#go-bug class=anchor aria-hidden=true>#</a><a href=#go-bug class=anchor aria-hidden=true>#</a></h3><p><code>go bug</code>，用于快速创建bug report。</p><p>作为开源项目的维护人员，非常希望开发人员“会”提问题！为什么这么说呢，就是因为如果不会提问题、问问题，沟通成本就会非常高，这对于开源项目维护人员来说，时间上是个极大的浪费。</p><p>在腾讯我也参与维护了好几个比较大型的开源项目，经常受到一些同学的问题，很多时候我真的感谢求学阶段长时间泡stackoverflow的经历，stackoverflow上教会了我怎么提问题，这个在我后面学习、沟通、检索、开源协同中起到了很重要的作用。</p><p>为了降低沟通成本，go bug内部定义了一个issue模板（其实github也支持定义模板），包括了几个部分：问题简述、go版本、go env信息、执行的操作、期望的结果、实际的结果。这里呢，为了保护go issuer的体验，go bug会自动获取go环境信息，填充到issue模板中，这里的内容将作为issue的body部分。</p><p>接下来会判断go issuer当前系统信息，并决定如何打开web浏览器，浏览器打开一个issue创建页面，通过GET参数填充issue的body，一个简单的issue基本信息就填充完成了。go issuer只需要填充下标题、问题简述、执行操作、期望结果、实际结果就创建完成了。</p><h3 id=go-build>go build <a href=#go-build class=anchor aria-hidden=true>#</a><a href=#go-build class=anchor aria-hidden=true>#</a></h3><p><code>go build</code>可以细分为如下几个操作：</p><ul><li>compile, src/cmd/compile/main.go</li><li>asm, &mldr;</li><li>link, src/cmd/link/main.go</li><li>ld, &mldr;</li></ul><p><code>go build</code>过程分析，假定待编译的工程开启了go module：</p><ul><li><p>初始化操作</p><ul><li><code>modload.Init()</code>, 进行go module相关的初始化，如检查环境变量GO111MODULE决定是否启用go module、定位go.mod所在的目录、设置git等；</li><li><code>instrumentInit()</code>，代码织入初始化，什么是代码织入呢，比如<code>go build -race</code>对代码中的竞态条件进行检查，需要在原程序中加入一些特殊代码来统计对某些数据结构的并发读写操作，这就称之为代码织入，熟悉Java字节码织入的话应该很容易看懂这里的概念，比如Kilim、Quasa等字节码织入。<code>go build -msan</code>应该是启用与内存清理相关的操作。这里也就是检查一下flag的正确性（如-race、-msan不能同时指定），检查一下平台是否支持race检查、msan检查；</li><li><code>buildModeInit()</code>，构建模式初始化，包括决定是构建一个共享库，还是一个可执行程序，还是其他等，也会检查平台是否支持、是否开启go module等；</li></ul></li><li><p>builder初始化: builder保存着一次构建过程中的全局状态，不保存package的全局状态，不同package的编译是并发进行的，builder是单例共享的</p><ul><li>初始化打印函数</li><li>初始化action cache</li><li>初始化mkdir cache</li><li>初始化tool id cache</li><li>初始化build id cache</li><li>初始化临时构建目录</li><li>检查GOOS、GOARCH是否合法</li><li>检查指定的tag列表</li></ul></li><li><p>加载要构建的路径对应的package信息</p><ul><li>加载路径对应的pacakge</li><li>移除纯测试用的package</li></ul></li><li><p>创建要执行的actions：一个action表示action图中的一个单独的动作</p><ul><li>创建一个go build的action（根节点），我猜这个action是一个表示全局构建完成的action；</li><li>针对各个要构建的package创建一个auto action，都是前一步go build这个action的前置依赖；</li><li>这里的actions构成了一个dag，也称之为action graph；</li></ul></li><li><p>b.Do()开始执行构建</p><ul><li>从根节点执行扫描，按照深度优先搜索、后序遍历的方式进行遍历，正好符合前置（子节点）执行完成后，后置才可以执行的问题；</li><li>根据查看选项是否指定，决定是否输出action graph；</li><li>action dag执行的时候，相当于先执行最底层的叶子节点，执行完再执行上一层的父节点&mldr;以此类推，直到到达根节点；</li><li>根据action.Deps构建反向的触发关系，如a.Deps=b，那么b.Triggers=a，方便b执行完后驱动a执行；</li><li>action.pending表示当前该action剩下的等待执行完成的前置依赖的数量，如果pending为0，表示无依赖或者依赖都已执行完成，当前action变为就绪状态，转移到b.ready这中，b.readySema信号量也ok了；</li><li>启动多个goroutine执行并发的构建任务，当b.readySema就绪后，从b.ready栈中取出要处理的action去执行，记录构建的时间之类的，应该是为了方便统计编译耗时信息；</li><li>这里要注意action.Func，默认是挺过(*Builder).build来构建的，层层展开，其实看得就是gc.go的gc方法，这个方法最终调用的其实是<code>go tool compile</code>来完成编译过程；</li><li><code>go tool compile</code>的代码位于<code>src/cmd/compile/main.go</code>下；</li></ul></li></ul><p><code>go tool compile</code>逻辑实现：</p><ul><li>我擦，一开始各种a#239?fafx8&mdash;</li><li>构建语法树，不是用的go/ast包，而是syntax包，据说这是因为之前是用c写的，即便后面用go重写了，但基本上是翻译了一遍，工程结构没再改；</li><li>基于语法树进行语义分析，如检查类型是否正确，<code>typecheck(node,...)</code>，这里又分为几个步骤：<ul><li>const、type、以及func的类型和名称的检查；</li><li>变量赋值检查；</li><li>函数体类型检查，检查返回值类型？</li><li>类型检查完之后，检查map类型的keys</li></ul></li><li>检查如何捕获closed的变量，需要在逃逸分析之前进行；</li><li>内联检查；</li><li>逃逸分析；</li><li>将闭包中对外部变量的引用，根据使用方式转换为按值捕获、按引用捕获的对应形式；</li><li>编译顶层函数，详见函数：<code>funccompile(node)</code>，这个函数就是根据函数定义（参数列表、返回值）以及语句，生成一系列的操作（操作码、操作数等）;</li><li>&mldr;.</li><li>写对象数据到磁盘，object data，翻译是“对象数据”，不是“目标文件数据”。详见函数<code>dumpdata()</code>，貌似是在函数<code>compileSSA()</code>中实现的，还要确认具体逻辑；</li></ul><p>哇，好复杂!</p><h3 id=go-clean>go clean <a href=#go-clean class=anchor aria-hidden=true>#</a><a href=#go-clean class=anchor aria-hidden=true>#</a></h3><p>我们在编译构建的过程中，一般都会生成一些临时文件，比如.o文件，如果是使用Makefile管理工程构建的时候一般会定义个PHONY Target clean，通过make clean来清理临时文件、目标文件、程序等，MVN构建也会定义clean这样的target，go也不例外。</p><p><code>go build</code>，编译输出可执行程序，<code>go install</code>还会将可执行程序安装到GOBIN或者GOPATH/bin，那现在要清理的话，<code>go clean</code>会清理当前module下的编译产物，<code>go clean -i</code>还会把安装到GOBIN或者GOPATH/bin下安装的程序给清理掉，另外go modules之间也有依赖关系，<code>go clean -r</code>还可以递归地清理依赖产物。</p><p>举个例子，假如现在有个工程目录叫hello，那么在该工程目录下执行go clean，将清理目录下的下述文件：hello, hello.exe, hello.test, hello.test.exe, main, main.exe, main.test, main.test.exe。那假如hello目录下go.mod定义的module是a.b.c呢？会清理a.b.c, a.b.c.exe, a.b.c.test, a.b.c.test.exe吗？不会！但是go clean -i会从GOBIN或GOPATH/bin下清理这些文件。为啥？目前go clean就是这么实现的。</p><p><code>go clean</code>之前实现的有bug，我稍微修改了下，实现了清理${module}, ${module}.exe的功能。</p><h3 id=go-doc>go doc <a href=#go-doc class=anchor aria-hidden=true>#</a><a href=#go-doc class=anchor aria-hidden=true>#</a></h3><p><code>go doc</code> 可以用来显示指定package下的类型、函数、方法及其注释信息，其用法比较多，如<code>go doc</code>、<code>go doc pkg.symbol.fieldOrMethod</code>、<code>go doc pkg.Function</code>等等。</p><p>比如我们运行<code>go doc os.Signal</code>，会显示如下信息：</p><pre><code class=language-go>package os // import &quot;os&quot;

type Signal interface {
    String() string
    Signal() // to distinguish from other Stringers
}
    A Signal represents an operating system signal. The usual underlying
    implementation is operating system-dependent: on Unix it is syscall.Signal.

var Interrupt Signal = syscall.SIGINT ...
</code></pre><p>从这里我们可以看到整个接口的定义，及其godoc注释信息，那么不禁要问，<code>go doc</code> 是如何准确找到这个符号os.Signal定义的呢？</p><p>如果之前有了解过<code>go/ast</code>的用法、用途之后，应该就不难理解了。我还写过一篇讲<a href=https://hitzhangjie.github.io/blog/2020-10-06-visualizing-your-go-code/>微服务代码逻辑可视化的文章</a>，也是使用了go/ast。</p><p><code>go doc</code>的逻辑其实很简单，它首先会将os.Signal split一下，发现是os这个package，然后是Signal这个符号，然后它就会根据build package提供的信息来定位到os对应的目录，然后通过<code>parser.ParseDir(...)</code>来对目录下go文件进行语法分析。分析完之后就将得到AST，然后再基于AST去查找符号Symbol的定义，比如这里是个类型定义，找到AST中对应的节点之后，再提取出注释信息。最后将这些信息格式化输出到stdout。</p><p><code>go doc</code>大致就是这样实现的。</p><h3 id=go-env>go env <a href=#go-env class=anchor aria-hidden=true>#</a><a href=#go-env class=anchor aria-hidden=true>#</a></h3><p><code>go env</code> 命令用来查看、设置、取消设置go相关的一些环境变量。</p><p>我们知道<code>go env</code>会显示出一个环境变量列表，这里面这些环境变量名称都是go envCmd里面预定义好的，比如要设置一个不相干的变量名<code>go env -w xxx</code>是会报错的。</p><p><code>go env</code> 列出的环境变量一般都有一个默认值，如<code>GOSUMDB=sum.golang.org</code>，但是我们有时候希望对齐进行调整，那么可以通过<code>go env -w GOSUMDB=off</code>来进行设置，如果要取消设置恢复到原来的默认设置，则可以执行<code>go env -u GOSUMDB</code>。</p><p>那这里不禁要问，用户手动设置的环境变量存储在哪里呢？其实是存储在环境变量<code>GOENV</code>对应的文件中，macOS下为<code>/Users/zhangjie/Library/Application Support/go</code>，linux下为<code>~/.config/go/env</code>，其实就是<code>os.UserConfigDir()+/go/env</code>路径下。当我们设置、取消设置的时候，会更新文件中的数据。</p><p><code>go env</code>大致就是这么工作的。</p><h3 id=go-fix>go fix <a href=#go-fix class=anchor aria-hidden=true>#</a><a href=#go-fix class=anchor aria-hidden=true>#</a></h3><p>一门快速演进中的编程语言也会面临一些调整的时候，如果发生了变化，比如将golang.org/x/tools/net/context内容转移到标准库context中，可能已经存在一些存量代码了，或者说开发者已经习惯了使用老的import的包路径了，那怎么办呢？想让开发者付出最小的迁移成本而转到使用最新的标准库context上来。go fix就是干这个事情的。</p><p>fix命令执行的时候会检查当前支持那些修复操作，每一个修复操作都指定了要搜索的代码，以及要替换成的代码，比如上面提及的context包导入路径的问题。fix命令会首先解析源文件得到抽象语法树AST，然后基于对AST的操作，搜索出可以修复的问题代码，然后将其替换成对应的新代码，然后再将AST转换成代码输出到源文件中。</p><p>这大概就是go fix (go tool fix) 的一个执行过程，$GOROOT/pkg/tool/$GOOS_$GOARCH/下保存了go tool对应的一些工具，如fix，vet等，运行go vet, go fix就会最终转换成执行上述路径下的vet、fix命令。<code>go fix</code>的入口在$GOROOT/src/cmd/go/fix/fix.go，实际调用的是<code>go tool fix</code>，其入口在<code>$GOROOT/src/cmd/fix/main.go</code>。</p><p>ps: <code>go fix</code>的内部实现，是基于go/ast实现，通过对源码进行语法分析构建ast，通过对ast进行查找、修改，完成对代码的调整，最后再将ast转换为源码输出。</p><h3 id=go-fmt>go fmt <a href=#go-fmt class=anchor aria-hidden=true>#</a><a href=#go-fmt class=anchor aria-hidden=true>#</a></h3><p><code>go fmt</code>实际上是调用的命令gofmt，它其实也是利用了package go/ast完成对特定源文件或者目录下所有源文件的语法分析，构建出语法树，然后基于对语法树的理解和操作，来最终完成对代码的格式化。</p><p><code>go fmt</code>在使用的时候，有几个地方比较方便，选项<code>-d</code>可以将格式化后的代码打印到标准输出，<code>-w</code>则可以直接将文件写入到文件，<code>-s</code>则支持对代码进行简化。</p><p>这里也没有特别多要强调的，继续看其他子命令的实现逻辑。</p><h3 id=go-generate>go generate <a href=#go-generate class=anchor aria-hidden=true>#</a><a href=#go-generate class=anchor aria-hidden=true>#</a></h3><p>go提供了代码生成能力，在go源文件中通过<code>//go:generate ....</code>定义的注释，其实是一种特殊的指令，它告诉go工具可以提取出这些指令来生成代码。当然理论上通过go:generate可以执行任何指令，但是从go工具设计者的初衷来看，它主要是为了用来作为一种包开发者的工具，用来生成或者更新特定源文件的。</p><p>比如一个代码生成工具可以通过代码模板来生成一个完整的服务工程，代码模板里面就可以包含这样的<code>//go:generate mockgen ...</code>指令来生成mock测试相关的桩代码。</p><p><code>go generate</code>实现的逻辑比较简单，它就是遍历源文件，然后去逐行读取每个源文件，检查读取行是不是匹配<code>//go:generate ...</code>，是的话则解析出命令来，然后执行对应的命令。</p><h3 id=go-get>go get <a href=#go-get class=anchor aria-hidden=true>#</a><a href=#go-get class=anchor aria-hidden=true>#</a></h3><p><code>go get</code>用来下载对应模块并安装，同时将该模块添加到当前模块的依赖文件go.mod中。当然<code>go get</code>也有很多一些常用选项，如<code>-u</code>用来更新模块等。这里可以通过<code>go help get</code>来了解详细的信息。</p><h3 id=go-install>go install <a href=#go-install class=anchor aria-hidden=true>#</a><a href=#go-install class=anchor aria-hidden=true>#</a></h3><p><code>go install</code>，它主要是下载对应模块，并完成程序的构建、安装逻辑。需要注意的是，这里在go1.13前后发生了一点变化。</p><p>在go1.13之前的版本中，是要通过go install来安装的，go1.13及之后的版本go get会自动下载、并构建、安装，go install只能安装本地已经下载下来的模块。</p><h3 id=go-list>go list <a href=#go-list class=anchor aria-hidden=true>#</a><a href=#go-list class=anchor aria-hidden=true>#</a></h3><p><code>go list</code>列出packages或依赖，具体如何实现的呢？这个命令怎么实现的不是很感兴趣，先跳过了。</p><h3 id=go-mod>go mod <a href=#go-mod class=anchor aria-hidden=true>#</a><a href=#go-mod class=anchor aria-hidden=true>#</a></h3><p><code>go mod</code>主要是用来对依赖进行管理，常用操作包括<code>go mod init</code>, <code>go mod tidy</code>，<code>go mod vendor</code>等等吧。</p><p>这个有时间再看，当前不是很感兴趣，先跳过了。</p><h3 id=go-run>go run <a href=#go-run class=anchor aria-hidden=true>#</a><a href=#go-run class=anchor aria-hidden=true>#</a></h3><p><code>go run</code>一般用来快速执行一个go文件，这个go文件必须是package main下的，并且包含一个方法<code>func main(){}</code>。<code>go run</code>现在也支持指定一个package main的路径名，要求是一样的，就是这个目录下的go源文件必须是package main，并且有一个源文件中包含<code>func main(){}</code>的定义。</p><p><code>go run</code>其实也需要进行编译、链接过程，只不过这个过程都在一个临时目录中完成，结果产物没有输出到源码目录或者命令执行时的工作目录下。并且<code>go run</code>执行完会后，会自动清理掉这些临时目录。执行完成前是怎么清理的呢？它这里模拟了c里面的函数<code>atexit()</code>来注册退出时要执行的函数，<code>go run</code>进程最终在调用<code>os.Exit()</code>之前会先将之前注册过的处理函数执行一遍，跟c库函数atexit的逻辑类似。这里注册的处理函数就包括清理<code>go run</code>触发编译、链接时生成的临时目录。</p><h3 id=go-test>go test <a href=#go-test class=anchor aria-hidden=true>#</a><a href=#go-test class=anchor aria-hidden=true>#</a></h3><p><code>go test</code>主要是用来执行单元测试用的，它还比较牛，不仅仅可以用来支持"test.go"文件的单元测试，还支持像"cmd/go/testdata/scripts/&ldquo;下的通过txt文件+自定义指令来实现的测试。这里还是有点创新点的。</p><p>这里先说下"test.go"文件的单元测试是如何实现的吧。实际上是这样执行的，它会为当前package下的"test.go"文件，生成一个新的go文件，这个go文件的内容是根据预先定义好的go测试模板文件生成的，内部会通过-test.run选项来选择我们自定义的TestXXX(t)来执行。</p><p>当然<code>go test</code>也支持覆盖率测试等等的操作，这个覆盖率测试实际上也简单，其实是把源文件重写了，每一行语句都对应了一个计数器，执行语句之后，紧跟着一条增加计数器的操作，最后测试程序跑完，检查所有语句的计数器就可以统计出覆盖率信息。</p><p>&mldr;</p><p>其他的，当前也不是很关心了。</p><h3 id=go-tool>go tool <a href=#go-tool class=anchor aria-hidden=true>#</a><a href=#go-tool class=anchor aria-hidden=true>#</a></h3><p>go这个命令行工具是一个集大成者，它内部其实也是调用了一些其他的工具的，如通过<code>go fmt</code>或<code>go tool fmt</code>来调用命令<code>gofmt</code>，还有一些其他的工具，这些工具可以在如下路径中找到：<code>$GOROOT/pkg/tool/$GOOS_$GOARCH</code>。</p><p>这里的工具有很多，我在后面的文章中会有选择的进行介绍。</p><h3 id=go-version>go version <a href=#go-version class=anchor aria-hidden=true>#</a><a href=#go-version class=anchor aria-hidden=true>#</a></h3><p><code>go version</code>就是打印当前go程序的版本信息，这个信息是在go编译构建期间由工具<code>go tool dist</code>生成的，详见<code>runtime/sys/zversion.go</code>。</p><p>还有一种常见的做法，是设置好一个包级别的变量，然后通过<code>go build -ldflags="-X 'pkg.Varable=value'"</code>，这也是一种办法。</p><h3 id=go-vet>go vet <a href=#go-vet class=anchor aria-hidden=true>#</a><a href=#go-vet class=anchor aria-hidden=true>#</a></h3><p><code>go vet</code>用来报道packages中可能的错误，之前有了解过并发map读写的问题，可以通过<code>go vet</code>检查出来，它是怎么检查的呢？它还能检查出什么其他的错误呢？</p><p><code>go vet</code>默认使用的vet工具是go自带的vet工具，也可以通过<code>go vet -vettool=$prog</code>替换成自定义的vet工具。OK，现在我们来看一下go自带的vet分析工具都支持分析哪些类型的错误，以及怎么实现的。</p><p>go自带的vet工具，其实现位于：src/cmd/vet/main.go，从源码中不难看出，vet支持对如下类型的错误进行检查：</p><ul><li>asmdecl: reports mismatches between assembly files and Go declarations</li><li>assign: detects useless assignments</li><li>atomic: checks for common mistakes using the sync/atomic package</li><li>bools: detects common mistakes involving boolean operators</li><li>buildtag: check that +build tags are well-formed and correctly located</li><li>cgocall: detect some violations of the cgo pointer passing rules</li><li>composite: check for unkeyed composite literals</li><li>copylock: check for locks erroneously passed by value</li><li>errorsas: report passing non-pointer or non-error values to errors.As</li><li>httpresponse: check for mistakes using HTTP response</li><li>ifaceassert: detect impossible interface-to-interface type assertions</li><li>loopclosure: check references to loop variables from within nested functions</li><li>lostcancel: check cancel func returned by context.WithCancel is called</li><li>nilfunc: check for useless comparisons between functions and nil</li><li>printf: check consistency of Printf format strings and arguments</li><li>shift: check for shifts that equal or exceed the width of the integer</li><li>stdmethods: check signature of methods of well-known interfaces</li><li>stringintconv: check for string(int) conversions</li><li>structtag: check that struct field tags conform to reflect.StructTag.Get</li><li>tests: check for common mistaken usages of tests and examples</li><li>unmarshal: report passing non-pointer or non-interface values to unmarshal</li><li>unreachable: check for unreachable code</li><li>unsafeptr: check for invalid conversions of uintptr to unsafe.Pointer</li><li>unusedresult: check for unused results of calls to some functions</li></ul><p>如何实现的呢，单独查看各个analyzer的实现就可以了，举例copylock是基于go/ast语法分析来检测出来的。</p><h2 id=4-总结>4. 总结 <a href=#4-%e6%80%bb%e7%bb%93 class=anchor aria-hidden=true>#</a><a href=#4-总结 class=anchor aria-hidden=true>#</a></h2><div class=edit-page><a href=https://github.com/hitzhangjie/myspace/blob/master/content/blog/2020-09-28-go%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90-go%e5%91%bd%e4%bb%a4.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></div><div class="docs-navigation d-flex justify-content-between"><a href=/blog/2020-10-06-visualizing-your-go-code/><div class="card my-1"><div class="card-body py-2">&larr; Visualizing Your Go Code</div></div></a><a class=ms-auto href=/blog/2020-09-20-%E5%AE%B6%E4%BA%BA%E7%94%9F%E6%B4%BB%E6%AF%94%E5%B7%A5%E4%BD%9C%E9%87%8D%E8%A6%81/><div class="card my-1"><div class="card-body py-2">家人&生活，比工作重要 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://www.netlify.com/>Netlify</a>, <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div><div class=col-lg-8 align=right><p><font size=-1>站点构建版本：v0.2.3</font></p></div></div></div></footer><script src=/js/bootstrap.min.fdbe9b9ba88a036135318f3c721784d684ac9e3280fe282cc80d7d49f7f9c82780cd54228c1608685a230c09984300d7946fc471734d566fcebc148b65bd16db.js integrity="sha512-/b6bm6iKA2E1MY88cheE1oSsnjKA/igsyA19Sff5yCeAzVQijBYIaFojDAmYQwDXlG/EcXNNVm/OvBSLZb0W2w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.b64f1e7517e5839396950ceee4ef937fbbd3ff20aa1fdd261ce87fa457863404f35a6e5239dd57b20b37f39c2401b933deeef60af180195b16941c88f10e948d.js integrity="sha512-tk8edRflg5OWlQzu5O+Tf7vT/yCqH90mHOh/pFeGNATzWm5SOd1Xsgs385wkAbkz3u72CvGAGVsWlByI8Q6UjQ==" crossorigin=anonymous defer></script>
<script src=/main.min.f16ffd9b364013a1df84be9cd7a45c470cb48639766bf5551e05bba845fe4ab150cb6436de43609bfed9af47c23bd5e395e9a10b932fa6fb2c4ee8f6cc78d7a3.js integrity="sha512-8W/9mzZAE6HfhL6c16RcRwy0hjl2a/VVHgW7qEX+SrFQy2Q23kNgm/7Zr0fCO9XjlemhC5MvpvssTuj2zHjXow==" crossorigin=anonymous defer></script>
<script src=/index.min.8d57439321b6dd8a598809ce7efb522e23279ded9e7e34e80e427f8ec81ea97de8997395fd0d3165dfb3f4c5454197fd3b0c32d5d862747aa0dec9fe4ad07c37.js integrity="sha512-jVdDkyG23YpZiAnOfvtSLiMnne2efjToDkJ/jsgeqX3omXOV/Q0xZd+z9MVFQZf9Owwy1dhidHqg3sn+StB8Nw==" crossorigin=anonymous defer></script></body></html>