<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Web站点描述">
<title>
go程序如何实现热重启 - 介绍
</title>




<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5f24f50fc2418c0012d52ac3&product=inline-share-buttons" async="async">
</script>

<style>
 
[alt~=sharing] {
    border: 0px;
    box-shadow: none;
}
div#st-1 {
    text-align: unset;
}

 
div#st-1 .st-btn {
    height: 24px;
    padding: 0 4px;
}

div#st-1 .st-btn > img {
    top: 4.2px;
}

div#st-2 .st-btn {
    height: 24px;
    padding: 0 4px;
}

div#st-2 .st-btn > img {
    top: 4.2px;
}
</style>







        <meta property="og:title" content="go程序如何实现热重启 - 介绍" />
<meta property="og:type" content="website" />
<meta property="og:description" content="Web站点描述"/>
<meta property="og:url" content="https://hitzhangjie.github.io/blog/2020-08-28-go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%87%8D%E5%90%AF/"/>
<meta property="og:site_name" content="介绍"/>




<meta property="og:image" content="https://hitzhangjie.github.io/home/me.jpg"/>

<meta property="og:image" content="https://hitzhangjie.github.io/home/profile.jpg"/>




        
<link rel="shortcut icon" href="/img/fav.ico">


        





<link rel="stylesheet" href="/css/main.min.daa833377fb1636f8cbfa65c601050bb5475623deb7aa6e6fdde94a064a6185d.css" integrity="sha256-2qgzN3&#43;xY2&#43;Mv6ZcYBBQu1R1Yj3reqbm/d6UoGSmGF0=" crossorigin="anonymous" media="screen">




    <link rel="stylesheet" href="/custom.css" integrity="" crossorigin="anonymous" media="screen">

        
        
        
        
    </head>
    <body>
        <section id="top" class="section">
            
            <div class="container hero  fade-in one ">
                

    <h1 class="bold-title is-1">博客</h1>


            </div>
            
            <div class="section  fade-in two ">
                
<div class="container">
    <hr>
    <nav class="navbar" role="navigation" aria-label="main navigation">
        
        <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
        <div class="navbar-menu " id="navMenu">
            
            
            
            
            <a class="navbar-item" href="/">主页</a>
            

            
            

            
                
            

            
                
            

            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.github.io/projects/">
                  
                  项目
                  
                  </a>
                
                
            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.github.io/blog/">
                  
                  返回 博客
                  
                  </a>
                
                
            
            
            
            
            
            <a class="navbar-item" href="/#about">关于</a>
            
            
            
            
            
            <a class="navbar-item" href="/#thanks">致谢</a>
            
            
            
            

            
            
            <a class="navbar-item" href="/#contact">联系方式</a>
            
            

            
            
            
            
            <a class="navbar-item" href="https://hitzhangjie.github.io/en/">English</a>
            
            

            
            
        </div>
    </nav>
    <hr>
</div>



                
    <div class="container">

        <h2 class="title is-1 top-pad strong-post-title">
            <a href="https://hitzhangjie.github.io/blog/2020-08-28-go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%87%8D%E5%90%AF/">go程序如何实现热重启</a>
        </h2>
        <div class="post-data">
            发表时间：2020-08-28 <br> 
            阅读时长：15 分钟 (7441字)
        </div>

        
        <div>
            <div>
            
            
            <p>
                标签：
                
                <a href="/tags/go">go</a>,
                
                <a href="/tags/%E7%83%AD%E9%87%8D%E5%90%AF">热重启</a>,
                
                <a href="/tags/reuseport">reuseport</a>,
                
                <a href="/tags/fd">fd</a>,
                
                <a href="/tags/unix%E5%A5%97%E6%8E%A5%E5%AD%97">unix套接字</a>
                
            </p>
            
            </div>

            <div>
            <br>
            


<div style="display:flex;">
    <div>分享：</div>
    <div>
        <div class="sharethis-inline-share-buttons"></div>
    </div>
</div>


            </div>

        </div>

        
        

        
        <div> 
            
<aside>
    <hr/>
    <header>
    <b>《go程序如何实现热重启》目录：</b>
    <br/>
    </header>
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1什么是热重启">1.什么是热重启？</a></li>
        <li><a href="#2如何实现热重启">2.如何实现热重启？</a>
          <ul>
            <li><a href="#21认识fork">2.1.认识fork</a></li>
            <li><a href="#22返回值">2.2.返回值</a></li>
            <li><a href="#23fork返回值">2.3.fork返回值</a></li>
            <li><a href="#24局限性">2.4.局限性</a></li>
          </ul>
        </li>
        <li><a href="#3单进程单线程模型">3.单进程单线程模型</a></li>
        <li><a href="#4单进程多线程模型">4.单进程多线程模型</a></li>
        <li><a href="#5-其他线程模型">5. 其他线程模型</a></li>
        <li><a href="#6-go实现热重启触发时机">6. go实现热重启：触发时机</a></li>
        <li><a href="#7-如何判断热重启">7. 如何判断热重启</a></li>
        <li><a href="#8-forkexec">8. ForkExec</a></li>
        <li><a href="#9-go实现热重启-传递listenfd">9. go实现热重启: 传递listenfd</a>
          <ul>
            <li><a href="#91-forkexecprocattrfiles-uintptr">9.1 ForkExec+ProcAttr{Files: []uintptr{}}</a></li>
            <li><a href="#92-unix-domain-socket--cmsg">9.2 unix domain socket + cmsg</a></li>
          </ul>
        </li>
        <li><a href="#10-go实现热重启-子进程如何通过listenfd重建listener">10. go实现热重启: 子进程如何通过listenfd重建listener</a></li>
        <li><a href="#11-go实现热重启父进程平滑退出">11. go实现热重启：父进程平滑退出</a>
          <ul>
            <li><a href="#111-处理已建立连接上请求">11.1. 处理已建立连接上请求</a></li>
            <li><a href="#112-消息服务">11.2. 消息服务</a></li>
            <li><a href="#112-自定义atexit清理任务">11.2. 自定义AtExit清理任务</a></li>
          </ul>
        </li>
        <li><a href="#参考文章">参考文章</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <hr/>
</aside>


        </div>
   
        
        <div class="container markdown top-pad">
            <p>最近在优化公司框架trpc时发现了一个热重启相关的问题，优化之余也总结沉淀下，对go如何实现热重启这方面的内容做一个简单的梳理。</p>
<h2 id="1什么是热重启">1.什么是热重启？</h2>
<p>热重启（Hot Restart），是一项保证服务可用性的手段。它允许服务重启期间，不中断已经建立的连接，原来的服务进程不再接受新的连接请求（也可以将连接套接字设置为读端关闭，不再接受新的请求），新的连接请求将在新的服务进程中受理。通过这种方式，可以保证已经建立的连接不中断，连接上的事务（请求、处理、响应）可以正常完成，老的服务进程等所有连接上的请求处理完毕之后，再退出，这期间新的服务进程可以正常接受连接、处理连接上的请求。当然，热重启期间进程平滑退出涉及到的不止是连接上的事务，也有消息服务、自定义事务需要关注。这是我理解的热重启的一个大致描述。</p>
<p>热重启现在还有没有存在的必要？我的理解是看场景。</p>
<p>以后台开发为例，假如运维平台有能力在服务升级、重启时自动踢掉流量，服务就绪后又自动加回流量，假如能够合理预估服务QPS、请求处理时长，那么只要配置一个合理的停止前等待时间，是可以达到类似热重启的效果的。这样的话，在后台服务里面支持热重启就显得没什么必要。但是，如果我们开发一个微服务框架，不能对将来的部署平台做这种假设，不能假设使用方一定有类似的运维平台，有可能使用方只是部署在一两台物理机上，也没有什么其他的负载均衡设施，但是也可能需要热重启的能力。</p>
<p>热重启是比较重要的一项保证服务质量的手段，还是值得了解下的，这也是本文介绍的初衷。</p>
<h2 id="2如何实现热重启">2.如何实现热重启？</h2>
<p>如何实现热重启，这里其实不能一概而论，要结合实际的场景来看。但是，大致的实现思路，可以先抛一下。</p>
<p>一般要实现热重启，大致要包括如下步骤：</p>
<ul>
<li>首先，要让老进程，这里称之为父进程了，先要fork出一个子进程来代替它执行接受连接、处理连接请求的任务；</li>
<li>然后，子进程就绪之后，通知父进程；</li>
<li>再然后，父进程处理完已建立连接上的请求后，慢慢退出。</li>
</ul>
<p>听上去是挺简单的，但是真的这么三言两语就说完了吗？No！</p>
<p>这里，和具体采用的什么编程模型也有关系，下文如无特殊提及，所列出的操作均指在Linux平台上的操作。</p>
<h3 id="21认识fork">2.1.认识fork</h3>
<p><code>fork()</code> 系统调用大家都知道，父进程调用fork会创建一个进程副本，代码中还可以通过fork返回值是否为0来区分是子进程还是父进程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv, <span style="color:#66d9ef">int</span> argc) {
    pid_t pid <span style="color:#f92672">=</span> fork();
    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        printf(<span style="color:#e6db74">&#34;i am child process&#34;</span>);
    } <span style="color:#66d9ef">else</span> {
        printf(<span style="color:#e6db74">&#34;i am parent process, i have a child process named %d&#34;</span>, pid);
    }
}
</code></pre></div><p>很多开发人员不知道fork的实现原理，或者不知道fork返回值为什么在父子进程中不同，或者不知道如何做到父子进程中返回值不同……了解这些还是要有点知识积累的。</p>
<h3 id="22返回值">2.2.返回值</h3>
<p>简单说吧，ABI往往定义了进行函数调用的一些规范，如何传递参数，如何返回值等等，以x86为例，返回值往往都是通过rax寄存器返回的，比如返回值类型是一些rax寄存器可以容纳的整数，这种好理解。</p>
<p>还有一种是寄存器位宽无法容纳的数据类型，那返回值如何存储呢？其实也简单，编译器会安插些指令来完成这些神秘的操作，具体是什么指令，就跟编译器实现相关了。</p>
<ul>
<li>可能会将返回值的地址，传递到rdi或其他寄存器，被调函数内部呢，通过多条指令将返回值写入rdi代指的内存区；</li>
<li>也可能在被调函数内部，用多个寄存器rax,rdx&hellip;一起暂存返回结果，函数返回时再将多个寄存器的值赋值到变量中；</li>
</ul>
<p>附录1中提供了一个简单的实例。</p>
<h3 id="23fork返回值">2.3.fork返回值</h3>
<p>fork系统调用的返回值，有点特殊，在父进程和子进程中，这个函数返回的值是不同的，如何做到的呢？</p>
<p>其实，你想啊，父进程调用fork的时候，操作系统内核需要干些什么呢？分配进程控制块、分配pid、分配内存空间……肯定有很多东西啦，这里注意下进程的硬件上下文信息，这些是非常重要的，在进程被调度算法选中进行调度时，是需要还原硬件上下文信息的。</p>
<p>哎，对了，就是这玩意，Linux fork的时候，会对子进程的硬件上下文进行一定的篡改，我就是让你fork之后拿到的pid是0，怎么办呢？前面2.2节提过了，对于那些小整数，rax寄存器存下绰绰有余，fork返回时就是将操作系统分配的pid放到rax寄存器的。</p>
<p>那，对于子进程而言，我只要在fork的时候将它的硬件上下文rax寄存器清0，然后等其他设置全ok后，再将其状态从不可中断等待状态修改为可运行状态，等其被调度器调度时，会先还原其硬件上下文信息，包括PC、rax等等，这样fork返回后，rax中值为0，最终赋值给pid的值就是0。</p>
<p>因此，也就可以通过这种判断 “pid是否等于0” 的方式来区分当前进程是父进程还是子进程了。</p>
<h3 id="24局限性">2.4.局限性</h3>
<p>很多人只知道fork可以创建一个进程的副本并继续往下执行，可以根据fork返回值来执行不同的分支逻辑。你再问他，如果一个进程是多线程程序，在一个线程中调用fork会复制整个进程吗？他很可能就答不上来了。</p>
<p>fork只能创建调用该函数的线程的副本，进程中其他运行的线程，fork不予处理。这就意味着，对于多线程程序而言，寄希望于通过fork来创建一个完整进程副本是不可行的。</p>
<p>前面我们也提到了，fork是实现热重启的重要一环，fork这里的这个局限性，就制约着不同服务编程模型下的热重启实现方式。所以我们说具体问题具体分析，不同编程模型下实际上可以采用不同的实现方式。</p>
<h2 id="3单进程单线程模型">3.单进程单线程模型</h2>
<p>单进程单线程模型，可能很多人一听觉得它已经被淘汰了，生产环境中绝对不能用，真的么？牛逼如redis，不就是单线程。强调下并非单线程模型没用，ok，收回来，现在关注下单进程单线程模型如何实现热重启。</p>
<p>单进程单线程，实现热重启会比较简单些:</p>
<ul>
<li>fork一下就可以创建出子进程，</li>
<li>子进程可以继承父进程中的资源，如已经打开的文件描述符，包括父进程的listenfd、connfd，</li>
<li>父进程，可以选择关闭listenfd，后续接受连接的任务就交给子进程来完成了，</li>
<li>父进程，甚至也可以关闭connfd，让子进程处理连接上的请求、回包等，也可以自身处理完已建立的连接上的请求；</li>
<li>父进程，在合适的时间点选择退出，子进程开始变成顶梁柱。</li>
</ul>
<p>核心思想就是这些，但是具体到实现，就有多种方法：</p>
<ul>
<li>可以选择fork的方式让子进程拿到原来的listenfd、connfd，</li>
<li>也可以选择unixdomain socket的方式父进程将listenfd、connfd发送给子进程。</li>
</ul>
<p>有同学可能会想，我不传递这些fd行吗？</p>
<ul>
<li>比如我开启了reuseport，父进程直接处理完已建立连接connfd上的请求之后关闭，子进程里reuseport.Listen直接创建新的listenfd。</li>
</ul>
<p>也可以！但是有些问题必须要提前告诉你：</p>
<ul>
<li>reuseport虽然允许多个进程在同一个端口上多次listen，似乎满足了要求，但是要知道只要euid相同，都可以在这个端口上listen！是不安全的！</li>
<li>reuseport实现和平台有关系，在Linux平台上在同一个address+port上listen多次，多个listenfd底层可以共享同一个连接队列，内核可以实现负载均衡，但是在darwin平台上却不会！</li>
</ul>
<p>当然这里提到的这些问题，在多线程模型下肯定也存在。</p>
<h2 id="4单进程多线程模型">4.单进程多线程模型</h2>
<p>前面提到的问题，在多线程模型中会叠加出现：</p>
<ul>
<li>fork只能复制calling thread，not whole process！</li>
<li>reuseport多次在相同地址+端口listen得到的多个fd，不同平台有不同的表现，可能无法做到接受连接时的load banlance！</li>
<li>非reuseport情况下，多次listen会失败！</li>
<li>不传递fd，直接通过reuseport来重新listen得到listenfd，不安全，不同服务进程实例可能会在同一个端口上监听，gg！</li>
<li>父进程平滑退出的逻辑，关闭listenfd，等待connfd上请求处理结束，关闭connfd，一切妥当后，父进程退出，子进程挑大梁！</li>
</ul>
<h2 id="5-其他线程模型">5. 其他线程模型</h2>
<p>其他线程都基本上避不开上述3、4的实现或者组合，对应问题相仿，不再赘述。</p>
<h2 id="6-go实现热重启触发时机">6. go实现热重启：触发时机</h2>
<p>需要选择一个时机来触发热重启，什么时候触发呢？操作系统提供了信号机制，允许进程做出一些自定义的响应。</p>
<p>杀死一个进程，一般会通过<code>kill -9</code>发送SIGKILL信号给进程，这个信号不允许捕获，SIGABORT也不允许捕获，这样可以允许进程所有者或者高权限用户控制进程生死，达到更好的管理效果。</p>
<p>kill也可以用来发送其他信号给进程，如发送SIGUSR1、SIGUSR2、SIGINT等等，进程中可以接收这些信号，并针对性的做出处理。这里可以选择SIGUSR1或者SIGUSR2来通知进程热重启。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Signal</span>, <span style="color:#ae81ff">1</span>)
    <span style="color:#a6e22e">signal</span>.<span style="color:#a6e22e">Notify</span>(<span style="color:#a6e22e">ch</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">SIGUSR2</span>)
    <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>

    <span style="color:#75715e">//接下来就可以做热重启相关的逻辑了
</span><span style="color:#75715e"></span>    <span style="color:#f92672">...</span>
}()
</code></pre></div><h2 id="7-如何判断热重启">7. 如何判断热重启</h2>
<p>那一个go程序重新启动之后，所有运行时状态信息都是新的，那我如何区分自己是否是子进程呢？或者说我是否要执行热重启逻辑呢？父进程可以通过设置子进程初始化时的环境变量，比如加个HOT_RESTART=1。</p>
<p>这就要求代码中在合适的地方要先检测环境变量HOT_RESTART是否为1，如果成立，那就执行热重启逻辑，否则就执行全新的启动逻辑。</p>
<h2 id="8-forkexec">8. ForkExec</h2>
<p>假如当前进程收到SIGUSR2信号之后，希望执行热重启逻辑，那么好，需要先执行syscall.ForkExec(&hellip;)来创建一个子进程，注意go不同于cc++，它本身就是依赖多线程来调度协程的，天然就是多线程程序，只不过是他没有使用NPTL线程库来创建，而是通过clone系统调用来创建。</p>
<p>前面提过了，如果单纯fork的话，只能复制调用fork函数的线程，对于进程中的其他线程无能为力，所以对于go这种天然的多线程程序，必须从头来一遍，再exec一下。所以go标准库提供的函数是syscall.ForkExec而不是syscall.Fork。</p>
<h2 id="9-go实现热重启-传递listenfd">9. go实现热重启: 传递listenfd</h2>
<p>go里面传递fd的方式，有这么几种，父进程fork子进程的时候传递fd，或者后面通过unix domain socket传递。需要注意的是，我们传递的实际上是file description，而非file descriptor。</p>
<p>附上一张类unix系统下file descriptor、file description、inode三者之间的关系图：
<img src="/blog/assets/restart/filedescriptor.png" alt="file descriptor"></p>
<p>fd分配都是从小到大分配的，父进程中的fd为10，传递到子进程中之后有可能就不是10。那么传递到子进程的fd是否是可以预测的呢？可以预测，但是不建议预测，所以我提供了两种实现方式。</p>
<h3 id="91-forkexecprocattrfiles-uintptr">9.1 ForkExec+ProcAttr{Files: []uintptr{}}</h3>
<p>要传递一个listenfd很简单，假如是类型net.Listener，那就通过<code>tcpln := ln.(*net.TCPListener); file, _ := tcpln.File(); fd := file.FD()</code> 来拿到listener底层file description对应的fd。</p>
<p>需要注意的是，这里的fd并非真实的file对应的初始fd，而是被dup2复制出来的一个fd，这样底层file description引用计数就会+1。如果你后面想通过ln.Close()关闭监听套接字的话，sorry，你关不掉。这里需要显示的执行 file.Close() 将原来的fd关掉，使原来的file description引用计数-1，保证Close的时候引用计数为0，才可以正常关闭。</p>
<p>试想下，我们想实现热重启，是一定要等连接上接收的请求处理完才可以退出进程的，但是这期间父进程不能再接收新的连接请求，如果这里不能正常关闭listener，那我们这个目标就无法实现。</p>
<p>OK，接下来说下syscall.ProcAttr{Files: []uintptr{}}，这里就是要传递的父进程中的fd，比如要传递stdin、stdout、stderr给子进程，就需要将这几个对应的fd塞进去os.Stdin.FD(), os.Stdout.FD(), os.Stderr.FD()，如果要想传递刚才的listenfd，就需要将上面的<code>file.FD()</code>返回的fd塞进去。</p>
<p>子进程中接收到这些fd之后，在类unix系统下一般会按照从0、1、2、3这样递增的顺序来分配fd，那么传递过去的fd是可以预测的，假如除了stdin, stdout, stderr再传两个listenfd，那么可以预测这两个的fd应该是3，4。在类unix系统下一般都是这么处理的，子进程中就可以根据传递fd的数量（比如通过环境变量传递给子进程FD_NUM=2），来从3开始计算，哦，这两个fd应该是3，4。</p>
<p>父子进程可以通过一个约定的顺序，来组织传递的listenfd的顺序，以方便子进程中按相同的约定进行处理，当然也可以通过fd重建listener之后来判断对应的监听network+address，以区分该listener对应的是哪一个逻辑service。都是可以的！</p>
<p>需要注意的是，file.FD()返回的fd是非阻塞的，在重建listener先将其设为nonblock, syscall.SetNonBlock(fd)，然后<code>file, _ := os.NewFile(fd); tcplistener := net.FileListener(file)</code>，或者是 <code>udpconn := net.PacketConn(file)</code>，然后可以获取tcplistener、udpconn的监听地址，来关联其对应的逻辑service。</p>
<p>有些微服务框架是支持对服务进行逻辑service分组的，google pb规范中也支持多service定义，这个在腾讯的goneat、trpc框架中也是有支持的。</p>
<p>当然了，这里我不会写一个完整的包含上述所有描述的demo给大家，这有点占篇幅，这里只贴一个精简版的实例，其他的读者感兴趣可以自己编码测试。须知纸上得来终觉浅，该你自己掌握的我不能效劳。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;io/ioutil&#34;</span>
	<span style="color:#e6db74">&#34;log&#34;</span>
	<span style="color:#e6db74">&#34;net&#34;</span>
	<span style="color:#e6db74">&#34;os&#34;</span>
	<span style="color:#e6db74">&#34;strconv&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;syscall&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">envRestart</span> = <span style="color:#e6db74">&#34;RESTART&#34;</span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">envListenFD</span> = <span style="color:#e6db74">&#34;LISTENFD&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#a6e22e">envRestart</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;1&#34;</span> {

		<span style="color:#a6e22e">ln</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;localhost:8888&#34;</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
			<span style="color:#66d9ef">for</span> {
				<span style="color:#a6e22e">ln</span>.<span style="color:#a6e22e">Accept</span>()
			}
		}()

		<span style="color:#a6e22e">tcpln</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ln</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPListener</span>)
		<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tcpln</span>.<span style="color:#a6e22e">File</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Setenv</span>(<span style="color:#a6e22e">envRestart</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Setenv</span>(<span style="color:#a6e22e">envListenFD</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Fd</span>()))

		<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">ForkExec</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">ProcAttr</span>{
			<span style="color:#a6e22e">Env</span>:   <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Environ</span>(),
			<span style="color:#a6e22e">Files</span>: []<span style="color:#66d9ef">uintptr</span>{<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Fd</span>()},
			<span style="color:#a6e22e">Sys</span>:   <span style="color:#66d9ef">nil</span>,
		})
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;parent pid:&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getpid</span>(), <span style="color:#e6db74">&#34;, pass fd:&#34;</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Fd</span>())
		<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>()
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()

	} <span style="color:#66d9ef">else</span> {

		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#a6e22e">envListenFD</span>)
		<span style="color:#a6e22e">fd</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseInt</span>(<span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;child pid:&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getpid</span>(), <span style="color:#e6db74">&#34;, recv fd:&#34;</span>, <span style="color:#a6e22e">fd</span>)

		<span style="color:#75715e">// test1
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// NOTE: 理解上面提及的file descriptor、file description的关系
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 通过环境变量肯定是不行的，fd根本不对应子进程中的fd
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//ff := os.NewFile(uintptr(fd), &#34;&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//if ff != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	_, err := ff.Stat()
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	if err != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//		log.Println(err)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	}
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// test2
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// 假定我们知道fd是多少，比如fd=3
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ff</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">NewFile</span>(uintptr(<span style="color:#ae81ff">3</span>), <span style="color:#e6db74">&#34;&#34;</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;fd:&#34;</span>, <span style="color:#a6e22e">ff</span>.<span style="color:#a6e22e">Fd</span>())
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ff</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ff</span>.<span style="color:#a6e22e">Stat</span>()
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				panic(<span style="color:#a6e22e">err</span>)
			}

			<span style="color:#75715e">// pause, lsof -P -p $pid，检查下有没有listenfd传过来，除了0，1，2，应该有看到3
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// ctrl+d to continue
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>)

			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;....&#34;</span>)
			<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">FileListener</span>(<span style="color:#a6e22e">ff</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				panic(<span style="color:#a6e22e">err</span>)
			}

			<span style="color:#75715e">// pause, lsof -P -p $pid, 会发现有两个listenfd, 
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 因为前面调用了ff.FD() dup2了一个，如果这里不显示关闭，listener将无法关闭
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ff</span>.<span style="color:#a6e22e">Close</span>()

			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>)
		}

		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>)
	}
}
</code></pre></div><p>这里用最简单的代码，大致解释了如何用ProcAttr来传递listenfd。这里有个缺点，加入后续父进程中将传递的fd修改了呢，比如我不传stdin, stdout, stderr的fd了，咋治？服务端是不是要开始预测应该从0开始编号了？其实这里的预测有点挫，在类unix平台下虽然可以比较可靠的预测出来fd，但毕竟也算是个hack逻辑。</p>
<p>私以为这种实现有点丑，不推荐。</p>
<h3 id="92-unix-domain-socket--cmsg">9.2 unix domain socket + cmsg</h3>
<p>另一种，思路就是通过unix domain socket + cmsg来传递，父进程启动的时候依然是通过ForkExec来创建子进程，但是并不通过ProcAttr来传递listenfd。</p>
<p>父进程在创建子进程之前，创建一个unix domain socket并监听，等子进程启动之后，建立到这个unix domain socket的连接，父进程此时开始将listenfd通过cmsg发送给子进程，获取fd的方式与9.1相同，该注意的fd关闭问题也是一样的处理。</p>
<p>子进程连接上unix domain socket，开始接收cmsg，内核帮子进程收消息的时候，发现里面有一个父进程的fd，内核找到对应的file description，并为子进程分配一个fd，将两者建立起映射关系。然后回到子进程中的时候，子进程拿到的就是对应该file description的fd了。通过os.NewFile(fd)就可以拿到file，然后再通过net.FileListener或者net.PacketConn就可以拿到tcplistener或者udpconn。</p>
<p>剩下的获取监听地址，关联逻辑service的动作，就与9.1小结描述的一致了。</p>
<p>这里我也提供一个可运行的精简版的demo，供大家了解、测试用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;io/ioutil&#34;</span>
	<span style="color:#e6db74">&#34;log&#34;</span>
	<span style="color:#e6db74">&#34;net&#34;</span>
	<span style="color:#e6db74">&#34;os&#34;</span>
	<span style="color:#e6db74">&#34;strconv&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;syscall&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>

	<span style="color:#a6e22e">passfd</span> <span style="color:#e6db74">&#34;github.com/ftrvxmtrx/fd&#34;</span>
)

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">envRestart</span> = <span style="color:#e6db74">&#34;RESTART&#34;</span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">envListenFD</span> = <span style="color:#e6db74">&#34;LISTENFD&#34;</span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unixsockname</span> = <span style="color:#e6db74">&#34;/tmp/xxxxxxxxxxxxxxxxx.sock&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#a6e22e">envRestart</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;1&#34;</span> {

		<span style="color:#a6e22e">ln</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;localhost:8888&#34;</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
			<span style="color:#66d9ef">for</span> {
				<span style="color:#a6e22e">ln</span>.<span style="color:#a6e22e">Accept</span>()
			}
		}()

		<span style="color:#a6e22e">tcpln</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ln</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPListener</span>)
		<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tcpln</span>.<span style="color:#a6e22e">File</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Setenv</span>(<span style="color:#a6e22e">envRestart</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Setenv</span>(<span style="color:#a6e22e">envListenFD</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Fd</span>()))

		<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">ForkExec</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">ProcAttr</span>{
			<span style="color:#a6e22e">Env</span>:   <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Environ</span>(),
			<span style="color:#a6e22e">Files</span>: []<span style="color:#66d9ef">uintptr</span>{<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>.<span style="color:#a6e22e">Fd</span>(), <span style="color:#75715e">/*f.Fd()*/</span>}, <span style="color:#75715e">// comment this when test unixsock
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">Sys</span>:   <span style="color:#66d9ef">nil</span>,
		})
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;parent pid:&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getpid</span>(), <span style="color:#e6db74">&#34;, pass fd:&#34;</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Fd</span>())

		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Remove</span>(<span style="color:#a6e22e">unixsockname</span>)
		<span style="color:#a6e22e">unix</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;unix&#34;</span>, <span style="color:#a6e22e">unixsockname</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">unixconn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unix</span>.<span style="color:#a6e22e">Accept</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">passfd</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">unixconn</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">UnixConn</span>), <span style="color:#a6e22e">f</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>()
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()

	} <span style="color:#66d9ef">else</span> {

		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getenv</span>(<span style="color:#a6e22e">envListenFD</span>)
		<span style="color:#a6e22e">fd</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseInt</span>(<span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;child pid:&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getpid</span>(), <span style="color:#e6db74">&#34;, recv fd:&#34;</span>, <span style="color:#a6e22e">fd</span>)

		<span style="color:#75715e">// test1
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// 通过环境变量肯定是不行的，fd根本不对应子进程中的fd
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//ff := os.NewFile(uintptr(fd), &#34;&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//if ff != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	_, err := ff.Stat()
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	if err != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//		log.Println(err)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	}
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// test2
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// 假定我们知道fd是多少，比如fd=3
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//ff := os.NewFile(uintptr(3), &#34;&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//if ff != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	_, err := ff.Stat()
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	if err != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//		panic(err)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	}
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	// pause, ctrl+d to continue
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	ioutil.ReadAll(os.Stdin)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	fmt.Println(&#34;....&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	_, err = net.FileListener(ff) //会dup一个fd出来，有多个listener
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	if err != nil {
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//		panic(err)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	}
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	// lsof -P -p $pid, 会发现有两个listenfd
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//	time.Sleep(time.Minute)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">// test 3
</span><span style="color:#75715e"></span>
		<span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;.....&#34;</span>) <span style="color:#75715e">// lsof -P -p $pid，检查下
</span><span style="color:#75715e"></span>
		<span style="color:#a6e22e">unixconn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;unix&#34;</span>, <span style="color:#a6e22e">unixsockname</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">files</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">passfd</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">unixconn</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">UnixConn</span>), <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">nil</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			panic(<span style="color:#a6e22e">err</span>)
		}

		<span style="color:#75715e">// lsof -P -p $pid再检查下
</span><span style="color:#75715e"></span>
		<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">files</span>[<span style="color:#ae81ff">0</span>]
		<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Stat</span>()

		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>)
	}
}
</code></pre></div><h2 id="10-go实现热重启-子进程如何通过listenfd重建listener">10. go实现热重启: 子进程如何通过listenfd重建listener</h2>
<p>前面已经提过了，当你已经拿到fd之后，你还不知道他对应的是tcp的listener，还是udpconn，那怎么办？都试下呗。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">NewFile</span>(<span style="color:#a6e22e">fd</span>)
<span style="color:#75715e">// check error
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">tcpln</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">FileListener</span>(<span style="color:#a6e22e">file</span>)
<span style="color:#75715e">// check error
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">udpconn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">PacketConn</span>(<span style="color:#a6e22e">file</span>)
<span style="color:#75715e">// check error
</span></code></pre></div><h2 id="11-go实现热重启父进程平滑退出">11. go实现热重启：父进程平滑退出</h2>
<p>父进程如何平滑退出呢，这个要看父进程中都有哪些逻辑要平滑停止了。</p>
<h3 id="111-处理已建立连接上请求">11.1. 处理已建立连接上请求</h3>
<p>可以从这两个方面入手：</p>
<ul>
<li>shutdown read，不再接受新的请求，对端继续写数据的时候回感知到失败</li>
<li>继续处理请求，处理完成后，回包，close连接</li>
</ul>
<p>也可以考虑连接空闲一段时间后close，但是尽最大速度关闭更好一点。</p>
<h3 id="112-消息服务">11.2. 消息服务</h3>
<ul>
<li>确认下自己服务的消息消费、确认机制是否合理</li>
<li>不再收新消息</li>
<li>处理完已收到的消息后，再退出</li>
</ul>
<h3 id="112-自定义atexit清理任务">11.2. 自定义AtExit清理任务</h3>
<p>有些任务会有些自定义任务，希望进程在退出之前，能够执行到，这种最好提供一各类似AtExit的注册函数，让进程退出之前能够执行业务自定义的逻辑。</p>
<p>不管是平滑重启，还是其他正常退出，&hellip;</p>
<h2 id="参考文章">参考文章</h2>
<ol>
<li>Unix高级编程、进程间通信, Steven Richards</li>
<li>&hellip;</li>
</ol>

        </div>
        

        
        <hr>
        <div style="float:right;">
        


<div style="display:flex;">
    <div>分享：</div>
    <div>
        <div class="sharethis-inline-share-buttons"></div>
    </div>
</div>


        </div>

        <br>
        <br>

    </div>

    
    
    <br>
    <br>
    <div style="height:auto;align:center;text-align:center;"> 
        <div>
            <img src="/common/xiaoqi.png" style="height:238px;margin-top:10px;margin-right:5px;"/>
            <img src="/common/qrcode.jpg" style="height:238px;margin-top:10px;"/>
            <img src="/common/yuanbao.png" style="height:238px;margin-top:10px;margin-left:5px;"/>
        </div>

        <div>
            <p>
                感谢打赏，小七🐶、元宝🐱可以改善伙食咯 😘
            </p>
        </div>


    </div>
    

    


                
                <div class="container">
    <hr>
</div>
<div class="container has-text-centered top-pad">
    <a href="#top">
        <i class="fa fa-arrow-up"></i>
    </a>
</div>

<div class="container">
    <hr>
</div>

                <div class="section" id="footer">
    <div class="container has-text-centered">
    
        <span class="footer-text">
            <a href="https://github.com/victoriadrake/hugo-theme-introduction/"><strong>Introduction</strong></a> 主题为 <a href="http://gohugo.io/">Hugo</a> 而设。由开源社群贡献者以 <a href="https://victoria.dev"><i class="fa fa-heart"></i> 和 <i class="fa fa-coffee"></i></a> 创造。
        </span>
    
    </div>
</div>

                
            </div>
        </section>
        
        





<script src="https://hitzhangjie.github.io/js/bundle.23f18222425179f754965a36c9b211bd8cff5e5ab61ee23b52f026cef6699139.js" integrity="sha256-I/GCIkJRefdUllo2ybIRvYz/Xlq2HuI7UvAmzvZpkTk="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168027530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




        
        
        
        
    </body>
</html>
