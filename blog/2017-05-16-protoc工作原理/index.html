<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Web站点描述">
<title>
Protoc工作原理分析 - 介绍
</title>









        <meta property="og:title" content="Protoc工作原理分析 - 介绍" />
<meta property="og:type" content="website" />
<meta property="og:description" content="Web站点描述"/>
<meta property="og:url" content="https://hitzhangjie.github.io/blog/2017-05-16-protoc%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
<meta property="og:site_name" content="介绍"/>




<meta property="og:image" content="https://hitzhangjie.github.io/home/me.jpg"/>

<meta property="og:image" content="https://hitzhangjie.github.io/home/profile.jpg"/>




        
<link rel="shortcut icon" href="/img/fav.ico">


        





<link rel="stylesheet" href="/css/main.min.5c5478bdd5363758f3e73657d5339b1ac7c131a401ffc3338edd7eb5e1a0114e.css" integrity="sha256-XFR4vdU2N1jz5zZX1TObGsfBMaQB/8Mzjt1&#43;teGgEU4=" crossorigin="anonymous" media="screen">




    <link rel="stylesheet" href="/custom.css" integrity="" crossorigin="anonymous" media="screen">

        
        
        
        
    </head>
    <body>
        <section id="top" class="section">
            
            <div class="container hero  fade-in one ">
                

    <h1 class="bold-title is-1">博客</h1>


            </div>
            
            <div class="section  fade-in two ">
                
<div class="container">
    <hr>
    <nav class="navbar" role="navigation" aria-label="main navigation">
        
        <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
        <div class="navbar-menu " id="navMenu">
            
            
            
            
            <a class="navbar-item" href="/">主页</a>
            

            
            

            
                
            

            
                
            

            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.github.io/projects/">
                  
                  项目
                  
                  </a>
                
                
            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.github.io/blog/">
                  
                  返回 博客
                  
                  </a>
                
                
            
            
            
            
            
            <a class="navbar-item" href="/#about">关于</a>
            
            
            
            
            
            <a class="navbar-item" href="/#thanks">致谢</a>
            
            
            
            

            
            
            <a class="navbar-item" href="/#contact">联系方式</a>
            
            

            
            
            
            
            <a class="navbar-item" href="https://hitzhangjie.github.io/en/">English</a>
            
            

            
            
        </div>
    </nav>
    <hr>
</div>



                
    <div class="container">

        <h2 class="title is-1 top-pad strong-post-title">
            <a href="https://hitzhangjie.github.io/blog/2017-05-16-protoc%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Protoc工作原理分析</a>
        </h2>
        <div class="post-data">
            发表时间：2017-05-19 <br> 
            阅读时长：31 分钟 (6586字)
        </div>

        <p>
            
<div class="blog-share">
    分享：
    
    <a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Protoc%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%20https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fab fa-twitter"></i>
        <span class="hidden">Twitter</span>
    </a>
    
    
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f"  onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="fab fa-facebook-f"></i>
        <span class="hidden">Facebook</span>
    </a>
    
    
    <a class="icon-pinterest" href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f&amp;description=Protoc%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90" onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
        <i class="fab fa-pinterest-p"></i>
        <span class="hidden">Pinterest</span>
    </a>
    
    
    <a class="icon-google-plus" href="https://plus.google.com/share?url=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <i class="fab fa-google-plus-g"></i>
        <span class="hidden">Google+</span>
    </a>
    
</div>



        </p>

        
        
        <p>
            标签：
            
            <a href="/tags/protoc">protoc</a>,
            
            <a href="/tags/protoc-gen-go">protoc-gen-go</a>,
            
            <a href="/tags/protobuf">protobuf</a>
            
        </p>
        

        
        <div> 
            
<aside>
    <hr/>
    <header>
    <b>《Protoc工作原理分析》目录：</b>
    <br/>
    </header>
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-protoc源代码准备">1. protoc源代码准备</a></li>
        <li><a href="#2-protoc源码分析">2. protoc源码分析</a>
          <ul>
            <li><a href="#21-protoc程序入口">2.1. protoc程序入口</a></li>
            <li><a href="#22-protoc命令行接口定义">2.2. protoc命令行接口定义</a></li>
            <li><a href="#23-protoc执行流程说明">2.3. protoc执行流程说明</a>
              <ul>
                <li><a href="#231-protoc完成基本的初始化工作后调用clirunargcargv开始生成代码">2.3.1. protoc完成基本的初始化工作后调用cli.Run(argc,argv)开始生成代码</a></li>
                <li><a href="#232-protoc命令接口clirunargcargv详细处理流程">2.3.2. protoc命令接口cli.Run(argc,argv)详细处理流程</a></li>
                <li><a href="#233-protoc执行逻辑总结">2.3.3. protoc执行逻辑总结</a></li>
              </ul>
            </li>
            <li><a href="#24-protoc插件开发">2.4. protoc插件开发</a>
              <ul>
                <li><a href="#241-protoc中的descriptor定义">2.4.1. protoc中的descriptor定义</a></li>
                <li><a href="#242-可以提取proto文件中的哪些信息--如何提取">2.4.2. 可以提取proto文件中的哪些信息 &amp; 如何提取</a></li>
                <li><a href="#243-protoc-go语言插件protoc-gen-go">2.4.3. protoc go语言插件protoc-gen-go</a></li>
                <li><a href="#2431-protoc-gen-go入口函数分析">2.4.3.1. protoc-gen-go入口函数分析</a></li>
                <li><a href="#2432-回顾一下codegeneratorrequest--codegeneratorresponse的定义">2.4.3.2. 回顾一下CodeGeneratorRequest &amp; CodeGeneratorResponse的定义</a></li>
                <li><a href="#2433-generator实现分析">2.4.3.3. generator实现分析</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    <hr/>
</aside>


        </div>
   
        
        <div class="container markdown top-pad">
            <p>在进行protoc插件开发之前，首先要了解protoc的工作原理。在protobuf的使用过程中，protoc作为proto文件的编译器，很多开发人员只会用但是不了解其工作原理，更不了解如何扩展其功能。protobuf作为目前常用的数据交换格式在协议开发中被广泛采用，此外，protoc对proto文件的强大解析能力使我们可以开发一些插件，通过插件快速生成特定于proto文件的工具类、配置文件等，从而提高开发效率。</p>
<p>本文首先会介绍一下protoc的整体工作机制，然后解释一下protoc对proto文件的解析过程，最后给出编写protoc插件扩展protoc功能的一个示例教程。</p>
<h2 id="1-protoc源代码准备">1. protoc源代码准备</h2>
<p>要想了解protoc的工作机制，查看其源代码了解其核心流程是最靠谱的方法。</p>
<p>获取程序源代码的方式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">git co https:<span style="color:#75715e">//github.com/google/protobuf
</span></code></pre></div><p>由于我们工程中常用的protoc版本是v2.5.0，所以这里检出对应版本的tag。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">git ck v2<span style="color:#ae81ff">.5.0</span>
</code></pre></div><p>考虑到可能会进行测试、修改、注释等学习过程，这里最好创建一个新的分支来操作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">git branch <span style="color:#960050;background-color:#1e0010">$</span>{new<span style="color:#f92672">-</span>branch<span style="color:#f92672">-</span>name}
git ck <span style="color:#960050;background-color:#1e0010">$</span>{new<span style="color:#f92672">-</span>branch<span style="color:#f92672">-</span>name}
</code></pre></div><p>现在源代码准备好了，我比较喜欢使用vim、ctags、cscope来阅读源码，根据个人习惯吧，下面可以阅读protoc的源码梳理以下工作机制。</p>
<h2 id="2-protoc源码分析">2. protoc源码分析</h2>
<p>上述git检出后的protobuf路径，记为${protobuf}，后面如果出现${protobuf}请知晓其含义。如果在描述源代码时没有提及起始路径${protobuf}，那么起始路径均为${protobuf}。</p>
<h3 id="21-protoc程序入口">2.1. protoc程序入口</h3>
<p>src/google/protobuf/compiler/main.cc中的main函数，为protoc的入口函数。</p>
<p>file: src/google/protobuf/compiler/main.cc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Author: kenton@google.com (Kenton Varda)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这个头文件定义了protoc的命令行接口
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/command_line_interface.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// protoc中内置了对cpp、python、java语言的支持，对其他语言的支持需要以plugin的方式来支持
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/cpp/cpp_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/python/python_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/java/java_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {

  <span style="color:#75715e">// 初始化protoc命令行接口并开启插件
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 插件只是普通的可执行程序，其文件名以AllowPlugins参数protoc-开头
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 假定protoc --foo_out，那么实际调用的插件是protoc-foo
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>CommandLineInterface cli;
  cli.AllowPlugins(<span style="color:#e6db74">&#34;protoc-&#34;</span>);

  <span style="color:#75715e">// Proto2 C++ (指定了--cpp_out将调用cpp::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>cpp<span style="color:#f92672">::</span>CppGenerator cpp_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--cpp_out&#34;</span>, <span style="color:#e6db74">&#34;--cpp_opt&#34;</span>, <span style="color:#f92672">&amp;</span>cpp_generator,
                        <span style="color:#e6db74">&#34;Generate C++ header and source.&#34;</span>);

  <span style="color:#75715e">// Proto2 Java (指定了--java_out将调用java::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>java<span style="color:#f92672">::</span>JavaGenerator java_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--java_out&#34;</span>, <span style="color:#f92672">&amp;</span>java_generator,
                        <span style="color:#e6db74">&#34;Generate Java source file.&#34;</span>);

  <span style="color:#75715e">// Proto2 Python (指定了python_out将调用python::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>python<span style="color:#f92672">::</span>Generator py_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--python_out&#34;</span>, <span style="color:#f92672">&amp;</span>py_generator,
                        <span style="color:#e6db74">&#34;Generate Python source file.&#34;</span>);

  <span style="color:#75715e">// 解析proto、生成源代码(借助内置的generator或者plugins)、创建源代码文件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> cli.Run(argc, argv);
}
</code></pre></div><h3 id="22-protoc命令行接口定义">2.2. protoc命令行接口定义</h3>
<p>下面看一下protoc的命令行接口定义，以了解其对命令行flags、options的解释过程以及对后续程序执行逻辑的影响。</p>
<p>file: src/google/protobuf/compiler/command_line_interface.h</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Author: kenton@google.com (Kenton Varda)
</span><span style="color:#75715e">//  Based on original Protocol Buffers design by
</span><span style="color:#75715e">//  Sanjay Ghemawat, Jeff Dean, and others.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Implements the Protocol Compiler front-end such that it may be reused by
</span><span style="color:#75715e">// custom compilers written to support other languages.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifndef GOOGLE_PROTOBUF_COMPILER_COMMAND_LINE_INTERFACE_H__
</span><span style="color:#75715e">#define GOOGLE_PROTOBUF_COMPILER_COMMAND_LINE_INTERFACE_H__
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/stubs/common.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
namespace google {
namespace protobuf {

<span style="color:#75715e">//proto文件中定义的数据类型可通过FileDescriptor来遍历、查看
</span><span style="color:#75715e"></span>class FileDescriptor;        <span style="color:#75715e">// descriptor.h
</span><span style="color:#75715e"></span>class DescriptorPool;        <span style="color:#75715e">// descriptor.h
</span><span style="color:#75715e"></span>class FileDescriptorProto;   <span style="color:#75715e">// descriptor.pb.h
</span><span style="color:#75715e"></span>template<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> class RepeatedPtrField;  <span style="color:#75715e">// repeated_field.h
</span><span style="color:#75715e"></span>
namespace compiler {

class CodeGenerator;        <span style="color:#75715e">// code_generator.h
</span><span style="color:#75715e"></span>class GeneratorContext;     <span style="color:#75715e">// code_generator.h
</span><span style="color:#75715e"></span>class DiskSourceTree;       <span style="color:#75715e">// importer.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这个类实现了protoc的命令行接口，使得protoc很容易扩展。
</span><span style="color:#75715e">// 例如我们想让protoc既支持cpp又支持另一种语言foo，那么我们可以定义一个实现了
</span><span style="color:#75715e">// CodeGenerator接口的FooGenerator，然后在protoc的main方法中对这两种语言cpp、Foo
</span><span style="color:#75715e">// 及其对应的CodeGenerator进行注册。
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//   int main(int argc, char* argv[]) {
</span><span style="color:#75715e">//     google::protobuf::compiler::CommandLineInterface cli;
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//     // 支持cpp
</span><span style="color:#75715e">//     google::protobuf::compiler::cpp::CppGenerator cpp_generator;
</span><span style="color:#75715e">//     cli.RegisterGenerator(&#34;--cpp_out&#34;, &amp;cpp_generator, &#34;Generate C++ source and header.&#34;);
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//     // 支持foo
</span><span style="color:#75715e">//     FooGenerator foo_generator;
</span><span style="color:#75715e">//     cli.RegisterGenerator(&#34;--foo_out&#34;, &amp;foo_generator, &#34;Generate Foo file.&#34;);
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//     return cli.Run(argc, argv);
</span><span style="color:#75715e">//   }
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// The compiler is invoked with syntax like:
</span><span style="color:#75715e">//   protoc --cpp_out=outdir --foo_out=outdir --proto_path=src src/foo.proto
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// For a full description of the command-line syntax, invoke it with --help.
</span><span style="color:#75715e"></span>class LIBPROTOC_EXPORT CommandLineInterface {
 public:
  CommandLineInterface();
  <span style="color:#f92672">~</span>CommandLineInterface();

  <span style="color:#75715e">// 为某种编程语言注册一个对应的代码生成器（其实这里也不一定非得是语言）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 命令行接口的参数:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param flag_name 指定输出文件类型的命令，例如--cpp_out，参数名字必须以“-”开头，
</span><span style="color:#75715e"></span>                      <span style="color:#960050;background-color:#1e0010">如果名字大于两个字符，则必须以“</span><span style="color:#f92672">--</span><span style="color:#960050;background-color:#1e0010">”开头。</span>
  <span style="color:#75715e">// @param generator 与flag_name对应的CodeGenerator接口实现
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param help_text 执行protoc --help的时候对这里的flag_name的说明性信息
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 某些代码生成器可接受额外参数，这些参数在输出路径之前给出，与输出路径之间用“:”分隔。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   protoc --foo_out=enable_bar:outdir
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里的:outdir之前的enable_bar被作为参数传递给CodeGenerator::Generate()的参数。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> RegisterGenerator(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> flag_name,
                         CodeGenerator<span style="color:#f92672">*</span> generator,
                         <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> help_text);

  <span style="color:#75715e">// 为某种编程语言注册一个对应的代码生成器
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param option_flag_name 指定额外的选项
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 与前面一个函数RegisterGenerator所不同的是，这个重载函数多个参数
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// option_flag_name，通过这个函数注册的语言和代码生成器可以接受额外的参数。例
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如通过command_line_interface.RegisterGenerator(&#34;--foo_out&#34;, &#34;--foo_opt&#34;, ...)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 注册了foo以及对应代码生成器，那么我们可以在执行protoc 的时候指定额外的参数
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// --foo_opt：protoc --foo_out=enable_bar:outdir --foo_opt=enable_baz，此时传
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 递给代码生成器的参数将会包括enable_bar和enable_baz。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RegisterGenerator</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> flag_name,
                         <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> option_flag_name,
                         CodeGenerator<span style="color:#f92672">*</span> generator,
                         <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> help_text);

  <span style="color:#75715e">// RegisterGenerator方法是在protoc的main方法中进行语言、代码生成器的注册，在
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 生产环境中不可能允许开发人员肆意修改公用程序库，这意味着我们如果要在稳定地
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// protoc v2.5.0基础上进行源码的修改这条路是行不通的，那么如何自由地扩展其功
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 能呢？protoc提供了“plugin”机制，我们可以通过自定义插件来实现对其他语言
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//（甚至不是语言）的支持。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 开启protoc对插件的支持，这种模式下，如果一个命令行选项以_out结尾，例如
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// --xxx_out，但是在protoc已经注册的语言支持中没有找到匹配的语言及代码生成器，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这个时候protoc就会去检查是否有匹配的插件支持这种语言，将这个插件来作为代
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 码生成器使用。这里的的protoc插件是一个$PATH中可搜索到的可执行程序，当然
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这个可执行程序稍微有点特殊。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里插件名称（可执行程序名称）是如何确定的呢？选项--xxx_out中，截取“xxx”，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 然后根据${exe_name_prefix}以及xxx来拼接出一个插件的名字，假如${exe_name_prefix}
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 是protoc-，那么插件的名字就是protoc-xxx，protoc将尝试执行这个程序来完成代
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 码生成的工作。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 假定插件的名字是plugin，protoc是这样调用这个插件的：
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   plugin [--out=OUTDIR] [--parameter=PARAMETER] PROTO_FILES &lt; DESCRIPTORS
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 选项说明：
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// --out：指明了插件代码生成时的输出目录（跟通过--foo_out传递给protoc的一样）,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//        如果省略这个参数，输出目录就是当前目录。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// --parameter：指明了传递给代码生成器的参数。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// PROTO_FILES：指明了protoc调用时传递给protoc的待处理的.proto文件列表。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// DESCRIPTORS: 编码后的FileDescriptorSet（这个在descriptor.proto中定义），
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里编码后的数据通过管道重定向到插件的标准输入，这里的FileDescriptorSet包括
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// PROTO_FILES中列出的所有proto文件的descriptors，也包括这些PROTO_FILES中
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// proto文件import进来的其他proto文件。插件不应该直接读取PROTO_FILES中的
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// proto文件，而应该使用这里的DESCRIPTORS。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 插件跟protoc main函数中注册的代码生成器一样，它也需要生成所有必须的文件。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 插件会将所有要生成的文件的名字写到stdout，插件名字是相对于当前输出目录的。如
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 果插件工作过程中发生了错误，需要将错误信息写到stderr，如果发生了严重错误，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 插件应该退出并返回一个非0的返回码。插件写出的数据会被protoc读取并执行后续
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 处理逻辑。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AllowPlugins</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> exe_name_prefix);

  <span style="color:#75715e">// 根据指定的命令行参数来执行protocol compiler，返回值将由main返回。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Run()方法是非线程安全的，因为其中调用了strerror()，不要在多线程环境下使用。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Run</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> argv[]);

  <span style="color:#75715e">// proto路径解析的控制说明，fixme
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Call SetInputsAreCwdRelative(true) if the input files given on the command
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// line should be interpreted relative to the proto import path specified
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// using --proto_path or -I flags.  Otherwise, input file names will be
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// interpreted relative to the current working directory (or as absolute
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// paths if they start with &#39;/&#39;), though they must still reside inside
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// a directory given by --proto_path or the compiler will fail.  The latter
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// mode is generally more intuitive and easier to use, especially e.g. when
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// defining implicit rules in Makefiles.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetInputsAreProtoPathRelative</span>(<span style="color:#66d9ef">bool</span> enable) {
    inputs_are_proto_path_relative_ <span style="color:#f92672">=</span> enable;
  }

  <span style="color:#75715e">// 设置执行protoc --version时打印的版本相关的信息，这行版本信息的下一行也会打印libprotoc的版本。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetVersionInfo</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> text) {
    version_info_ <span style="color:#f92672">=</span> text;
  }


 private:
  <span style="color:#75715e">// -----------------------------------------------------------------
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 这个类的后续部分代码，虽然也比较重要，但是即便在这里先不解释，也不会给我
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 们的理解造成太多干扰，为了简化篇幅并且避免过早地陷入细节而偏离对整体的把
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 握，这里我先把这个类的后续部分代码进行删减……只保留相对比较重要的。
</span><span style="color:#75715e"></span>
  class GeneratorContextImpl;
  class MemoryOutputStream;

  <span style="color:#75715e">// 清楚上次Run()运行时设置的状态
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Clear</span>();

  <span style="color:#75715e">// 映射input_files_中的每个文件，使其变成相对于proto_path_中对应目录的相对路径
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 当inputs_are_proto_path_relative_为false的时候才会调用这个函数；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 出错返回false，反之返回true；
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">MakeInputsBeProtoPathRelative</span>(DiskSourceTree<span style="color:#f92672">*</span> source_tree);

  <span style="color:#75715e">// ParseArguments() &amp; InterpretArgument()返回的状态
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> ParseArgumentStatus {
    PARSE_ARGUMENT_DONE_AND_CONTINUE,
    PARSE_ARGUMENT_DONE_AND_EXIT,
    PARSE_ARGUMENT_FAIL
  };

  <span style="color:#75715e">// 解析所有的命令行参数
</span><span style="color:#75715e"></span>  ParseArgumentStatus <span style="color:#a6e22e">ParseArguments</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> argv[]);

  <span style="color:#75715e">// 解析某个命令行参数
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 参数名放name，参数值放value
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 如果argv中的下一个参数应该被当做value则返回true，反之返回false
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ParseArgument</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> arg, string<span style="color:#f92672">*</span> name, string<span style="color:#f92672">*</span> value);

  <span style="color:#75715e">// 解析某个命令行参数的状态
</span><span style="color:#75715e"></span>  ParseArgumentStatus <span style="color:#a6e22e">InterpretArgument</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> name, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> value);

  <span style="color:#75715e">// 从输入的proto文件生成指定的源代码文件
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> OutputDirective;

  <span style="color:#75715e">// 对解析成功的每个proto文件，生成对应的源代码文件
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param parsed_files 解析成功的proto文件vector
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param output_directive 输出指示，包括了文件名、语言、代码生成器、输出目录
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param generator_context 代码生成器上下文，可记录待输出文件名、文件内容、尺寸等信息
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">GenerateOutput</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;&amp;</span> parsed_files,
                      <span style="color:#66d9ef">const</span> OutputDirective<span style="color:#f92672">&amp;</span> output_directive,
                      GeneratorContext<span style="color:#f92672">*</span> generator_context);

  <span style="color:#75715e">// 对解析成功的每个proto文件，调用protoc插件生成对应的源代码
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param parsed_files 解析成功的proto文件vector
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param plugin_name 插件的名称，命名方式一般是protoc-gen-${lang}
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param parameter 传递给protoc插件的参数
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param generator_context 代码生成器上下文，可记录待输出文件名、文件内容、尺寸等信息
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @param error 错误信息
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">GeneratePluginOutput</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;&amp;</span> parsed_files,
                            <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> plugin_name,
                            <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> parameter,
                            GeneratorContext<span style="color:#f92672">*</span> generator_context,
                            string<span style="color:#f92672">*</span> error);

  <span style="color:#75715e">// 编码、解码，实现命令行中的--encode和--decode选项
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">EncodeOrDecode</span>(<span style="color:#66d9ef">const</span> DescriptorPool<span style="color:#f92672">*</span> pool);

  <span style="color:#75715e">// 实现命令行中的--descriptor_set_out选项
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">WriteDescriptorSet</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;</span> parsed_files);

  <span style="color:#75715e">// 获取指定proto文件依赖的proto文件列表（列表中包括该proto文件本身）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - proto文件通过FileDescriptorProto表示；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 这些依赖的proto文件列表会被重新排序，被依赖的proto会被排在依它的proto前面,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   这样我们就可以调用DescriptorPool::BuildFile()来建立最终的源代码文件；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - already_seen中已经列出的proto文件不会被重复添加，每一个被添加的proto文件都被加入到already_seen中；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 如果include_source_code_info为true，则包括源代码信息到FileDescriptorProtos中；
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetTransitiveDependencies</span>(<span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*</span> file,
                                        <span style="color:#66d9ef">bool</span> include_source_code_info,
                                        set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;*</span> already_seen,
                                        RepeatedPtrField<span style="color:#f92672">&lt;</span>FileDescriptorProto<span style="color:#f92672">&gt;*</span> output);

  <span style="color:#75715e">// -----------------------------------------------------------------
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 当前被调用的程序的名称，argv[0]
</span><span style="color:#75715e"></span>  string executable_name_;

  <span style="color:#75715e">// 通过SetVersionInfo()设置的版本信息
</span><span style="color:#75715e"></span>  string version_info_;

  <span style="color:#75715e">// 注册的代码生成器
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> GeneratorInfo {
    string flag_name;           <span style="color:#75715e">// --foo_out
</span><span style="color:#75715e"></span>    string option_flag_name;    <span style="color:#75715e">// --foo_opt
</span><span style="color:#75715e"></span>    CodeGenerator<span style="color:#f92672">*</span> generator;   <span style="color:#75715e">// 对应的代码生成器
</span><span style="color:#75715e"></span>    string help_text;           <span style="color:#75715e">// protoc --help时输出的--foo_out的帮助信息
</span><span style="color:#75715e"></span>  };

  <span style="color:#66d9ef">typedef</span> map<span style="color:#f92672">&lt;</span>string, GeneratorInfo<span style="color:#f92672">&gt;</span> GeneratorMap;
  <span style="color:#75715e">// flag_name、代码生成器map
</span><span style="color:#75715e"></span>  GeneratorMap generators_by_flag_name_;
  <span style="color:#75715e">// option_name、代码生成器map
</span><span style="color:#75715e"></span>  GeneratorMap generators_by_option_name_;

  <span style="color:#75715e">// flag_name、option map
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 如果调用protoc --foo_out=outputdir --foo_opt=enable_bar ...，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   map中将包括一个&lt;--foo_out,enable_bar&gt; entry.
</span><span style="color:#75715e"></span>  map<span style="color:#f92672">&lt;</span>string, string<span style="color:#f92672">&gt;</span> generator_parameters_;

  <span style="color:#75715e">// protoc插件前缀，如果该变量为空，那么不允许使用插件
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// @see AllowPlugins()
</span><span style="color:#75715e"></span>  string plugin_prefix_;

  <span style="color:#75715e">// 将protoc插件名称映射为具体的插件可执行文件
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 执行一个插件可执行程序时，首先搜索这个map，如果找到则直接执行；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 如果这个map中找不到匹配的插件可执行程序，则搜索PATH寻找可执行程序执行；
</span><span style="color:#75715e"></span>  map<span style="color:#f92672">&lt;</span>string, string<span style="color:#f92672">&gt;</span> plugins_;

  <span style="color:#75715e">// protoc命令行中指定的工作模式
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> Mode {
    MODE_COMPILE,  <span style="color:#75715e">// Normal mode:  parse .proto files and compile them.
</span><span style="color:#75715e"></span>    MODE_ENCODE,   <span style="color:#75715e">// --encode:  read text from stdin, write binary to stdout.
</span><span style="color:#75715e"></span>    MODE_DECODE    <span style="color:#75715e">// --decode:  read binary from stdin, write text to stdout.
</span><span style="color:#75715e"></span>  };

  Mode mode_;

  vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span>string, string<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> proto_path_;  <span style="color:#75715e">// Search path for proto files.
</span><span style="color:#75715e"></span>  vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> input_files_;                <span style="color:#75715e">// Names of the input proto files.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// protoc调用时每个--${lang}_out都对应着一个OutputDirective
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> OutputDirective {
    string name;                <span style="color:#75715e">// flag_name，E.g. &#34;--foo_out&#34;
</span><span style="color:#75715e"></span>    CodeGenerator<span style="color:#f92672">*</span> generator;   <span style="color:#75715e">// 为NULL则表示使用protoc插件而非内置的代码生成器
</span><span style="color:#75715e"></span>    string parameter;           <span style="color:#75715e">// 传递给代码生成器或者protoc插件的参数
</span><span style="color:#75715e"></span>    string output_location;     <span style="color:#75715e">// 源代码文件输出目录
</span><span style="color:#75715e"></span>  };
  <span style="color:#75715e">// 一次protoc调用可能会同时制定多个--${lang}_out选项
</span><span style="color:#75715e"></span>  vector<span style="color:#f92672">&lt;</span>OutputDirective<span style="color:#f92672">&gt;</span> output_directives_;

  <span style="color:#75715e">// 当使用--encode或者--decode的时候，codec_type_指明了encode或者decode的类型
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 如果codec_type_为空则表示--decode_raw类型;
</span><span style="color:#75715e"></span>  string codec_type_;

  <span style="color:#75715e">// 如果指定了--descriptor_set_out选项，FileDescriptorSet将被输出到指定的文件
</span><span style="color:#75715e"></span>  string descriptor_set_name_;

  <span style="color:#75715e">// 如果指定了--include-imports那么所有的依赖proto都要写到DescriptorSet；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如果未指定，则只把命令行中列出的proto文件写入；
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> imports_in_descriptor_set_;

  <span style="color:#75715e">// 如果指定--include_source_info为true，则不能从DescriptorSet中删除SourceCodeInfo
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> source_info_in_descriptor_set_;

  <span style="color:#75715e">// --disallow_services_这个选项有被使用吗？
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> disallow_services_;

  <span style="color:#75715e">// See SetInputsAreProtoPathRelative().
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> inputs_are_proto_path_relative_;

  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CommandLineInterface);
};

}  <span style="color:#75715e">// namespace compiler
</span><span style="color:#75715e"></span>}  <span style="color:#75715e">// namespace protobuf
</span><span style="color:#75715e"></span>
}  <span style="color:#75715e">// namespace google
</span><span style="color:#75715e"></span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// GOOGLE_PROTOBUF_COMPILER_COMMAND_LINE_INTERFACE_H__
</span></code></pre></div><h3 id="23-protoc执行流程说明">2.3. protoc执行流程说明</h3>
<p>protoc执行流程的相关源码，主要包括如下两个部分。</p>
<h4 id="231-protoc完成基本的初始化工作后调用clirunargcargv开始生成代码">2.3.1. protoc完成基本的初始化工作后调用cli.Run(argc,argv)开始生成代码</h4>
<p>这部分内容在前面已经有过较为详细的解释，这里不再详细展开，只给出相应的代码、注释。</p>
<p>file: src/google/protobuf/compiler/main.cc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Author: kenton@google.com (Kenton Varda)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这个头文件定义了protoc的命令行接口
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/command_line_interface.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// protoc中内置了对cpp、python、java语言的支持，对其他语言的支持需要以plugin的方式来支持
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/cpp/cpp_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/python/python_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;google/protobuf/compiler/java/java_generator.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {

  <span style="color:#75715e">// 初始化protoc命令行接口并开启插件
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 插件只是普通的可执行程序，其文件名以AllowPlugins参数protoc-开头
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 假定protoc --foo_out，那么实际调用的插件是protoc-foo
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>CommandLineInterface cli;
  cli.AllowPlugins(<span style="color:#e6db74">&#34;protoc-&#34;</span>);

  <span style="color:#75715e">// Proto2 C++ (指定了--cpp_out将调用cpp::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>cpp<span style="color:#f92672">::</span>CppGenerator cpp_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--cpp_out&#34;</span>, <span style="color:#e6db74">&#34;--cpp_opt&#34;</span>, <span style="color:#f92672">&amp;</span>cpp_generator,
                        <span style="color:#e6db74">&#34;Generate C++ header and source.&#34;</span>);

  <span style="color:#75715e">// Proto2 Java (指定了--java_out将调用java::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>java<span style="color:#f92672">::</span>JavaGenerator java_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--java_out&#34;</span>, <span style="color:#f92672">&amp;</span>java_generator,
                        <span style="color:#e6db74">&#34;Generate Java source file.&#34;</span>);

  <span style="color:#75715e">// Proto2 Python (指定了python_out将调用python::Generator)
</span><span style="color:#75715e"></span>  google<span style="color:#f92672">::</span>protobuf<span style="color:#f92672">::</span>compiler<span style="color:#f92672">::</span>python<span style="color:#f92672">::</span>Generator py_generator;
  cli.RegisterGenerator(<span style="color:#e6db74">&#34;--python_out&#34;</span>, <span style="color:#f92672">&amp;</span>py_generator,
                        <span style="color:#e6db74">&#34;Generate Python source file.&#34;</span>);

  <span style="color:#66d9ef">return</span> cli.Run(argc, argv);
}
</code></pre></div><h4 id="232-protoc命令接口clirunargcargv详细处理流程">2.3.2. protoc命令接口cli.Run(argc,argv)详细处理流程</h4>
<p>这部分代码是protoc对proto文件进行读取、解析、通过注册的代码生成器或者protoc插件生成源代码、保存源代码到源文件的执行流程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> CommandLineInterface<span style="color:#f92672">::</span>Run(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> argv[]) {
  Clear();
  <span style="color:#66d9ef">switch</span> (ParseArguments(argc, argv)) {
    <span style="color:#66d9ef">case</span> PARSE_ARGUMENT_DONE_AND_EXIT:     <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">case</span> PARSE_ARGUMENT_FAIL:              <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">case</span> PARSE_ARGUMENT_DONE_AND_CONTINUE: <span style="color:#66d9ef">break</span>;
  }

  <span style="color:#75715e">// Set up the source tree.
</span><span style="color:#75715e"></span>  DiskSourceTree source_tree;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> proto_path_.size(); i<span style="color:#f92672">++</span>) {
    source_tree.MapPath(proto_path_[i].first, proto_path_[i].second);
  }

  <span style="color:#75715e">// Map input files to virtual paths if necessary.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>inputs_are_proto_path_relative_) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>MakeInputsBeProtoPathRelative(<span style="color:#f92672">&amp;</span>source_tree)) {
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
  }

  <span style="color:#75715e">// Allocate the Importer.
</span><span style="color:#75715e"></span>  ErrorPrinter error_collector(error_format_, <span style="color:#f92672">&amp;</span>source_tree);
  Importer <span style="color:#a6e22e">importer</span>(<span style="color:#f92672">&amp;</span>source_tree, <span style="color:#f92672">&amp;</span>error_collector);

  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;</span> parsed_files;

  <span style="color:#75715e">// Parse each file.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> input_files_.size(); i<span style="color:#f92672">++</span>) {
    <span style="color:#75715e">// Import the file.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*</span> parsed_file <span style="color:#f92672">=</span> importer.Import(input_files_[i]);
    <span style="color:#66d9ef">if</span> (parsed_file <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    parsed_files.push_back(parsed_file);

    <span style="color:#75715e">// Enforce --disallow_services.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (disallow_services_ <span style="color:#f92672">&amp;&amp;</span> parsed_file<span style="color:#f92672">-&gt;</span>service_count() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
      cerr <span style="color:#f92672">&lt;&lt;</span> parsed_file<span style="color:#f92672">-&gt;</span>name() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: This file contains services, but &#34;</span>
              <span style="color:#e6db74">&#34;--disallow_services was used.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
  }

  <span style="color:#75715e">// We construct a separate GeneratorContext for each output location.  Note
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// that two code generators may output to the same location, in which case
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// they should share a single GeneratorContext so that OpenForInsert() works.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> hash_map<span style="color:#f92672">&lt;</span>string, GeneratorContextImpl<span style="color:#f92672">*&gt;</span> GeneratorContextMap;
  GeneratorContextMap output_directories;

  <span style="color:#75715e">// Generate output.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (mode_ <span style="color:#f92672">==</span> MODE_COMPILE) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> output_directives_.size(); i<span style="color:#f92672">++</span>) {
      string output_location <span style="color:#f92672">=</span> output_directives_[i].output_location;
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>HasSuffixString(output_location, <span style="color:#e6db74">&#34;.zip&#34;</span>) <span style="color:#f92672">&amp;&amp;</span>
          <span style="color:#f92672">!</span>HasSuffixString(output_location, <span style="color:#e6db74">&#34;.jar&#34;</span>)) {
        AddTrailingSlash(<span style="color:#f92672">&amp;</span>output_location);
      }
      GeneratorContextImpl<span style="color:#f92672">**</span> map_slot <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>output_directories[output_location];

      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>map_slot <span style="color:#f92672">==</span> NULL) {
        <span style="color:#75715e">// First time we&#39;ve seen this output location.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>map_slot <span style="color:#f92672">=</span> new GeneratorContextImpl(parsed_files);
      }

      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GenerateOutput(parsed_files, output_directives_[i], <span style="color:#f92672">*</span>map_slot)) {
        STLDeleteValues(<span style="color:#f92672">&amp;</span>output_directories);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
    }
  }

  <span style="color:#75715e">// Write all output to disk.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (GeneratorContextMap<span style="color:#f92672">::</span>iterator iter <span style="color:#f92672">=</span> output_directories.begin();
       iter <span style="color:#f92672">!=</span> output_directories.end(); <span style="color:#f92672">++</span>iter) {
    <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> location <span style="color:#f92672">=</span> iter<span style="color:#f92672">-&gt;</span>first;
    GeneratorContextImpl<span style="color:#f92672">*</span> directory <span style="color:#f92672">=</span> iter<span style="color:#f92672">-&gt;</span>second;
    <span style="color:#66d9ef">if</span> (HasSuffixString(location, <span style="color:#e6db74">&#34;/&#34;</span>)) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>directory<span style="color:#f92672">-&gt;</span>WriteAllToDisk(location)) {
        STLDeleteValues(<span style="color:#f92672">&amp;</span>output_directories);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">if</span> (HasSuffixString(location, <span style="color:#e6db74">&#34;.jar&#34;</span>)) {
        directory<span style="color:#f92672">-&gt;</span>AddJarManifest();
      }

      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>directory<span style="color:#f92672">-&gt;</span>WriteAllToZip(location)) {
        STLDeleteValues(<span style="color:#f92672">&amp;</span>output_directories);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
    }
  }

  STLDeleteValues(<span style="color:#f92672">&amp;</span>output_directories);

  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>descriptor_set_name_.empty()) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>WriteDescriptorSet(parsed_files)) {
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
  }

  <span style="color:#66d9ef">if</span> (mode_ <span style="color:#f92672">==</span> MODE_ENCODE <span style="color:#f92672">||</span> mode_ <span style="color:#f92672">==</span> MODE_DECODE) {
    <span style="color:#66d9ef">if</span> (codec_type_.empty()) {
      <span style="color:#75715e">// HACK:  Define an EmptyMessage type to use for decoding.
</span><span style="color:#75715e"></span>      DescriptorPool pool;
      FileDescriptorProto file;
      file.set_name(<span style="color:#e6db74">&#34;empty_message.proto&#34;</span>);
      file.add_message_type()<span style="color:#f92672">-&gt;</span>set_name(<span style="color:#e6db74">&#34;EmptyMessage&#34;</span>);
      GOOGLE_CHECK(pool.BuildFile(file) <span style="color:#f92672">!=</span> NULL);
      codec_type_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;EmptyMessage&#34;</span>;
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>EncodeOrDecode(<span style="color:#f92672">&amp;</span>pool)) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>EncodeOrDecode(importer.pool())) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
    }
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="233-protoc执行逻辑总结">2.3.3. protoc执行逻辑总结</h4>
<p>通过查看上面两部分代码及其他关键代码，可以对protoc的执行流程进行一个简单的总结了：</p>
<ol>
<li>
<p>protoc main中初始化命令行参数接口cli;</p>
</li>
<li>
<p>protoc 中开启protoc-前缀的插件作为第三方代码生成器使用cli.AllowPlugins(&ldquo;protoc-&quot;)；</p>
</li>
<li>
<p>protoc main中注册编程语言cpp、java、python及对应的代码生成器，cli.RegisterGenerator(&hellip;)，原生支持cpp、java、python；</p>
</li>
<li>
<p>protoc main中cli.Run(argc, argv)，运行注册的代码生成器或者protoc插件;</p>
<ul>
<li>Clear()清空所有的数据备用；</li>
<li>ParseArguments(argc,argv)解析参数，对于protoc的某些内置参数的检查，对某些插件相关的&ndash;${lang}_out参数的检查等，将&ndash;${lang}_out作为输出指令保存起来；
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  <span style="color:#66d9ef">struct</span> OutputDirective {
    string name;                <span style="color:#75715e">// E.g. &#34;--foo_out&#34;
</span><span style="color:#75715e"></span>    CodeGenerator<span style="color:#f92672">*</span> generator;   <span style="color:#75715e">// NULL for plugins
</span><span style="color:#75715e"></span>    string parameter;
    string output_location;
  };
</code></pre></div></li>
<li>参数解析成功之后，继续执行处理，设置源代码树、映射输入文件到虚拟路径、分配importer；</li>
<li>针对每个输入的proto文件进行解析，const FileDescriptor* parsed_file = importer.Import(input_files_[i])，解析成功后的文件会被加入到vector&lt;FileDescriptor*&gt; parsed_files中记录，每一个proto文件解析后都可以用一个FileDescriptor结构体来表示；</li>
</ul>
<blockquote>
<p>备注：<br>
这里解析proto文件的过程是这样的，首先将proto文件中的内容分割成一个个的token，将内容拆分成一个个词素并检查有效性，也就是词法分析。如果词法分析检查无误则进入后续的语法分析过程，parser对输入token串进行文法相关的分析检查是否可以构成一棵有效的语法分析树，如果可以则表示语法正确。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  <span style="color:#75715e">// Token定义如下
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> Token {
    TokenType type;
    string text;       <span style="color:#75715e">// The exact text of the token as it appeared in
</span><span style="color:#75715e"></span>                       <span style="color:#75715e">// the input.  e.g. tokens of TYPE_STRING will still
</span><span style="color:#75715e"></span>                       <span style="color:#75715e">// be escaped and in quotes.
</span><span style="color:#75715e"></span>   
    <span style="color:#75715e">// &#34;line&#34; and &#34;column&#34; specify the position of the first character of
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the token within the input stream.  They are zero-based.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> line;
    <span style="color:#66d9ef">int</span> column;
    <span style="color:#66d9ef">int</span> end_column;
  };

  <span style="color:#75715e">// Token类型定义如下
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> TokenType {
    TYPE_START,       <span style="color:#75715e">// Next() has not yet been called.
</span><span style="color:#75715e"></span>    TYPE_END,         <span style="color:#75715e">// End of input reached.  &#34;text&#34; is empty.
</span><span style="color:#75715e"></span>   
    TYPE_IDENTIFIER,  <span style="color:#75715e">// A sequence of letters, digits, and underscores, not
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// starting with a digit.  It is an error for a number
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// to be followed by an identifier with no space in
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// between.
</span><span style="color:#75715e"></span>    TYPE_INTEGER,     <span style="color:#75715e">// A sequence of digits representing an integer.  Normally
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// the digits are decimal, but a prefix of &#34;0x&#34; indicates
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// a hex number and a leading zero indicates octal, just
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// like with C numeric literals.  A leading negative sign
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// is NOT included in the token; it&#39;s up to the parser to
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// interpret the unary minus operator on its own.
</span><span style="color:#75715e"></span>    TYPE_FLOAT,       <span style="color:#75715e">// A floating point literal, with a fractional part and/or
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// an exponent.  Always in decimal.  Again, never
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// negative.
</span><span style="color:#75715e"></span>    TYPE_STRING,      <span style="color:#75715e">// A quoted sequence of escaped characters.  Either single
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// or double quotes can be used, but they must match.
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// A string literal cannot cross a line break.
</span><span style="color:#75715e"></span>    TYPE_SYMBOL,      <span style="color:#75715e">// Any other printable character, like &#39;!&#39; or &#39;+&#39;.
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// Symbols are always a single character, so &#34;!+$%&#34; is
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// four tokens.
</span><span style="color:#75715e"></span>  };

</code></pre></div><p>语法分析的过程这里就不解释了，感兴趣的可以看一下protobuf中grammar的定义，无非也就是些规约的事情，只要能够按照grammar将词法分析输出的token串构建出一棵完整的语法分析树proto文件就是合法的，否则就是不合法的，至于语法分析过程中伴随的语义分析过程，语义分析过程中执行哪些语义动作，不说也知道，肯定是生成某些“中间代码”之类的鬼东西。学过编译原理的这些处理过程应该都是比较清楚的，这里就不再展开了。语法分析成功之后就得到了proto对应的FileDescriptor对象，因为可能输入的是多个proto，所以多个FileDescriptor就用vector来存储了。</p>
<ul>
<li>遍历之前记录下来的输出指令OutputDirective output_directives[]，output_directives[i].output_location指明了输出目录，针对输出目录创建GeneratorContextImpl，并记录到hash_map&lt;string, GeneratorContextImpl<em>&gt; output_directories这个map中，key为flag_out,如&ndash;foo_out，value为GeneratorContextImpl。由于可能多个&ndash;${lang}_out都指向相同的输出目录，所以同一个GeneratorContextImpl也存在复用的情况。每个GeneratorContextImpl记录了一个输出目录、所有该目录下的待创建的源代码文件的信息，待创建的源代码文件信息记录在map&lt;string,string</em>&gt; files_里面，key为源代码文件名，val为源代码文件的内容，另外还包括了一个vector&lt;FileDescriptor*&gt; parsed_files记录了所有解析成功的proto文件信息。<br>
遍历output_directives的同时，因为同一个output_directives[i]对应的输出目录下可能有多个源代码文件要输出，并且不管flag_name是什么，要处理的proto文件都是相同的，所以每个output_directives[i]都会对其调用<strong>GenerateOutput</strong>(parsed_files, output_directives[i], *map_slot)，output_directives[i].plugin指明了语言的代码生成器(为NULL则使用插件)，对所有的解析成功的proto文件parsed_files[i]生成源代码，源代码全部输出到output_directive[i].output_location下，源代码的文件名都记录在parsed_files[i].name()里面，而最终生成的源代码信息都存储在这里的CodeGeneratorImpl **map_slot中，也就相当于存储在了output_directories[]中。</li>
<li>最后遍历output_directories[]，将每个输出目录下要写的所有文件的数据全部写出到磁盘，即output_directories[i]-&gt;WriteAllToDisk()。</li>
<li>done！</li>
</ul>
</li>
</ol>
<p>了解从proto到源代码生成的关键之处就是这里的GenerateOutput是怎么实现的，接着看。</p>
<h5 id="2331-protoc-commandlineinterfacegenerateoutput实现">2.3.3.1 protoc CommandLineInterface::GenerateOutput(&hellip;)实现</h5>
<p>下面看下GenerateOutput方法到底执行了哪些操作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 根据输出指示, 为解析成功的proto文件调用代码生成器生成对应的代码并存储到generator_context
</span><span style="color:#75715e">//@param parsed_files 所有解析成功的proto文件，每个解析成功的proto文件都用一个FileDescriptor来表示
</span><span style="color:#75715e">//@param output_directive 输出指示，其指明了目标语言、语言对应的代码生成器、输出目录等
</span><span style="color:#75715e">//@param generator_context 代码生成器上下文，可记录生成的代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> CommandLineInterface<span style="color:#f92672">::</span>GenerateOutput(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;&amp;</span> parsed_files,
                                          <span style="color:#66d9ef">const</span> OutputDirective<span style="color:#f92672">&amp;</span> output_directive,
                                          GeneratorContext<span style="color:#f92672">*</span> generator_context) {
  <span style="color:#75715e">// Call the generator.
</span><span style="color:#75715e"></span>  string error;

  <span style="color:#75715e">// 如果输出指示中没有设置对应的代码生成器，表明没有在protoc main中注册语言对应的代码生成器，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这种需要protoc通过插件机制，通过调用对应的插件来充当代码生成器的功能。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (output_directive.generator <span style="color:#f92672">==</span> NULL) {
    <span style="color:#75715e">// This is a plugin.
</span><span style="color:#75715e"></span>    GOOGLE_CHECK(HasPrefixString(output_directive.name, <span style="color:#e6db74">&#34;--&#34;</span>) <span style="color:#f92672">&amp;&amp;</span>
          HasSuffixString(output_directive.name, <span style="color:#e6db74">&#34;_out&#34;</span>))
        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Bad name for plugin generator: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> output_directive.name;

    <span style="color:#75715e">// 实际上protoc搜索插件对应的可执行程序的时候，搜索的名称是“protoc-gen-”+“语言”，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果我们调用的是protoc --xxx_out，那么实际搜索的就是protoc-gen-xxx。
</span><span style="color:#75715e"></span>    string plugin_name <span style="color:#f92672">=</span> plugin_prefix_ <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;gen-&#34;</span> <span style="color:#f92672">+</span>
        output_directive.name.substr(<span style="color:#ae81ff">2</span>, output_directive.name.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">6</span>);

    <span style="color:#75715e">// 调用protoc插件来生成代码，这是我们要重点看的，我们就是要实现自己的protoc插件
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GeneratePluginOutput(parsed_files, plugin_name, output_directive.parameter, generator_context, <span style="color:#f92672">&amp;</span>error)) {
      cerr <span style="color:#f92672">&lt;&lt;</span> output_directive.name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> error <span style="color:#f92672">&lt;&lt;</span> endl;
      <span style="color:#66d9ef">return</span> false;
    }
  } <span style="color:#66d9ef">else</span> {
    
    <span style="color:#75715e">// 这种是protoc main函数中正常注册的语言和代码生成器
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Regular generator.
</span><span style="color:#75715e"></span>    string parameters <span style="color:#f92672">=</span> output_directive.parameter;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>generator_parameters_[output_directive.name].empty()) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parameters.empty()) {
        parameters.append(<span style="color:#e6db74">&#34;,&#34;</span>);
      }
      parameters.append(generator_parameters_[output_directive.name]);
    }

    <span style="color:#75715e">// 为每个解析成功的proto文件生成代码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> parsed_files.size(); i<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>output_directive.generator<span style="color:#f92672">-&gt;</span>Generate(parsed_files[i], parameters, generator_context, <span style="color:#f92672">&amp;</span>error)) {
        <span style="color:#75715e">// Generator returned an error.
</span><span style="color:#75715e"></span>        cerr <span style="color:#f92672">&lt;&lt;</span> output_directive.name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> parsed_files[i]<span style="color:#f92672">-&gt;</span>name() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> error <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> false;
      }
    }
  }

  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><h5 id="2332-protoc调用插件生成代码的执行逻辑">2.3.3.2. protoc调用插件生成代码的执行逻辑</h5>
<p>下面再来看一下GeneratePluginOutput是如何工作的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 调用protoc插件为解析成功的proto文件生成代码
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//@param parsed_files 解析成功的文件
</span><span style="color:#75715e">//@param plugin_name protoc插件名称（这个是拼接出来的protoc-gen-${lang}）
</span><span style="color:#75715e">//@param parameter 传给插件的参数
</span><span style="color:#75715e">//@param generator_context 代码生成器上下文，可记录生成的代码
</span><span style="color:#75715e">//@param error 代码生成过程中的错误信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> CommandLineInterface<span style="color:#f92672">::</span>GeneratePluginOutput(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;&amp;</span> parsed_files,
                                                <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> plugin_name,
                                                <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> parameter,
                                                GeneratorContext<span style="color:#f92672">*</span> generator_context,
                                                string<span style="color:#f92672">*</span> error) {
  <span style="color:#75715e">// protoc生成一个代码生成请求，并发送给插件
</span><span style="color:#75715e"></span>  CodeGeneratorRequest request;

  <span style="color:#75715e">// protoc插件根据接收到的代码生成请求生成代码，并发送响应给protoc
</span><span style="color:#75715e"></span>  CodeGeneratorResponse response;

  <span style="color:#75715e">// Build the request.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parameter.empty()) {
    request.set_parameter(parameter);
  }

  set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> FileDescriptor<span style="color:#f92672">*&gt;</span> already_seen;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> parsed_files.size(); i<span style="color:#f92672">++</span>) {
    request.add_file_to_generate(parsed_files[i]<span style="color:#f92672">-&gt;</span>name());
    GetTransitiveDependencies(parsed_files[i],
                              true,  <span style="color:#75715e">// Include source code info.
</span><span style="color:#75715e"></span>                              <span style="color:#f92672">&amp;</span>already_seen, request.mutable_proto_file());
  }

  <span style="color:#75715e">// fork出一个子进程，子进程来执行插件完成代码生成工作，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 父子进程之间是通过管道通信完成请求、响应过程，如何控制子进程的stdin、stdout，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这个可以通过dup2或者dup3来控制间fd 0、1分别设置到管道的读端、写端。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 事实上protobuf的开发人员也是这么来实现的。
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Invoke the plugin.
</span><span style="color:#75715e"></span>  Subprocess subprocess;

  <span style="color:#66d9ef">if</span> (plugins_.count(plugin_name) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
    subprocess.Start(plugins_[plugin_name], Subprocess<span style="color:#f92672">::</span>EXACT_NAME);
  } <span style="color:#66d9ef">else</span> {
    subprocess.Start(plugin_name, Subprocess<span style="color:#f92672">::</span>SEARCH_PATH);
  }

  string communicate_error;

  <span style="color:#75715e">// 请求插件生成代码
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>subprocess.Communicate(request, <span style="color:#f92672">&amp;</span>response, <span style="color:#f92672">&amp;</span>communicate_error)) {
    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> strings<span style="color:#f92672">::</span>Substitute(<span style="color:#e6db74">&#34;$0: $1&#34;</span>, plugin_name, communicate_error);
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#75715e">// Write the files.  We do this even if there was a generator error in order
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// to match the behavior of a compiled-in generator.
</span><span style="color:#75715e"></span>  scoped_ptr<span style="color:#f92672">&lt;</span>io<span style="color:#f92672">::</span>ZeroCopyOutputStream<span style="color:#f92672">&gt;</span> current_output;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> response.file_size(); i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">const</span> CodeGeneratorResponse<span style="color:#f92672">::</span>File<span style="color:#f92672">&amp;</span> output_file <span style="color:#f92672">=</span> response.file(i);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>output_file.insertion_point().empty()) {

      <span style="color:#75715e">// 首先关闭当前正在写入的文件数据（用CodeGeneratorResponse表示）
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 打开待写入的文件数据，这个文件数据已经存在，定位到准确的插入点位置执行写入，然后关闭文件
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// - 这里的插入点如何定义，我们在后面再进行说明。具体可参考plugin.proto和plugin.pb.h。
</span><span style="color:#75715e"></span>      current_output.reset();

      <span style="color:#75715e">// OpenForInsert返回一个输出流，以方便后面写入编码后数据
</span><span style="color:#75715e"></span>      current_output.reset(generator_context<span style="color:#f92672">-&gt;</span>OpenForInsert(output_file.name(), output_file.insertion_point()));

    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>output_file.name().empty()) {

      <span style="color:#75715e">// 首先关闭当前正在写入的文件数据（用CodeGeneratorResponse表示）
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 打开待写入的文件数据，这个文件数据不存在，不存在插入点信息，从开始处执行写入
</span><span style="color:#75715e"></span>      current_output.reset();
      
      <span style="color:#75715e">// OpenForInsert返回一个输出流，以方便后面写入编码后数据
</span><span style="color:#75715e"></span>      current_output.reset(generator_context<span style="color:#f92672">-&gt;</span>Open(output_file.name()));

    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (current_output <span style="color:#f92672">==</span> NULL) {

      <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> strings<span style="color:#f92672">::</span>Substitute(
        <span style="color:#e6db74">&#34;$0: First file chunk returned by plugin did not specify a file name.&#34;</span>,
        plugin_name);
      <span style="color:#66d9ef">return</span> false;

    }

    <span style="color:#75715e">// 从CodeGeneratorResponse中获取输出流，写出，这里输出流中的数据时存储在GeneratorContextImpl中的，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// GenerateOutput调用成功之后后面会遍历每一个GenerateContextImpl完成WriteAllToDisk()的操作。
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Use CodedOutputStream for convenience; otherwise we&#39;d need to provide
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// our own buffer-copying loop.
</span><span style="color:#75715e"></span>    io<span style="color:#f92672">::</span>CodedOutputStream writer(current_output.get());
    writer.WriteString(output_file.content());
  }

  <span style="color:#75715e">// Check for errors.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>response.error().empty()) {
    <span style="color:#75715e">// Generator returned an error.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> response.error();
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#66d9ef">return</span> true;
}

</code></pre></div><h5 id="2333-protoc--protoc插件数据交互的执行逻辑">2.3.3.3. protoc &amp; protoc插件数据交互的执行逻辑</h5>
<p>整体执行逻辑差不多理清楚了，然后这里我们需要看一下父进程给子进程发送的代码生成请求是什么，收到的代码生成的响应又是什么，以及父子进程通信的细节、子进程对请求的处理过程等。</p>
<p>先来看下plugin.proto的定义，protoc内置的支持语言里面并不包含go，我们后面需要用go来编写我们自己的插件，所以必须使用protoc的go插件来生成go对应的plugin.go代码，然后我们自己写一些业务类插件（非语言插件）的时候才能用上plugin.go。扯这么多是为了让大家明白这里为什么需要看下plugin.proto，而不是误解为只是在堆砌内容。看了这里的plugin.proto之后才能理解到protoc中的插件机制的边界时什么，我们就可以明白利用protoc的插件机制，我们可以做到什么程度，哪些功能能实现，哪些实现不了，这个是很重要的。</p>
<p>file: src/google/protobuf/compiler/plugin.proto</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// protoc (aka the Protocol Compiler) can be extended via plugins.  A plugin is
</span><span style="color:#75715e">// just a program that reads a CodeGeneratorRequest from stdin and writes a
</span><span style="color:#75715e">// CodeGeneratorResponse to stdout.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Plugins written using C++ can use google/protobuf/compiler/plugin.h instead
</span><span style="color:#75715e">// of dealing with the raw protocol defined here.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// A plugin executable needs only to be placed somewhere in the path.  The
</span><span style="color:#75715e">// plugin should be named &#34;protoc-gen-$NAME&#34;, and will then be used when the
</span><span style="color:#75715e">// flag &#34;--${NAME}_out&#34; is passed to protoc.
</span><span style="color:#75715e"></span>
package google.protobuf.compiler;
option java_package <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;com.google.protobuf.compiler&#34;</span>;
option java_outer_classname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PluginProtos&#34;</span>;

import <span style="color:#e6db74">&#34;google/protobuf/descriptor.proto&#34;</span>;

<span style="color:#75715e">// 发送给插件的代码生成请求
</span><span style="color:#75715e">// An encoded CodeGeneratorRequest is written to the plugin&#39;s stdin.
</span><span style="color:#75715e"></span>message CodeGeneratorRequest {
  <span style="color:#75715e">// The .proto files that were explicitly listed on the command-line.  The
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// code generator should generate code only for these files.  Each file&#39;s
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// descriptor will be included in proto_file, below.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">//proto文件列表对应的要生成的文件的源代码文件的名字
</span><span style="color:#75715e"></span>  repeated string file_to_generate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 

  <span style="color:#75715e">// The generator parameter passed on the command-line.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//传递给插件代码生成器的参数
</span><span style="color:#75715e"></span>  optional string parameter <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;        

  <span style="color:#75715e">// FileDescriptorProtos for all files in files_to_generate and everything
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// they import.  The files will appear in topological order, so each file
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// appears before any file that imports it.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// protoc guarantees that all proto_files will be written after
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the fields above, even though this is not technically guaranteed by the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// protobuf wire format.  This theoretically could allow a plugin to stream
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// in the FileDescriptorProtos and handle them one by one rather than read
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the entire set into memory at once.  However, as of this writing, this
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// is not similarly optimized on protoc&#39;s end -- it will store all fields in
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// memory at once before sending them to the plugin.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 每一个正确解析的proto文件都用一个FileDescriptorProto来表示；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里的FileDescriptorProto与FileDescriptor其实是对应的，在请求插件进行代码
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 生成的时候直接就有这样的代码FileDescriptor::CopyTo(FileDescriptorProto&amp;)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 的用法。而在descriptor.h和descriptor.proto中查看二者的描述时，其注释清清
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 楚楚地写着都是描述的一个完整的proto文件。
</span><span style="color:#75715e"></span>  repeated FileDescriptorProto proto_file <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>; 
}

<span style="color:#75715e">// 插件返回的代码生成响应
</span><span style="color:#75715e">// The plugin writes an encoded CodeGeneratorResponse to stdout.
</span><span style="color:#75715e"></span>message CodeGeneratorResponse {
  <span style="color:#75715e">// Error message.  If non-empty, code generation failed.  The plugin process
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// should exit with status code zero even if it reports an error in this way.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// This should be used to indicate errors in .proto files which prevent the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// code generator from generating correct code.  Errors which indicate a
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// problem in protoc itself -- such as the input CodeGeneratorRequest being
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// unparseable -- should be reported by writing a message to stderr and
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// exiting with a non-zero status code.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 错误信息
</span><span style="color:#75715e"></span>  optional string error <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// Represents a single generated file.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 生成的源代码文件消息类型，注意这里是一个内部类型
</span><span style="color:#75715e"></span>  message File {
    <span style="color:#75715e">// 待生成的源代码文件名（相对于输出目录），文件名中不能包括.或者..，路径是
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 相对输出目录的路径，不能用绝对路径，另分隔符必须用/。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果name没有指定，那么输出的内容将追加到前一个输出的源代码文件中，这种
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 方式使得代码生成器能够将一个大文件的生成分多次写入来完成，不用一次性将很
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 大数据量的数据放在内存中。这里需要指出的是，protoc中并没有针对这种情况
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  进行特殊的优化，它等待读取完整的CodeGeneratorResponse再写出到磁盘。
</span><span style="color:#75715e"></span>    optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">// 如果insertion_point不空的话，name字段也不能为空，并且假定name字段指定的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 文件已经存在了。这里的内容将被插入到name指定的文件中的特定插入点（注解）的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 上一行。这有助于扩展代码生成器输出的内容。在一次protoc调用中，可能会同
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 时指定多个protoc插件，前面的插件可能会在输出的内容中指定插入点，后面的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 插件可能会在这些指定的插入点的位置继续扩展代码内容。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 例如，前面的一个插件在输出的代码内容中增加了这样一行注解：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   @@protoc_insertion_point(NAME)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这样就定义了一个插入点，插入点前面、后面可以包含任意的文本内容，即使在
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注释里面也是可以的。这里的插入点定义中的NAME应该可以唯一标识一个插入点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 才可以，类似于标识符，以供其他的插件使用，插件插入代码的时候将从插入点
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 的上一行开始自行插入。如果包含多个插入点的话，插入点的内容将被插件依次
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 扩展。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 一开始创建这个源代码文件的代码生成器或者插件与后面的继续扩展源代码插入
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 点位置内容的代码生成器或者插件，必须在protoc的同一次调用中，代码生成器
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 或者插件按照protoc命令行调用过程中指定的顺序依次调用。
</span><span style="color:#75715e"></span>    optional string insertion_point <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

    <span style="color:#75715e">// 待写入到源代码中的内容
</span><span style="color:#75715e"></span>    optional string content <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;
  }

  <span style="color:#75715e">// 一次要处理的 proto文件可能有多个，所以插件处理后这里的file是一个list
</span><span style="color:#75715e"></span>  repeated File file <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;
}
</code></pre></div><p>下面看一下protoc与protoc插件这对父子进程之间是怎么通信的。</p>
<p>file: src/google/protobuf/compiler/subprocess.h</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">class LIBPROTOC_EXPORT Subprocess {
 public:
  Subprocess();
  <span style="color:#f92672">~</span>Subprocess();

  <span style="color:#66d9ef">enum</span> SearchMode {
    SEARCH_PATH,   <span style="color:#75715e">// Use PATH environment variable.
</span><span style="color:#75715e"></span>    EXACT_NAME     <span style="color:#75715e">// Program is an exact file name; don&#39;t use the PATH.
</span><span style="color:#75715e"></span>  };

  <span style="color:#75715e">// Start the subprocess.  Currently we don&#39;t provide a way to specify
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// arguments as protoc plugins don&#39;t have any.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Start</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> program, SearchMode search_mode);

  <span style="color:#75715e">// Serialize the input message and pipe it to the subprocess&#39;s stdin, then
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// close the pipe.  Meanwhile, read from the subprocess&#39;s stdout and parse
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the data into *output.  All this is done carefully to avoid deadlocks.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Returns true if successful.  On any sort of error, returns false and sets
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// *error to a description of the problem.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Communicate</span>(<span style="color:#66d9ef">const</span> Message<span style="color:#f92672">&amp;</span> input, Message<span style="color:#f92672">*</span> output, string<span style="color:#f92672">*</span> error);

  <span style="color:#75715e">// win32 relevant ... neglect
</span><span style="color:#75715e"></span>
 private:
<span style="color:#75715e">#ifdef _WIN32
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#else  </span><span style="color:#75715e">// !_WIN32
</span><span style="color:#75715e"></span>  pid_t child_pid_;

  <span style="color:#75715e">// The file descriptors for our end of the child&#39;s pipes.  We close each and
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// set it to -1 when no longer needed.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> child_stdin_;
  <span style="color:#66d9ef">int</span> child_stdout_;

<span style="color:#75715e">#endif 
</span><span style="color:#75715e"></span>};
</code></pre></div><p>下面是Linux平台下的子进程启动处理逻辑。</p>
<p>file: src/google/protobuf/compiler/subprocess.cc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> Subprocess<span style="color:#f92672">::</span>Start(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> program, SearchMode search_mode) {
  <span style="color:#75715e">// Note that we assume that there are no other threads, thus we don&#39;t have to
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// do crazy stuff like using socket pairs or avoiding libc locks.
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// [0] is read end, [1] is write end.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> stdin_pipe[<span style="color:#ae81ff">2</span>];
  <span style="color:#66d9ef">int</span> stdout_pipe[<span style="color:#ae81ff">2</span>];

  GOOGLE_CHECK(pipe(stdin_pipe) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  GOOGLE_CHECK(pipe(stdout_pipe) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

  <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> { strdup(program.c_str()), NULL };

  child_pid_ <span style="color:#f92672">=</span> fork();
  <span style="color:#66d9ef">if</span> (child_pid_ <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    GOOGLE_LOG(FATAL) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;fork: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> strerror(errno);
  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (child_pid_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    <span style="color:#75715e">// We are the child.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将子进程的stdin重定向到stdin_pipe的读端
</span><span style="color:#75715e"></span>    dup2(stdin_pipe[<span style="color:#ae81ff">0</span>], STDIN_FILENO);
    <span style="color:#75715e">// 将子进程的stdout重定向到stdout_pipe的写端
</span><span style="color:#75715e"></span>    dup2(stdout_pipe[<span style="color:#ae81ff">1</span>], STDOUT_FILENO);

    <span style="color:#75715e">// 子进程通过0、1对管道进行操作就够了，释放多余的fd
</span><span style="color:#75715e"></span>    close(stdin_pipe[<span style="color:#ae81ff">0</span>]);
    close(stdin_pipe[<span style="color:#ae81ff">1</span>]);
    close(stdout_pipe[<span style="color:#ae81ff">0</span>]);
    close(stdout_pipe[<span style="color:#ae81ff">1</span>]);

    <span style="color:#75715e">// 根据程序搜索模式调用exec族函数来调用插件执行，exec族函数通过替换当前进
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 程的代码段、数据段等内存数据信息，然后调整寄存器信息，使得进程转而去执
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 行插件的代码。插件代码执行之前进程就已经将fd 0、1重定向到父进程clone过
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 来的管道了，因此插件程序的输出将直接被输出到父进程创建的管道中。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 正常情况下，exec一旦执行成功，那么久绝不对执行switch后续的代码了，只有
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 出错才可能会执行到后续的代码。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> (search_mode) {
      <span style="color:#66d9ef">case</span> SEARCH_PATH:
        execvp(argv[<span style="color:#ae81ff">0</span>], argv);
        <span style="color:#66d9ef">break</span>;
      <span style="color:#66d9ef">case</span> EXACT_NAME:
        execv(argv[<span style="color:#ae81ff">0</span>], argv);
        <span style="color:#66d9ef">break</span>;
    }

    <span style="color:#75715e">// 只有出错才可能会执行到这里的代码。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Write directly to STDERR_FILENO to avoid stdio code paths that may do
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stuff that is unsafe here.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ignored;
    ignored <span style="color:#f92672">=</span> write(STDERR_FILENO, argv[<span style="color:#ae81ff">0</span>], strlen(argv[<span style="color:#ae81ff">0</span>]));
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;: program not found or is not executable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    ignored <span style="color:#f92672">=</span> write(STDERR_FILENO, message, strlen(message));
    (<span style="color:#66d9ef">void</span>) ignored;

    <span style="color:#75715e">// Must use _exit() rather than exit() to avoid flushing output buffers
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// that will also be flushed by the parent.
</span><span style="color:#75715e"></span>    _exit(<span style="color:#ae81ff">1</span>);
  } <span style="color:#66d9ef">else</span> {
    free(argv[<span style="color:#ae81ff">0</span>]);

    <span style="color:#75715e">// 父进程释放无用的fd
</span><span style="color:#75715e"></span>    close(stdin_pipe[<span style="color:#ae81ff">0</span>]);
    close(stdout_pipe[<span style="color:#ae81ff">1</span>]);

    <span style="color:#75715e">// 子进程的stdin，对父进程来说也就是管道stdin_pipe的写端，CodeGeneratorRequest将通过这个fd写给子进程
</span><span style="color:#75715e"></span>    child_stdin_ <span style="color:#f92672">=</span> stdin_pipe[<span style="color:#ae81ff">1</span>];
    <span style="color:#75715e">// 子进程的stdout，对父进程来说也就是管道stdout_pipe的读端，CodeGeneratorResponse将通过这个fd从子进程读取
</span><span style="color:#75715e"></span>    child_stdout_ <span style="color:#f92672">=</span> stdout_pipe[<span style="color:#ae81ff">0</span>];
  }
}
</code></pre></div><p>下面接着看父进程读取子进程返回的CodeGeneratorResponse的执行逻辑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> Subprocess<span style="color:#f92672">::</span>Communicate(<span style="color:#66d9ef">const</span> Message<span style="color:#f92672">&amp;</span> input, Message<span style="color:#f92672">*</span> output, string<span style="color:#f92672">*</span> error) {

  GOOGLE_CHECK_NE(child_stdin_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Must call Start() first.&#34;</span>;

  <span style="color:#75715e">// The &#34;sighandler_t&#34; typedef is GNU-specific, so define our own.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SignalHandler</span>(<span style="color:#66d9ef">int</span>);

  <span style="color:#75715e">// Make sure SIGPIPE is disabled so that if the child dies it doesn&#39;t kill us.
</span><span style="color:#75715e"></span>  SignalHandler<span style="color:#f92672">*</span> old_pipe_handler <span style="color:#f92672">=</span> signal(SIGPIPE, SIG_IGN);

  string input_data <span style="color:#f92672">=</span> input.SerializeAsString();
  string output_data;

  <span style="color:#66d9ef">int</span> input_pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> max_fd <span style="color:#f92672">=</span> max(child_stdin_, child_stdout_);

  <span style="color:#75715e">// child_stdout==-1的时候表示子进程返回的数据已经读取完毕了，可以gg了
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (child_stdout_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    fd_set read_fds;
    fd_set write_fds;
    FD_ZERO(<span style="color:#f92672">&amp;</span>read_fds);
    FD_ZERO(<span style="color:#f92672">&amp;</span>write_fds);
    <span style="color:#66d9ef">if</span> (child_stdout_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      FD_SET(child_stdout_, <span style="color:#f92672">&amp;</span>read_fds);
    }
    <span style="color:#66d9ef">if</span> (child_stdin_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      FD_SET(child_stdin_, <span style="color:#f92672">&amp;</span>write_fds);
    }

    <span style="color:#75715e">// 这种情景下也用select，果然很google！
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (select(max_fd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>read_fds, <span style="color:#f92672">&amp;</span>write_fds, NULL, NULL) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
      <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EINTR) {
        <span style="color:#75715e">// Interrupted by signal.  Try again.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">continue</span>;
      } <span style="color:#66d9ef">else</span> {
        GOOGLE_LOG(FATAL) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;select: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> strerror(errno);
      }
    }

    <span style="color:#75715e">// stdout_pipe写事件就绪，写请求CodeGeneratorRequest给子进程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (child_stdin_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> FD_ISSET(child_stdin_, <span style="color:#f92672">&amp;</span>write_fds)) {
      <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> write(child_stdin_, input_data.data() <span style="color:#f92672">+</span> input_pos,
                                  input_data.size() <span style="color:#f92672">-</span> input_pos);
      <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">// Child closed pipe.  Presumably it will report an error later.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Pretend we&#39;re done for now.
</span><span style="color:#75715e"></span>        input_pos <span style="color:#f92672">=</span> input_data.size();
      } <span style="color:#66d9ef">else</span> {
        input_pos <span style="color:#f92672">+=</span> n;
      }

      <span style="color:#75715e">// 代码生成请求已经成功写给子进程了，关闭相关的fd
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (input_pos <span style="color:#f92672">==</span> input_data.size()) {
        <span style="color:#75715e">// We&#39;re done writing.  Close.
</span><span style="color:#75715e"></span>        close(child_stdin_);
        child_stdin_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
      }
    }

    <span style="color:#75715e">// stdin_pipe读事件就绪，读取子进程返回的CodeGeneratorResponse
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (child_stdout_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> FD_ISSET(child_stdout_, <span style="color:#f92672">&amp;</span>read_fds)) {
      <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">4096</span>];
      <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> read(child_stdout_, buffer, <span style="color:#66d9ef">sizeof</span>(buffer));

      <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        output_data.append(buffer, n);
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 子进程返回的CodeGeneratorResponse已经读取完毕，关闭相关的fd
</span><span style="color:#75715e"></span>        close(child_stdout_);
        child_stdout_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
      }
    }
  }

  <span style="color:#75715e">// 子进程还没有读取CodeGeneratorRequest完毕，就关闭了输出，这种情况下也不可
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 能读取到返回的CodeGeneratorResponse了，这种情况很可能是出现了异常。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (child_stdin_ <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#75715e">// Child did not finish reading input before it closed the output.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Presumably it exited with an error.
</span><span style="color:#75715e"></span>    close(child_stdin_);
    child_stdin_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#75715e">// 等待子进程结束，子进程退出之后，需要父进程来清理子进程占用的部分资源。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如果当前父进程不waitpid的话，子进程的父进程会变为init或者systemd进程，同样也会被清理的。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> status;
  <span style="color:#66d9ef">while</span> (waitpid(child_pid_, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">!=</span> EINTR) {
      GOOGLE_LOG(FATAL) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;waitpid: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> strerror(errno);
    }
  }

  <span style="color:#75715e">// 刚才为了阻止SIGPIPE信号到达时导致进程终止，我们修改了SIGPIPE的信号处理函
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 数，这里可以恢复之前的SIGPIPE的信号处理函数。
</span><span style="color:#75715e"></span>  signal(SIGPIPE, old_pipe_handler);

  <span style="color:#75715e">// 根据子进程的退出状态执行后续的处理逻辑
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 异常处理
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (WIFEXITED(status)) {
    <span style="color:#66d9ef">if</span> (WEXITSTATUS(status) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
      <span style="color:#66d9ef">int</span> error_code <span style="color:#f92672">=</span> WEXITSTATUS(status);
      <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> strings<span style="color:#f92672">::</span>Substitute(
          <span style="color:#e6db74">&#34;Plugin failed with status code $0.&#34;</span>, error_code);
      <span style="color:#66d9ef">return</span> false;
    }
  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (WIFSIGNALED(status)) {
    <span style="color:#66d9ef">int</span> signal <span style="color:#f92672">=</span> WTERMSIG(status);
    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> strings<span style="color:#f92672">::</span>Substitute(
        <span style="color:#e6db74">&#34;Plugin killed by signal $0.&#34;</span>, signal);
    <span style="color:#66d9ef">return</span> false;
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Neither WEXITSTATUS nor WTERMSIG is true?&#34;</span>;
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#75715e">// 将子进程返回的串行化之后的CodeGeneratorResponse数据进行反串行化，反串行化
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 成Message对象，实际上这里的Message::ParseFromString(const string&amp;)是个虚
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 函数，是被CodeGeneratorResponse这个类重写了的，反串行化过程与具体的类密切
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 相关，也必须在派生类中予以实现。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>output<span style="color:#f92672">-&gt;</span>ParseFromString(output_data)) {
    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Plugin output is unparseable.&#34;</span>;
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#66d9ef">return</span> true;
}

</code></pre></div><p>到这里为止protoc进程的具体执行逻辑我们已经很清楚了，看到这里想必读者也看清楚了吧？下面再看下插件的执行逻辑。</p>
<p>插件的执行逻辑一定也是非常简单的，插件就只是从stdin读取串行化之后的CodeGeneratorRequest请求，然后执行反串行化得到一个完整的CodeGeneratorRequest对象，然后根据请求进行必要的代码生成逻辑，确定要生成的源代码信息，并将其设置到CodeGeneratorResponse中并串行化后写入到stdout，插件的执行逻辑就这么简单。</p>
<p>下面我们将进入插件的编写过程了。</p>
<h3 id="24-protoc插件开发">2.4. protoc插件开发</h3>
<h4 id="241-protoc中的descriptor定义">2.4.1. protoc中的descriptor定义</h4>
<p>proto文件中的数据类型都是在descriptor.proto中定义好的，为了更好地帮助我们对proto文件中的数据类型进行解析，为了在插件开发过程中更加方便快速地获得与数据类型、变量、rpc等相关的这种内容、那种内容，我们都需要深入地理解descriptor.proto中的相关定义以及从它延伸出来的一些概念、算法等。</p>
<p>这部分的内容还不少，在不影响理解的大前提下，我还是稍微删减写些代码，避免对大家理解造成不必要的干扰。</p>
<p>file: src/google/protobuf/descriptor.proto</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Author: kenton@google.com (Kenton Varda)
</span><span style="color:#75715e">// Based on original Protocol Buffers design by
</span><span style="color:#75715e">// Sanjay Ghemawat, Jeff Dean, and others.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// descriptor.proto文件中的messages定义了proto文件中所能见到的所有的定义，一个有效的.proto文件在不提供其他信息（甚至不需要读取它的imports）能够直接被转换成一个FileDescriptorProto对象。
</span><span style="color:#75715e"></span>
package google.protobuf;
option java_package <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;com.google.protobuf&#34;</span>;
option java_outer_classname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DescriptorProtos&#34;</span>;

<span style="color:#75715e">// descriptor.proto必须在速度方面优化，因为在启动过程中基于反射的算法不起作用
</span><span style="color:#75715e"></span>option optimize_for <span style="color:#f92672">=</span> SPEED;

<span style="color:#75715e">// protoc可以将解析的proto文件中的descriptor添加到FileDescriptorSet并输出到文件
</span><span style="color:#75715e"></span>message FileDescriptorSet {
  repeated FileDescriptorProto file <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
}

<span style="color:#75715e">// 下面的message FileDescriptorProto可以用于描述一个完整的proto文件
</span><span style="color:#75715e"></span>message FileDescriptorProto {

  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;              <span style="color:#75715e">// proto文件名，file name，相对于源代码根目录 
</span><span style="color:#75715e"></span>  optional string package <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;           <span style="color:#75715e">// proto包名，例如 &#34;foo&#34;、&#34;foo.bar&#34;
</span><span style="color:#75715e"></span>  repeated string dependency <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;        <span style="color:#75715e">// proto文件中import进来的其他proto文件列表
</span><span style="color:#75715e"></span>  repeated int32 public_dependency <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// 上面public import的proto文件在proto文件列表中的索引
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Indexes of the weak imported files in the dependency list.
</span><span style="color:#75715e"></span>  repeated int32 weak_dependency <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;   <span style="color:#75715e">// 上面weak import的proto文件在proto文件列表中的索引
</span><span style="color:#75715e"></span>                                         <span style="color:#75715e">// 不要使用，只用于google内部的迁移
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// proto文件中的所有顶层定义信息
</span><span style="color:#75715e"></span>  repeated DescriptorProto message_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;    <span style="color:#75715e">// 所有的消息(message)类型定义
</span><span style="color:#75715e"></span>  repeated EnumDescriptorProto enum_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;   <span style="color:#75715e">// 所有的枚举(enum)类型定义
</span><span style="color:#75715e"></span>  repeated ServiceDescriptorProto service <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;  <span style="color:#75715e">// 所有的服务(service)类型定义
</span><span style="color:#75715e"></span>  repeated FieldDescriptorProto extension <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;  <span style="color:#75715e">// 所有的扩展字段定义
</span><span style="color:#75715e"></span>
  optional FileOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;             <span style="color:#75715e">// 文件选项
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 这个字段包括了源代码的相关信息，这里的信息可以给开发工具使用，也仅应该提供给开发工具使用；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 可以选择将这个字段中的信息删除，在程序运行期间并不会造成破坏。
</span><span style="color:#75715e"></span>  optional SourceCodeInfo source_code_info <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
}

<span style="color:#75715e">// 描述消息类型Message
</span><span style="color:#75715e"></span>message DescriptorProto {
  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                     <span style="color:#75715e">// Message的类型名称
</span><span style="color:#75715e"></span>
  repeated FieldDescriptorProto field <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;      <span style="color:#75715e">// Message中包括的字段列表
</span><span style="color:#75715e"></span>  repeated FieldDescriptorProto extension <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;  <span style="color:#75715e">// Message中包括的扩展列表
</span><span style="color:#75715e"></span>
  repeated DescriptorProto nested_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;     <span style="color:#75715e">// Message中嵌套的Message类型列表
</span><span style="color:#75715e"></span>  repeated EnumDescriptorProto enum_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;   <span style="color:#75715e">// Message中嵌套的枚举类型列表
</span><span style="color:#75715e"></span>
  message ExtensionRange {
    optional int32 start <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    optional int32 end <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
  }
  repeated ExtensionRange extension_range <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;

  optional MessageOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
}

<span style="color:#75715e">// 描述一个字段（字段可以是Message中的，也可以是某些扩展字段）
</span><span style="color:#75715e"></span>message FieldDescriptorProto {
  <span style="color:#75715e">// 字段数据类型
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> Type {
    <span style="color:#75715e">// 0 is reserved for errors.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 由于历史方面的原因，这里的枚举值的顺序有点奇怪
</span><span style="color:#75715e"></span>    TYPE_DOUBLE         <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    TYPE_FLOAT          <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#75715e">// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// negative values are likely.
</span><span style="color:#75715e"></span>    TYPE_INT64          <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    TYPE_UINT64         <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
    <span style="color:#75715e">// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// negative values are likely.
</span><span style="color:#75715e"></span>    TYPE_INT32          <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    TYPE_FIXED64        <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
    TYPE_FIXED32        <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
    TYPE_BOOL           <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
    TYPE_STRING         <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
    TYPE_GROUP          <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// Tag-delimited aggregate.
</span><span style="color:#75715e"></span>    TYPE_MESSAGE        <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;  <span style="color:#75715e">// Length-delimited aggregate.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// New in version 2.
</span><span style="color:#75715e"></span>    TYPE_BYTES          <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
    TYPE_UINT32         <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>;
    TYPE_ENUM           <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>;
    TYPE_SFIXED32       <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;
    TYPE_SFIXED64       <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;
    TYPE_SINT32         <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span>;  <span style="color:#75715e">// Uses ZigZag encoding.
</span><span style="color:#75715e"></span>    TYPE_SINT64         <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;  <span style="color:#75715e">// Uses ZigZag encoding.
</span><span style="color:#75715e"></span>  };

  <span style="color:#75715e">// 字段修饰符optional、required、repeated
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> Label {
    <span style="color:#75715e">// 0 is reserved for errors
</span><span style="color:#75715e"></span>    LABEL_OPTIONAL      <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    LABEL_REQUIRED      <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    LABEL_REPEATED      <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    <span style="color:#75715e">// TODO(sanjay): Should we add LABEL_MAP?
</span><span style="color:#75715e"></span>  };

  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;             <span style="color:#75715e">// 字段名称
</span><span style="color:#75715e"></span>  optional int32 number <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;            <span style="color:#75715e">// 字段tag编号
</span><span style="color:#75715e"></span>  optional Label label <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;             <span style="color:#75715e">// 字段修饰符
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 如果type_name已设置，这个字段无须设置；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如果这两个字段都设置了，这里的type字段必须是TYPE_ENUM类型或者TYPE_MESSAGE类型
</span><span style="color:#75715e"></span>  optional Type type <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;

  <span style="color:#75715e">// 对于TYPE_ENUM或者TYPE_MESSAGE类型，type_name就是type的名字。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如果name以“.”开头那么它是完全保留的。对于C++来说，其作用域规则要求首先搜
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 索当前Message类型的嵌套类型，然后才是parent namespace中的类型，一直到root
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// namespace。
</span><span style="color:#75715e"></span>  optional string type_name <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;

  <span style="color:#75715e">// 对于扩展，它就是被扩展的类型的名字，对它的解析与对type_name的解析时一样的
</span><span style="color:#75715e"></span>  optional string extendee <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

  <span style="color:#75715e">// 对于数值类型，存储了数值的文本表示形式；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 对于布尔类型，存储字符串&#34;true&#34;或&#34;false&#34;；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 对于字符串类型，存储原始的文本内容（未转义的）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 对于字节，存储了c转义后的值（所有&gt;=128的字节都会被转义）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// TODO(kenton)，基于base64编码的?
</span><span style="color:#75715e"></span>  optional string default_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;

  optional FieldOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;    <span style="color:#75715e">// 字段选项
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 描述一个枚举类型enum
</span><span style="color:#75715e"></span>message EnumDescriptorProto {
  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                     <span style="color:#75715e">// 枚举类型名称
</span><span style="color:#75715e"></span>  repeated EnumValueDescriptorProto value <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;  <span style="color:#75715e">// 枚举类型中包括的枚举值列表
</span><span style="color:#75715e"></span>  optional EnumOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;             <span style="color:#75715e">// 枚举类型选项
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 描述一个枚举类型中的一个枚举值
</span><span style="color:#75715e"></span>message EnumValueDescriptorProto {
  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                     <span style="color:#75715e">// 枚举值对应的name
</span><span style="color:#75715e"></span>  optional int32 number <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;                    <span style="color:#75715e">// 枚举值对应的number（默认为0，依次递增）
</span><span style="color:#75715e"></span>  optional EnumValueOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;        <span style="color:#75715e">// 枚举值选项
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 描述一个rpc service.
</span><span style="color:#75715e"></span>message ServiceDescriptorProto {
  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                     <span style="color:#75715e">// 服务名称
</span><span style="color:#75715e"></span>  repeated MethodDescriptorProto method <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// 服务对应的方法列表
</span><span style="color:#75715e"></span>  optional ServiceOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;          <span style="color:#75715e">// 服务选项
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 描述一个服务的方法
</span><span style="color:#75715e"></span>message MethodDescriptorProto {
  optional string name <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                     <span style="color:#75715e">// 方法名称
</span><span style="color:#75715e"></span>  optional string input_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;               <span style="color:#75715e">// 方法入参类型
</span><span style="color:#75715e"></span>  optional string output_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;              <span style="color:#75715e">// 方法出参类型
</span><span style="color:#75715e"></span>  optional MethodOptions options <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;           <span style="color:#75715e">// 方法选项
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// ===================================================================
</span><span style="color:#75715e">// Options
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 上面的每一个定义基本上都包括了选项option相关的字段，这些选项字段仅仅是一些
</span><span style="color:#75715e">// 注解，这些注解会影响代码的生成，使得生成的代码稍有不同，注解也可能包含了操作
</span><span style="color:#75715e">// message的代码的一些提示信息、说明信息。
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// clients可能会定义一些自定义的选项来作为*Options message的extensions，这些
</span><span style="color:#75715e">// extensions在parsing阶段可能还无法确定下来，所以parser不能存储他们的值，而是
</span><span style="color:#75715e">// 将这些自定义的选项先存储到一个*Options message里面，称之为
</span><span style="color:#75715e">// uinterpreted_option。这个字段的名字在所有的*Options message里面都必须保证是
</span><span style="color:#75715e">// 相同的。之后在我们构建descriptor的时候，这个时候所有的proto文件也都解析完了、
</span><span style="color:#75715e">// 所有的extensions也都知道了，这个时候我们再用这里的uinterpreted_option字段去
</span><span style="color:#75715e">// 填充那些extensions。
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// 用于自定义选项的extensions编号的选择一般遵循下面的方法：
</span><span style="color:#75715e">// * 对于只在一个应用程序或者组织内使用的选项，或者用于实验目的的选项，使用字
</span><span style="color:#75715e">//   段编号50000~99999范围内的。对于多个选项，用户需要确保不使用相同的编号。
</span><span style="color:#75715e">// * 对于可能被多个互不依赖的实体所共同使用的选项，需要给
</span><span style="color:#75715e">//   protobuf-global-extension-registry@google.com发邮件来申请预留扩展编号。需
</span><span style="color:#75715e">//   要提供工程名称、工程站点，没必要解释为什么需要申请预留某个特定的编号。通
</span><span style="color:#75715e">//   常只需要一个扩展编号，可以声明多个选项但是只使用这一个相同的扩展编号。如
</span><span style="color:#75715e">//   果申请公共的扩展编号是个刚需，google可能会发布一个web service接口来自动分
</span><span style="color:#75715e">//   配选项编号。
</span><span style="color:#75715e"></span>
message FileOptions {

  <span style="color:#75715e">// java包名，当前proto文件中生成的java类将位于这个package下
</span><span style="color:#75715e"></span>  optional string java_package <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// 指定一个外部类名称，当前proto文件中生成的所有的类将被封装在这个外部类当中
</span><span style="color:#75715e"></span>  optional string java_outer_classname <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;

  <span style="color:#75715e">// 如果设置为true，java代码生成器将为每个顶层message、enum、service定义生成
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 单独的java文件，默认为false
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> java_multiple_files <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// 如果设置为true，java代码生成器将未每个message定义生成equals()、hashCode()
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 方法，默认为false。本来AbstractMessage基类经包括了一个基于反射的equals()、
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// hashCode()方法实现，这里的这个设置项是一个性能方面的优化
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> java_generate_equals_and_hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// 优化类型，生成的类可以进行速度优化、代码尺寸优化
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> OptimizeMode {
    SPEED <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;        <span style="color:#75715e">// Generate complete code for parsing, serialization,
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// etc.
</span><span style="color:#75715e"></span>    CODE_SIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// Use ReflectionOps to implement these methods.
</span><span style="color:#75715e"></span>    LITE_RUNTIME <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e">// Generate code using MessageLite and the lite runtime.
</span><span style="color:#75715e"></span>  }
  optional OptimizeMode optimize_for <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>SPEED];

  <span style="color:#75715e">// 设置go代码的包名
</span><span style="color:#75715e"></span>  optional string go_package <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;

  <span style="color:#75715e">// 是否应该针对每一门语言都生成generice services？generic服务并不特定于任何
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 的rpc系统，它是由每个语言的注代码生成器来生成的，不借助于额外的插件。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// generic services是早期protoo2这个版本说支持的唯一一种服务类型。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 由于现在推崇使用plugins，plugins可以生成针对特定rpc系统的代码，generic
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// services现在可以看做是被废弃了。因此，以前proto2总的generice services的默
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 认设置默认为false，早期的依赖于generic services的代码需要显示设置这些选项
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 为true。
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> cc_generic_services <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];
  optional <span style="color:#66d9ef">bool</span> java_generic_services <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];
  optional <span style="color:#66d9ef">bool</span> py_generic_services <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// parser将不识别的选项存储在这里的uinterpreted_option
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message MessageOptions {
  <span style="color:#75715e">// 设为true则使用老的proto1 MessageSet wire format……兼容性目的，没必要使用
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> message_set_wire_format <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// 禁用标准的descriptor()方法的生成，因为如果有个字段名是descriptor的话会生
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 成一个同名的函数，会冲突。这使得从proto1迁移到后续版本更简单，但是新版本
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 中还是应该避免使用字段descriptor。
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> no_standard_descriptor_accessor <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// parser将不识别的选项存储在这个字段里
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message FieldOptions {
  <span style="color:#75715e">// 开启packed选项之后，对于repeated基本数据类型字段的表示会更加高效。不再针
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 对repeated字段中的各个元素执行写tag、类型操作，而是将整个数组作为一个固定
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 长度的blob来存储。
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> packed <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

  <span style="color:#75715e">// 当前字段是否需要lazy parsing？只是建议，lazy为true，protoc不一定lazy parsing
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> lazy <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// 当前字段是否已经被废弃，跟目标平台相关，这个字段可以为生成的accessor方法
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 生成Deprecated注解，如果目标平台不支持就会忽略这个选项。不管目标平台是否
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 支持，proto里面要想废弃一个字段加deprecated选项还是非常正确的做法。
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> deprecated <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// map字段，目前还未完全实现，应避免使用
</span><span style="color:#75715e"></span>  optional string experimental_map_key <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;

  <span style="color:#75715e">// google内部迁移使用，因避免使用
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> weak <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>false];

  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户自定义选项来扩展message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message EnumOptions {

  <span style="color:#75715e">// 不允许将多个不同的tag names映射到一个相同的值
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 意思是说不允许多个字段的编号相同
</span><span style="color:#75715e"></span>  optional <span style="color:#66d9ef">bool</span> allow_alias <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> [<span style="color:#66d9ef">default</span><span style="color:#f92672">=</span>true];

  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户自定义选项来扩展message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message EnumValueOptions {
  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户自定义选项来扩展message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message ServiceOptions {
  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户自定义选项来扩展message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

message MethodOptions {

  <span style="color:#75715e">// 注意：字段编号1~32被保留给google内部rpc框架使用，google的解释是，在
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// protobuf被公开给外部使用之前内部就已经大量使用了，且1~32倍使用的很多，也
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 是不得已的事情，总不能为了开源、推广一个内部组件就把自己的生意砸了吧。
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 用户可以定义自定义选项来扩展当前Message
</span><span style="color:#75715e"></span>  repeated UninterpretedOption uninterpreted_option <span style="color:#f92672">=</span> <span style="color:#ae81ff">999</span>;

  <span style="color:#75715e">// 用户自定义选项来扩展message
</span><span style="color:#75715e"></span>  extensions <span style="color:#ae81ff">1000</span> to max;
}

<span style="color:#75715e">// 描述一个parser不认识的option message
</span><span style="color:#75715e">// - UninterpretedOption只会出现在compiler::Parser类创建的options protos中；
</span><span style="color:#75715e">// - 构建Descriptor对象的时候DescriptorPool会解析UninterpretedOptions；
</span><span style="color:#75715e">// 因此，descriptor对象中的options protos（通过Descriptor::options()返回，或者
</span><span style="color:#75715e">// 通过Descriptor::CopyTo()生成）是不会包括UinterpretedOptions的。
</span><span style="color:#75715e"></span>message UninterpretedOption {
  <span style="color:#75715e">// uinterpreted选项的名字，name中每个元素的name_part字段都表示name中的点分字
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 符串的一段，如果name_part是一个扩展（通过在字符串两端用括号括起来表示），
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// is_extension字段为true。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 例如，{[&#34;foo&#34;, false], [&#34;bar.baz&#34;,true], [&#34;qux&#34;,false]}表示&#34;foo.(bar.baz).qux&#34;。
</span><span style="color:#75715e"></span>  message NamePart {
    required string name_part <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    required <span style="color:#66d9ef">bool</span> is_extension <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
  }
  repeated NamePart name <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

  <span style="color:#75715e">// uinterpreted选项的值，会设置下面字段中其中一个的值
</span><span style="color:#75715e"></span>  optional string identifier_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
  optional uint64 positive_int_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
  optional int64 negative_int_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
  optional <span style="color:#66d9ef">double</span> double_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
  optional bytes string_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
  optional string aggregate_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
}

<span style="color:#75715e">// ===================================================================
</span><span style="color:#75715e">// Optional source code info
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// FileDescriptorProto是从之前的source file中生成的（source file指的是proto文
</span><span style="color:#75715e">// 件），这里的SourceCodeInfo指的是proto中的“源代码”信息。
</span><span style="color:#75715e"></span>message SourceCodeInfo {
  <span style="color:#75715e">// Location用于识别proto文件中的源代码片段，往往对应着一个特定的定义。这些
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Location信息对于IDE、代码索引工具、文档生成工具等是非常重要的。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 下面说明一下Location的概念和作用，以下面这个message为例：
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   message Foo {
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//     optional string foo = 1;
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   }
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 我们先只看上面这个message中的字段定义：
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   optional string foo = 1;
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   ^       ^^     ^^  ^  ^^^
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   a       bc     de  f  ghi
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 我们可以得到下面这几个Location：
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   span   path               represents
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 每个proto文件解析之后用一个FileDescriptorProto来表示，所以Lcoation路径位
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 置从FileDescriptorProto开始。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 因为message Foo是一个message，proto中所有顶层message类型定义都在
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   FileDescriptorProto中message_type字段存储，这个字段的tag是4，所以Location为[4]；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 又因为message_type是repeated DescriptorProto类型，因为当前proto示例中
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   Foo为第一个message，所以其在message_type列表中的索引值为0，所以Location为[4,0]；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 因为我们现在看的“源代码”是“optional string foo = 1;”，我们需要定位到
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   message中的字段位置，message Foo中的所有字段都在DescriptorProto中的field字
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   段中记录，这个字段的tag=2，所以Location变为[4,0,2]；
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// - 又因为这个DescriptorProto中的field为repeated FieldDescriptorProto field，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//   因为这个message中只有一个字段foo，所以foo在field列表中的索引值为0，Location变为[4,0,2,0];
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 上面解释了定位到完整的“optional string foo = 1”定义这个field的Location变
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 化过程，下面再说一下label、type、name、number的Location如何进一步确定。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// FieldDescriptorProto中label的tag位4，type的tag为5，name的tag为1，number的
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// tag为3，Location对应的追加索引4、5、1、3。gg!
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// proto文件中的源代码信息就是由一系列的Location来寻址的。
</span><span style="color:#75715e"></span>  repeated Location location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  message Location {
    <span style="color:#75715e">// 前面已经描述了Location的确定过程，一个Location如[4,0,2,0]其中的数字要么
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 是字段的tag编号要么是repeated列表中的索引值，这里的数字构成的数组保存在
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// path中。
</span><span style="color:#75715e"></span>    repeated int32 path <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> [packed<span style="color:#f92672">=</span>true];

    <span style="color:#75715e">// 该字段span总是包括3个或者4个元素，依次表示startline、startcolumn、endline、endcolumn
</span><span style="color:#75715e"></span>    repeated int32 span <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> [packed<span style="color:#f92672">=</span>true];

    <span style="color:#75715e">// 如果这个SourceCodeInfo代表一个完整的声明的话，可能在这个声明的前面或者
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 后面可能有一些attached的注释。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 连续的多个行注释看做是一个单独的注释。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这个字段只记录了注释内容，不包括注释内容开头的注释符号//。对于块注释，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注释前面的空白字符、*这几种符号也会被清理掉。但是会包括换行符。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Examples:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional int32 foo = 1;  // Comment attached to foo.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   // Comment attached to bar.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional int32 bar = 2;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional string baz = 3;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   // Comment attached to baz.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   // Another line attached to baz.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   // Comment attached to qux.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   //
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   // Another line attached to qux.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional double qux = 4;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional string corge = 5;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   /* Block comment attached
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//    * to corge.  Leading asterisks
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//    * will be removed. */
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   /* Block comment attached to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//    * grault. */
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   optional int32 grault = 6;
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">// Location前面的注释信息
</span><span style="color:#75715e"></span>    optional string leading_comments <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;

    <span style="color:#75715e">// Location后面的注释信息
</span><span style="color:#75715e"></span>    optional string trailing_comments <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
  }
}
</code></pre></div><h4 id="242-可以提取proto文件中的哪些信息--如何提取">2.4.2. 可以提取proto文件中的哪些信息 &amp; 如何提取</h4>
<p>前一节2.4.1中对descriptor.proto进行了详细地描述，可以说在proto文件中写的每一行内容都可以通过解析FileDescriptorProto来访问到。proto文件只是一种自描述的消息格式，基于这种格式生成面向特定编程语言的源代码文件时，我们想获取的信息不外乎如下几个：</p>
<ol>
<li>待生成的源文件的包名；</li>
<li>待生成的源文件的wrapper class类名；</li>
<li>proto文件中定义的各个类型，包括枚举enum、消息message、服务service；</li>
<li>对于枚举enum需要知道枚举类型名、列出的枚举值（包括字段、值、注释信息）、注释信息；</li>
<li>对于消息message需要知道类型名、类成员（包括成员类型、成员名称、定义顺序、默认值、注释信息）、注释信息；</li>
<li>对于服务service需要知道服务名称、服务rpc接口（rpc接口的请求参数、返回值类型、注释信息）、注释信息；</li>
<li>proto中可以添加注解吗？注解可以提取出来吗？</li>
</ol>
<p>如何提取上述信息呢？可以肯定地是，只要能拿到当前proto文件对应的FileDescriptorProto，上述内容几乎都可以获取到。但是如何获取到对应的proto文件对应的这个FileDescriptorProto对象呢？下面我们先来看一个protoc插件的示例代码吧，看完之后，大家也就了解了如何获取proto对应的FileDescriptorProto以及如何从中提取想要的1~7上述信息，生成源代码文件也就简单了。</p>
<h4 id="243-protoc-go语言插件protoc-gen-go">2.4.3. protoc go语言插件protoc-gen-go</h4>
<p>protoc-gen-go的源代码可以通过通过如下方式获取：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">git co https:<span style="color:#75715e">//github.com/golang/protobuf
</span><span style="color:#75715e"></span>git branch <span style="color:#f92672">-</span>b <span style="color:#960050;background-color:#1e0010">$</span>{new<span style="color:#f92672">-</span>branch}
</code></pre></div><h4 id="2431-protoc-gen-go入口函数分析">2.4.3.1. protoc-gen-go入口函数分析</h4>
<p>file: protobuf/protoc-gen-go/main.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;io/ioutil&#34;</span>
    <span style="color:#e6db74">&#34;os&#34;</span>

    <span style="color:#e6db74">&#34;github.com/c4pt0r/proto&#34;</span>
    <span style="color:#e6db74">&#34;github.com/c4pt0r/protoc-gen-go/generator&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 首先创建一个代码生成器generator，CodeGeneratorRequest、CodeGeneratorResponse
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 结构体都被保存在generator中，CodeGenerateResponse中保存着代码生成过程中
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 的错误状态信息，因此我们可以通过这个结构体提取错误状态并进行错误处理
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">New</span>()

    <span style="color:#75715e">// 从标准输入中读取CodeGeneratorRequest信息（标准输入已经被重定向到了父进程
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// protoc进程创建的管道stdout_pipe的读端，父进程会从管道的写端写入该请求信息）
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;reading input&#34;</span>)
    }

    <span style="color:#75715e">// 读取到的数据时串行化之后的CodeGeneratorRequest，将其反串行化成CodeGeneratorRequest
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;parsing input proto&#34;</span>)
    }

    <span style="color:#75715e">// 检查CodeGeneratorRequest中待生成的源代码文件数量，数量为0则无需生成
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">FileToGenerate</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Fail</span>(<span style="color:#e6db74">&#34;no files to generate&#34;</span>)
    }

    <span style="color:#75715e">// 将CodeGeneratorRequest中传递给代码生成器的参数设置到protoc插件的代码生成器中
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">CommandLineParameters</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">GetParameter</span>())

    <span style="color:#75715e">// 前面的proto.Unmarshal(...)操作将stdin中的请求反串行化成了CodeGeneratorRequest，
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里的g.WrapTypes()将请求中的一些descriptors进行进一步封装，方便后面引用
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">WrapTypes</span>()

    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">SetPackageNames</span>()
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">BuildTypeNameMap</span>()

    <span style="color:#75715e">// 生成所有的源代码文件
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">GenerateAllFiles</span>()

    <span style="color:#75715e">// 将CodeGeneratorResponse对象进行串行化处理
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Response</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;failed to marshal output proto&#34;</span>)
    }
    <span style="color:#75715e">// 将串行化之后的CodeGenerateResponse对象数据写入标准输出（标准输出已经被
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 重定向到了父进程protoc进程创建的管道stdin_pipe的写端，父进程从管道的读
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 端读取这里的响应）
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">data</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">err</span>, <span style="color:#e6db74">&#34;failed to write output proto&#34;</span>)
    }
}
</code></pre></div><h4 id="2432-回顾一下codegeneratorrequest--codegeneratorresponse的定义">2.4.3.2. 回顾一下CodeGeneratorRequest &amp; CodeGeneratorResponse的定义</h4>
<p>下面看下CodeGeneratorRequest和CodeGeneratorResponse的定义。</p>
<p>file: ${protobuf}/src/google/protobuf/compiler/plugin.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 串行化后的CodeGeneratorRequest信息会被写入到插件程序的stdin
</span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">CodeGeneratorRequest</span> {
  <span style="color:#75715e">// protoc命令执行时，我们在命令行中列出了需要进行处理的.proto文件的名称，代
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 码生成器应该只为这些.proto文件生成源代码文件。每一个.proto文件成功解析之
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 后会生成一个FileDescriptorProto对象，这个对象会被加入到字段proto_file中
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">repeated</span> <span style="color:#66d9ef">string</span> <span style="color:#a6e22e">file_to_generate</span> = <span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// protoc命令行程序中传递给插件程序代码生成器的参数信息
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">string</span> <span style="color:#a6e22e">parameter</span> = <span style="color:#ae81ff">2</span>;

  <span style="color:#75715e">// protoc命令行中列出的所有的.proto文件被添加到了字段file_to_generate中，这
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 些.proto文件中通过import引入进来的文件，这两部分文件解析成功后对应的
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// FileDescriptorProto对象都会被加入到这里的proto_file中，添加后的顺序是按照
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 拓扑顺序排序的，怎么讲？就是被import的proto文件会出现在import它们的 proto
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 文件前面。
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">repeated</span> <span style="color:#a6e22e">FileDescriptorProto</span> <span style="color:#a6e22e">proto_file</span> = <span style="color:#ae81ff">15</span>;
}

<span style="color:#75715e">// 串行化后的CodeGeneratorResponse信息会被写入到插件的stdout
</span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">CodeGeneratorResponse</span> {
  <span style="color:#75715e">// 如果错误信息非空，表示代码生成失败。这种情况下尽管代码生成失败，插件进程
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 仍然应该返回一个状态0。
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这个字段用于指示.proto文件错误，.proto文件中的错误将使得代码生成器无法生
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 成正确的代码。指示protoc本身的错误，例如CodeGeneratorRequest数据无法被正
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 确地反串行化，这种情况应该被报告，错误信息应该写到stderr并且插件进程应该
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 返回一个非0状态码
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">error</span> = <span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// 描述一个待生成的源代码文件
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">message</span> <span style="color:#a6e22e">File</span> {
    <span style="color:#75715e">// 待生成的源代码文件相对于输出目录的文件名
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">string</span> <span style="color:#a6e22e">name</span> = <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">// 写入到源代码文件中的插入点信息，方便后面的插件在插入点处进行扩展其他内容
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">string</span> <span style="color:#a6e22e">insertion_point</span> = <span style="color:#ae81ff">2</span>;

    <span style="color:#75715e">// 写入到文件或者文件插入点位置的内容
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">string</span> <span style="color:#a6e22e">content</span> = <span style="color:#ae81ff">15</span>;
  }

  <span style="color:#75715e">// 所有的待生成的源代码文件列表
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">repeated</span> <span style="color:#a6e22e">File</span> <span style="color:#a6e22e">file</span> = <span style="color:#ae81ff">15</span>;
}
</code></pre></div><h4 id="2433-generator实现分析">2.4.3.3. generator实现分析</h4>
<p>main.go中调用了generator的几个关键方法，我们先来看下这几个方法都做了些什么，然
后再跟进一步看看generator的详细实现过程。</p>
<h5 id="24331-generatornew">2.4.3.3.1. generator.New()</h5>
<p>file: ${golang-protobuf}/protoc-gen-go/generator/generator.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Generator类型的方法能够输出源代码，这些输出的源代码信息存储在Response成员中
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Generator</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>

    <span style="color:#a6e22e">Request</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">CodeGeneratorRequest</span>  <span style="color:#75715e">// The input.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Response</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">CodeGeneratorResponse</span> <span style="color:#75715e">// The output.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">Param</span>             <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span> <span style="color:#75715e">// Command-line parameters.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">PackageImportPath</span> <span style="color:#66d9ef">string</span>            <span style="color:#75715e">// Go import path of the package we&#39;re generating code for
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ImportPrefix</span>      <span style="color:#66d9ef">string</span>            <span style="color:#75715e">// String to prefix to imported package file names.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ImportMap</span>         <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span> <span style="color:#75715e">// Mapping from .proto file name to import path
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">Pkg</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span> <span style="color:#75715e">// The names under which we import support packages
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">packageName</span>      <span style="color:#66d9ef">string</span>                     <span style="color:#75715e">// What we&#39;re calling ourselves.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">allFiles</span>         []<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>          <span style="color:#75715e">// All files in the tree
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">allFilesByName</span>   <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span> <span style="color:#75715e">// All files by filename.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">genFiles</span>         []<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>          <span style="color:#75715e">// Those files we will generate output for.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">file</span>             <span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>            <span style="color:#75715e">// The file we are compiling now.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">usedPackages</span>     <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>            <span style="color:#75715e">// Names of packages used in current file.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeNameToObject</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Object</span>          <span style="color:#75715e">// Key is a fully-qualified name in input syntax.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">init</span>             []<span style="color:#66d9ef">string</span>                   <span style="color:#75715e">// Lines to emit in the init function.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">indent</span>           <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">writeOutput</span>      <span style="color:#66d9ef">bool</span>
}

<span style="color:#75715e">// 创建一个新的代码生成器，并创建请求、响应对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span> {
    <span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Generator</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Buffer</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span> = new(<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">CodeGeneratorRequest</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Response</span> = new(<span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">CodeGeneratorResponse</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">g</span>
}
</code></pre></div><h5 id="24332-generatorcommandlineparameters">2.4.3.3.2. generator.CommandLineParameters(&hellip;)</h5>
<p>这个函数是负责解析protoc传递过来的命令行参数信息的。</p>
<p>file: ${golang-protobuf}/protoc-gen-go/generator/generator.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 将都好分隔的key=value列表解析成&lt;key,value&gt; map
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">CommandLineParameters</span>(<span style="color:#a6e22e">parameter</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Param</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">parameter</span>, <span style="color:#e6db74">&#34;,&#34;</span>) {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;=&#34;</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">0</span> {
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Param</span>[<span style="color:#a6e22e">p</span>] = <span style="color:#e6db74">&#34;&#34;</span>
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Param</span>[<span style="color:#a6e22e">p</span>[<span style="color:#ae81ff">0</span>:<span style="color:#a6e22e">i</span>]] = <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
        }
    }

    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">ImportMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>)
    <span style="color:#a6e22e">pluginList</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;none&#34;</span> <span style="color:#75715e">// Default list of plugin names to enable (empty means all).
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Param</span> {
        <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">k</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;import_prefix&#34;</span>:
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">ImportPrefix</span> = <span style="color:#a6e22e">v</span>
        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;import_path&#34;</span>:
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">PackageImportPath</span> = <span style="color:#a6e22e">v</span>
        <span style="color:#75715e">// --go_out=plugins=grpc:.，解析这里的参数plugins=grpc
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;plugins&#34;</span>:
            <span style="color:#a6e22e">pluginList</span> = <span style="color:#a6e22e">v</span>
        <span style="color:#66d9ef">default</span>:
            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">k</span>) &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">k</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;M&#39;</span> {
                <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">ImportMap</span>[<span style="color:#a6e22e">k</span>[<span style="color:#ae81ff">1</span>:]] = <span style="color:#a6e22e">v</span>
            }
        }
    }

    <span style="color:#75715e">// 在protoc-gen-go的某个地方已经将grpc插件注册到了当前generator（也就是添
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 加到plugins []Plugin中），但是到底是在哪里注册的呢？只有注册并激活（参
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 数中通过--go_out=plugins=grpc:.)grpc子插件，该子插件才能被使用于后续的
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 代码生成过程中（生成rpc相关的go源代码）。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 其实这里的grpc子插件注册是利用了link_grpc.go里面的import _操作来隐式地
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 调用了grpc.init()方法，该初始化方法中负责完成向generator的注册操作，即
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// generator.RegisterPlugin(new(grpc))，这里的RegisterPlugin其实就是将指定
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 的子插件加入到plugins []Plugin slice中。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 为了能够在protoc-gen-go中正确地将grpc link进去，在构建protoc-gen-go的时
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 候需要执行命令：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// cd protoc-gen-go &amp; go build main.go link_grpc.go
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// go build的时候如果没有列出link_grpc.go，那么grpc是不会被link进
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// protoc-gen-go这个插件的，这样处理.proto文件中的service时插件是不会生成
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// service相关的go源代码的。
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 根据--go_out=plugins=?+?+?:.，更新激活的插件列表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pluginList</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
        <span style="color:#75715e">// Amend the set of plugins.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">enabled</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">pluginList</span>, <span style="color:#e6db74">&#34;+&#34;</span>) {
            <span style="color:#a6e22e">enabled</span>[<span style="color:#a6e22e">name</span>] = <span style="color:#66d9ef">true</span>
        }
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">nplugins</span> []<span style="color:#a6e22e">Plugin</span>
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">plugins</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">enabled</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Name</span>()] {
                <span style="color:#a6e22e">nplugins</span> = append(<span style="color:#a6e22e">nplugins</span>, <span style="color:#a6e22e">p</span>)
            }
        }
        <span style="color:#a6e22e">plugins</span> = <span style="color:#a6e22e">nplugins</span>
    }
}
</code></pre></div><h5 id="24333-generatorwraptypes">2.4.3.3.3. generator.WrapTypes()</h5>
<p>file: ${golang-protobuf}/protoc-gen-go/generator/generator.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// WrapTypes walks the incoming data, wrapping DescriptorProtos, EnumDescriptorProtos
</span><span style="color:#75715e">// and FileDescriptorProtos into file-referenced objects within the Generator.
</span><span style="color:#75715e">// It also creates the list of files to generate and so should be called before GenerateAllFiles.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">WrapTypes</span>() {
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span> = make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">ProtoFile</span>))
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFilesByName</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>, len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span>))
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">ProtoFile</span> {
        <span style="color:#75715e">// We must wrap the descriptors before we wrap the enums
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">descs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wrapDescriptors</span>(<span style="color:#a6e22e">f</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">buildNestedDescriptors</span>(<span style="color:#a6e22e">descs</span>)
        <span style="color:#a6e22e">enums</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wrapEnumDescriptors</span>(<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">descs</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">buildNestedEnums</span>(<span style="color:#a6e22e">descs</span>, <span style="color:#a6e22e">enums</span>)
        <span style="color:#a6e22e">exts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wrapExtensions</span>(<span style="color:#a6e22e">f</span>)
        <span style="color:#a6e22e">fd</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">FileDescriptor</span>{
            <span style="color:#a6e22e">FileDescriptorProto</span>: <span style="color:#a6e22e">f</span>,
            <span style="color:#a6e22e">desc</span>:                <span style="color:#a6e22e">descs</span>,
            <span style="color:#a6e22e">enum</span>:                <span style="color:#a6e22e">enums</span>,
            <span style="color:#a6e22e">ext</span>:                 <span style="color:#a6e22e">exts</span>,
            <span style="color:#a6e22e">exported</span>:            make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Object</span>][]<span style="color:#a6e22e">symbol</span>),
            <span style="color:#a6e22e">proto3</span>:              <span style="color:#a6e22e">fileIsProto3</span>(<span style="color:#a6e22e">f</span>),
        }
        <span style="color:#a6e22e">extractComments</span>(<span style="color:#a6e22e">fd</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span> = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span>, <span style="color:#a6e22e">fd</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFilesByName</span>[<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">GetName</span>()] = <span style="color:#a6e22e">fd</span>
    }
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">fd</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span> {
        <span style="color:#a6e22e">fd</span>.<span style="color:#a6e22e">imp</span> = <span style="color:#a6e22e">wrapImported</span>(<span style="color:#a6e22e">fd</span>.<span style="color:#a6e22e">FileDescriptorProto</span>, <span style="color:#a6e22e">g</span>)
    }

    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span> = make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">FileToGenerate</span>))
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">fileName</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Request</span>.<span style="color:#a6e22e">FileToGenerate</span> {
        <span style="color:#a6e22e">fd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFilesByName</span>[<span style="color:#a6e22e">fileName</span>]
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fd</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Fail</span>(<span style="color:#e6db74">&#34;could not find file named&#34;</span>, <span style="color:#a6e22e">fileName</span>)
        }
        <span style="color:#a6e22e">fd</span>.<span style="color:#a6e22e">index</span> = len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span> = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span>, <span style="color:#a6e22e">fd</span>)
    }
}

</code></pre></div><h5 id="24334-generatorgenerateallfiles">2.4.3.3.4. generator.GenerateAllFiles()</h5>
<p>调用generator针对所有解析成功的proto文件生成所有的go源代码</p>
<p>file: ${golang-protobuf}/protoc-gen-go/generator/generator.go</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 生成所有.proto文件对应的go源代码，这里只是将源代码内容存储到g.Response中，
</span><span style="color:#75715e">// 并没有直接创建源代码文件，插件将Response传递给protoc进程后由protoc进程来负
</span><span style="color:#75715e">// 责创建源代码文件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">GenerateAllFiles</span>() {
    <span style="color:#75715e">// Initialize the plugins
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">plugins</span> {
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Init</span>(<span style="color:#a6e22e">g</span>)
    }
    <span style="color:#75715e">// Generate the output. The generator runs for every file, even the files
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// that we don&#39;t generate output for, so that we can collate the full list
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// of exported symbols to support public imports.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">genFileMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>]<span style="color:#66d9ef">bool</span>, len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span>))
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">file</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">genFiles</span> {
        <span style="color:#a6e22e">genFileMap</span>[<span style="color:#a6e22e">file</span>] = <span style="color:#66d9ef">true</span>
    }
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">file</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">allFiles</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Reset</span>()
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">writeOutput</span> = <span style="color:#a6e22e">genFileMap</span>[<span style="color:#a6e22e">file</span>]

        <span style="color:#75715e">// 调用generator的generate(...)方法来生成该proto文件的
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// FileDescriptorProto描述对应的go源代码
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generate</span>(<span style="color:#a6e22e">file</span>)

        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">writeOutput</span> {
            <span style="color:#66d9ef">continue</span>
        }
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Response</span>.<span style="color:#a6e22e">File</span> = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Response</span>.<span style="color:#a6e22e">File</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">plugin</span>.<span style="color:#a6e22e">CodeGeneratorResponse_File</span>{
            <span style="color:#a6e22e">Name</span>:    <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">String</span>(<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">goFileName</span>()),
            <span style="color:#a6e22e">Content</span>: <span style="color:#a6e22e">proto</span>.<span style="color:#a6e22e">String</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">String</span>()),
        })
    }
}
</code></pre></div><p>再看下generator.generate(&hellip;)方法是如何实现的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 针对.proto文件（由FileDescriptor表示）生成对应的go源代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">generate</span>(<span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>) {
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span> = <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">FileOf</span>(<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">FileDescriptorProto</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">usedPackages</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)

    <span style="color:#75715e">// 要生成源代码的首个proto文件对应的go源代码，这部分代码顶部插入版权信息
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">index</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#75715e">// For one file in the package, assert version compatibility.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// This is a compile-time assertion to ensure that this generated file&#34;</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// is compatible with the proto package it is being compiled against.&#34;</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// A compilation error at this line likely means your copy of the&#34;</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// proto package needs to be updated.&#34;</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;const _ = &#34;</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Pkg</span>[<span style="color:#e6db74">&#34;proto&#34;</span>], <span style="color:#e6db74">&#34;.ProtoPackageIsVersion&#34;</span>, <span style="color:#a6e22e">generatedCodeVersion</span>, <span style="color:#e6db74">&#34; // please upgrade the proto package&#34;</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()
    }

    <span style="color:#75715e">// 生成import语句
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">td</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">imp</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateImported</span>(<span style="color:#a6e22e">td</span>)
    }
    <span style="color:#75715e">// 生成enum类型定义语句
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">enum</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">enum</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateEnum</span>(<span style="color:#a6e22e">enum</span>)
    }
    <span style="color:#75715e">// 生成message类型定义语句
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">desc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">desc</span> {
        <span style="color:#75715e">// Don&#39;t generate virtual messages for maps.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">desc</span>.<span style="color:#a6e22e">GetOptions</span>().<span style="color:#a6e22e">GetMapEntry</span>() {
            <span style="color:#66d9ef">continue</span>
        }
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateMessage</span>(<span style="color:#a6e22e">desc</span>)
    }
    <span style="color:#75715e">// 生成extension类型定义语句
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ext</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">ext</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateExtension</span>(<span style="color:#a6e22e">ext</span>)
    }
    <span style="color:#75715e">// 生成初始化函数语句
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateInitFunction</span>()

    <span style="color:#75715e">// 前面生成enum、message、extension等的方式都基本类似，后面我们只给出一个
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 生成枚举类型方法的说明，生成message、extension的实现方法可以执行查看
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// generator.go中的实现。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 需要注意的是，前面的各个生成源代码的方法不能处理service服务定义的rpc接
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 口代码，这部分rpc代码的生成需要借助于grpc子插件来完成，即下面的g.runPlugins(...)
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">runPlugins</span>(<span style="color:#a6e22e">file</span>)

    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateFileDescriptor</span>(<span style="color:#a6e22e">file</span>)

    <span style="color:#75715e">// 待输出的源代码需要知道哪些package是需要import的，哪些不需要，因此先运行
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 插件生成go代码中除import之外的其他部分代码，然后知道了哪些package需要
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// import，再插入具体的import语句。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 最后在go源代码中插入header、import
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">rem</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Buffer</span>
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Buffer</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateHeader</span>()
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateImports</span>()
    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">writeOutput</span> {
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">rem</span>.<span style="color:#a6e22e">Bytes</span>())

    <span style="color:#75715e">// 重新格式化生成的go源代码（gofmt）
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fset</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">NewFileSet</span>()
    <span style="color:#a6e22e">raw</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Bytes</span>()
    <span style="color:#a6e22e">ast</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">ParseFile</span>(<span style="color:#a6e22e">fset</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">parser</span>.<span style="color:#a6e22e">ParseComments</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// Print out the bad code with line numbers.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// This should never happen in practice, but it can while changing generated code,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// so consider this a debugging aid.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">src</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>
        <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewScanner</span>(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">raw</span>))
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Scan</span>(); <span style="color:#a6e22e">line</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">src</span>, <span style="color:#e6db74">&#34;%5d\t%s\n&#34;</span>, <span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Bytes</span>())
        }
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Fail</span>(<span style="color:#e6db74">&#34;bad Go source code was generated:&#34;</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">src</span>.<span style="color:#a6e22e">String</span>())
    }
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Reset</span>()
    <span style="color:#a6e22e">err</span> = (<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">printer</span>.<span style="color:#a6e22e">Config</span>{<span style="color:#a6e22e">Mode</span>: <span style="color:#a6e22e">printer</span>.<span style="color:#a6e22e">TabIndent</span> | <span style="color:#a6e22e">printer</span>.<span style="color:#a6e22e">UseSpaces</span>, <span style="color:#a6e22e">Tabwidth</span>: <span style="color:#ae81ff">8</span>}).<span style="color:#a6e22e">Fprint</span>(<span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">fset</span>, <span style="color:#a6e22e">ast</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Fail</span>(<span style="color:#e6db74">&#34;generated Go source code could not be reformatted:&#34;</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
    }
}

</code></pre></div><p>上面generate.generate(&hellip;)方法中generateEnum()、generateMessage()方法与其他几个方法都是非常类似的，由于大家使用protobuf过程中使用enum、message比较多，并且generateEnum()、generateMessage()方法执行逻辑非常相似，考虑到篇幅方面generateEnum()比generateMessage()简短，这里我们就只以generateEnum()的源代码作为示例进行分析。相信如果看懂了generateEnum的实现思路，generateMessage的实现思路也很容易搞明白，读者也具备了自己实现子插件的能力。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 生成指定enum类型的go源代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">generateEnum</span>(<span style="color:#a6e22e">enum</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EnumDescriptor</span>) {
    <span style="color:#75715e">// enum类型的完整类型名
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeName</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">TypeName</span>()
    <span style="color:#75715e">// CamelCased之后的完整类型名
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ccTypeName</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">CamelCaseSlice</span>(<span style="color:#a6e22e">typeName</span>)
    <span style="color:#a6e22e">ccPrefix</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">prefix</span>()

    <span style="color:#75715e">// 打印enum类型定义之前的leading comments
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 提取源代码信息SourceCodeInfo都是通过Location path来获取的；
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 提取注释信息也不例外，下面我们会介绍PrintComments(path)如何通过
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//   Location path来生成注释信息；
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">PrintComments</span>(<span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">path</span>)

    <span style="color:#75715e">// 生成枚举类型的定义起始部分：type 枚举类型名 int32
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;type &#34;</span>, <span style="color:#a6e22e">ccTypeName</span>, <span style="color:#e6db74">&#34; int32&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">addExport</span>(<span style="color:#a6e22e">enum</span>, <span style="color:#a6e22e">enumSymbol</span>{<span style="color:#a6e22e">ccTypeName</span>, <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">proto3</span>()})

    <span style="color:#75715e">// 枚举类型里面的各个枚举值都作为const int32常量来定义
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;const (&#34;</span>)

    <span style="color:#75715e">// 枚举值定义之前缩进一下
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">In</span>()

    <span style="color:#75715e">// 针对枚举类型里面的所有枚举值进行源代码生成
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">Value</span> {
        <span style="color:#75715e">// 生成枚举值前面的leading comments
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">PrintComments</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s,%d,%d&#34;</span>, <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">enumValuePath</span>, <span style="color:#a6e22e">i</span>))
        <span style="color:#75715e">// 生成枚举值的name = value形式的go源代码
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ccPrefix</span> <span style="color:#f92672">+</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Name</span>
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#a6e22e">ccTypeName</span>, <span style="color:#e6db74">&#34; = &#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Number</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">addExport</span>(<span style="color:#a6e22e">enum</span>, <span style="color:#a6e22e">constOrVarSymbol</span>{<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34;const&#34;</span>, <span style="color:#a6e22e">ccTypeName</span>})
    }

    <span style="color:#75715e">// 枚举值定义完之后取消缩进
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Out</span>()

    <span style="color:#75715e">// 打印最后的结束信息
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;)&#34;</span>)

    <span style="color:#75715e">// 生成枚举类型相关的两个map
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 其中一个是枚举值到枚举名的映射；
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 另一个是枚举名到枚举值的映射；
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;var &#34;</span>, <span style="color:#a6e22e">ccTypeName</span>, <span style="color:#e6db74">&#34;_name = map[int32]string{&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">In</span>()
    <span style="color:#75715e">// 第一个map
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">generated</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int32</span>]<span style="color:#66d9ef">bool</span>) <span style="color:#75715e">// avoid duplicate values
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">Value</span> {
        <span style="color:#a6e22e">duplicate</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">present</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">generated</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Number</span>]; <span style="color:#a6e22e">present</span> {
            <span style="color:#a6e22e">duplicate</span> = <span style="color:#e6db74">&#34;// Duplicate value: &#34;</span>
        }
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#a6e22e">duplicate</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Number</span>, <span style="color:#e6db74">&#34;: &#34;</span>, <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Quote</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Name</span>), <span style="color:#e6db74">&#34;,&#34;</span>)
        <span style="color:#a6e22e">generated</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Number</span>] = <span style="color:#66d9ef">true</span>
    }
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Out</span>()
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;}&#34;</span>)
    <span style="color:#75715e">// 第二个map
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;var &#34;</span>, <span style="color:#a6e22e">ccTypeName</span>, <span style="color:#e6db74">&#34;_value = map[string]int32{&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">In</span>()
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">enum</span>.<span style="color:#a6e22e">Value</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Quote</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Name</span>), <span style="color:#e6db74">&#34;: &#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Number</span>, <span style="color:#e6db74">&#34;,&#34;</span>)
    }
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Out</span>()
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;}&#34;</span>)

    <span style="color:#75715e">// 其他处理动作，也会生成部分源代码，这里可以忽略不计了
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>下面看一下PrintComments如何通过Location path来提取并打印关联的注释信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 打印.proto文件中对该location path关联的leading comments注释信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">PrintComments</span>(<span style="color:#a6e22e">path</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">writeOutput</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
    }

    <span style="color:#75715e">// 在protoc进程解析.proto文件的时候就已经将各个类型、字段的comments信息维
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 护起来了，k就是location的path，通过path就能获取到对应的location，每个
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// location中保存了这个位置的源代码的leading comments、trailing comments信
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 息，这里只打印leading comments
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">loc</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">comments</span>[<span style="color:#a6e22e">path</span>]; <span style="color:#a6e22e">ok</span> {
        <span style="color:#a6e22e">text</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSuffix</span>(<span style="color:#a6e22e">loc</span>.<span style="color:#a6e22e">GetLeadingComments</span>(), <span style="color:#e6db74">&#34;\n&#34;</span>)
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">line</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">text</span>, <span style="color:#e6db74">&#34;\n&#34;</span>) {
            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// &#34;</span>, <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimPrefix</span>(<span style="color:#a6e22e">line</span>, <span style="color:#e6db74">&#34; &#34;</span>))
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}
</code></pre></div><p>看到这里我们对于基本的enum、message类型定义等都基本清楚了，下面我们需要看一下grpc子插件是如何生成service服务的rpc接口源代码的，这样的话，就得再来看一下g.runPlugins(file)是如何实现的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Run all the plugins associated with the file.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Generator</span>) <span style="color:#a6e22e">runPlugins</span>(<span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FileDescriptor</span>) {
    <span style="color:#75715e">// 在上述generator处理的基础上，继续运行generator中注册的插件，依次运行插件
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">plugins</span> {
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">file</span>)
    }
}
</code></pre></div><p>因为上述runPlugins(&hellip;)执行过程中，plugins这个slice内只有一个有效的、激活的子插件grpc，因此如果我们想了解service服务对应的rpc接口的实现方式，我们需要就只需要了解grpc这个插件的Generate(file)方法就可以了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 生成.proto文件中service定义的rpc接口的go源代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">grpc</span>) <span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">FileDescriptor</span>) {

    <span style="color:#75715e">// 如果没有定义service服务直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">FileDescriptorProto</span>.<span style="color:#a6e22e">Service</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span>
    }

    <span style="color:#75715e">// 相关变量定义
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// Reference imports to suppress errors if they are not otherwise used.&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;var _ &#34;</span>, <span style="color:#a6e22e">contextPkg</span>, <span style="color:#e6db74">&#34;.Context&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;var _ &#34;</span>, <span style="color:#a6e22e">grpcPkg</span>, <span style="color:#e6db74">&#34;.ClientConn&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// 断言，检查版本兼容性
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// This is a compile-time assertion to ensure that this generated file&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// is compatible with the grpc package it is being compiled against.&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;const _ = &#34;</span>, <span style="color:#a6e22e">grpcPkg</span>, <span style="color:#e6db74">&#34;.SupportPackageIsVersion&#34;</span>, <span style="color:#a6e22e">generatedCodeVersion</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// 针对所有的service定义生成相关的service的go源代码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">service</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">FileDescriptorProto</span>.<span style="color:#a6e22e">Service</span> {
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateService</span>(<span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">service</span>, <span style="color:#a6e22e">i</span>)
    }
}

<span style="color:#75715e">// grpc中对generateService的实现，生成service相关的go源代码
</span><span style="color:#75715e">// @param .proto解析后的各种DescriptorProto的wrapping类，通过它可以方便地访问.proto中定义的东西 
</span><span style="color:#75715e">// @param .proto中的某个service解析后对应的ServiceDescriptorProto
</span><span style="color:#75715e">// @param .proto中可能定义了多个service，当前这个service对应的索引值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">grpc</span>) <span style="color:#a6e22e">generateService</span>(<span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">FileDescriptor</span>, <span style="color:#a6e22e">service</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pb</span>.<span style="color:#a6e22e">ServiceDescriptorProto</span>, <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#75715e">// 构建当前service对应的path!
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">path</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;6,%d&#34;</span>, <span style="color:#a6e22e">index</span>) <span style="color:#75715e">// 6 means service.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 获取service名称
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">origServName</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">service</span>.<span style="color:#a6e22e">GetName</span>()
    <span style="color:#a6e22e">fullServName</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">origServName</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pkg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">GetPackage</span>(); <span style="color:#a6e22e">pkg</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
        <span style="color:#a6e22e">fullServName</span> = <span style="color:#a6e22e">pkg</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">fullServName</span>
    }
    <span style="color:#a6e22e">servName</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">CamelCase</span>(<span style="color:#a6e22e">origServName</span>)

    <span style="color:#75715e">// 准备生成client相关的go源代码
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// Client API for &#34;</span>, <span style="color:#a6e22e">servName</span>, <span style="color:#e6db74">&#34; service&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// 服务用户端go源代码生成
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - type 服务名+Client interface
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;type &#34;</span>, <span style="color:#a6e22e">servName</span>, <span style="color:#e6db74">&#34;Client interface {&#34;</span>)
    <span style="color:#75715e">// - 服务用户端定义的各个接口方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">method</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">service</span>.<span style="color:#a6e22e">Method</span> {

        <span style="color:#75715e">// 打印接口的leading comments
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">PrintComments</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s,2,%d&#34;</span>, <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">i</span>)) <span style="color:#75715e">// 2 means method in a service.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 生成接口的签名
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateClientSignature</span>(<span style="color:#a6e22e">servName</span>, <span style="color:#a6e22e">method</span>))
    }
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;}&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// 服务的用户端struct，其中包括了一个cc *grpc.ClientConn，后面会在该struct
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 上实现上述服务接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;type &#34;</span>, <span style="color:#a6e22e">unexport</span>(<span style="color:#a6e22e">servName</span>), <span style="color:#e6db74">&#34;Client struct {&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;cc *&#34;</span>, <span style="color:#a6e22e">grpcPkg</span>, <span style="color:#e6db74">&#34;.ClientConn&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;}&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// NewClient工厂 
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;func New&#34;</span>, <span style="color:#a6e22e">servName</span>, <span style="color:#e6db74">&#34;Client (cc *&#34;</span>, <span style="color:#a6e22e">grpcPkg</span>, <span style="color:#e6db74">&#34;.ClientConn) &#34;</span>, <span style="color:#a6e22e">servName</span>, <span style="color:#e6db74">&#34;Client {&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;return &amp;&#34;</span>, <span style="color:#a6e22e">unexport</span>(<span style="color:#a6e22e">servName</span>), <span style="color:#e6db74">&#34;Client{cc}&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;}&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">methodIndex</span>, <span style="color:#a6e22e">streamIndex</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">serviceDescVar</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">servName</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_serviceDesc&#34;</span>

    <span style="color:#75715e">// 服务用户端的接口方法实现
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">method</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">service</span>.<span style="color:#a6e22e">Method</span> {
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">descExpr</span> <span style="color:#66d9ef">string</span>
        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">method</span>.<span style="color:#a6e22e">GetServerStreaming</span>() <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">method</span>.<span style="color:#a6e22e">GetClientStreaming</span>() {
            <span style="color:#75715e">// Unary RPC method
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">descExpr</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;&amp;%s.Methods[%d]&#34;</span>, <span style="color:#a6e22e">serviceDescVar</span>, <span style="color:#a6e22e">methodIndex</span>)
            <span style="color:#a6e22e">methodIndex</span><span style="color:#f92672">++</span>
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Streaming RPC method
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">descExpr</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;&amp;%s.Streams[%d]&#34;</span>, <span style="color:#a6e22e">serviceDescVar</span>, <span style="color:#a6e22e">streamIndex</span>)
            <span style="color:#a6e22e">streamIndex</span><span style="color:#f92672">++</span>
        }
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">generateClientMethod</span>(<span style="color:#a6e22e">servName</span>, <span style="color:#a6e22e">fullServName</span>, <span style="color:#a6e22e">serviceDescVar</span>, <span style="color:#a6e22e">method</span>, <span style="color:#a6e22e">descExpr</span>)
    }

    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>(<span style="color:#e6db74">&#34;// Server API for &#34;</span>, <span style="color:#a6e22e">servName</span>, <span style="color:#e6db74">&#34; service&#34;</span>)
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">P</span>()

    <span style="color:#75715e">// 服务端接口go源代码生成
</span><span style="color:#75715e"></span>    <span style="color:#f92672">...</span>
}
</code></pre></div><p>看完之后我们已经清楚了generator做了什么、grpc子插件又做了什么，以及各自的细节是什么样的。下面我们将在此学习、理解的基础上开发一个自己的protoc插件。</p>

        </div>
        

    </div>

    <div align="center">
        
<div class="blog-share">
    分享：
    
    <a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Protoc%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%20https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fab fa-twitter"></i>
        <span class="hidden">Twitter</span>
    </a>
    
    
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f"  onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="fab fa-facebook-f"></i>
        <span class="hidden">Facebook</span>
    </a>
    
    
    <a class="icon-pinterest" href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f&amp;description=Protoc%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90" onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
        <i class="fab fa-pinterest-p"></i>
        <span class="hidden">Pinterest</span>
    </a>
    
    
    <a class="icon-google-plus" href="https://plus.google.com/share?url=https%3a%2f%2fhitzhangjie.github.io%2fblog%2f2017-05-16-protoc%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%2f" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <i class="fab fa-google-plus-g"></i>
        <span class="hidden">Google+</span>
    </a>
    
</div>



    </div>

    
    <br>
    <br>
    <div style="height:auto;align:center;text-align:center;"> 
        <div>
            <p>
                ~~~ 如果文章对您有帮助，请记得打赏哦。帮我家小七🐶、元宝🐱改善下伙食吧，😘 ~~~
            </p>
        </div>

        <div>
            <img src="/common/xiaoqi.png" style="height:238px;margin-top:10px;margin-right:5px;"/>
            <img src="/common/qrcode.jpg" style="height:238px;margin-top:10px;"/>
            <img src="/common/yuanbao.png" style="height:238px;margin-top:10px;margin-left:5px;"/>
        </div>
    </div>

    


                
                <div class="container">
    <hr>
</div>
<div class="container has-text-centered top-pad">
    <a href="#top">
        <i class="fa fa-arrow-up"></i>
    </a>
</div>

<div class="container">
    <hr>
</div>

                <div class="section" id="footer">
    <div class="container has-text-centered">
    
        <span class="footer-text">
            <a href="https://github.com/victoriadrake/hugo-theme-introduction/"><strong>Introduction</strong></a> 主题为 <a href="http://gohugo.io/">Hugo</a> 而设。由开源社群贡献者以 <a href="https://victoria.dev"><!-- raw HTML omitted --><!-- raw HTML omitted --> 和 <!-- raw HTML omitted --><!-- raw HTML omitted --></a> 创造。
        </span>
    
    </div>
</div>

                
            </div>
        </section>
        
        


<script src="https://hitzhangjie.github.io/js/bundle.e6934e69d06bb8a213134f4c1468f9478bb7755e786dfb60e3c5a917c5335805.js" integrity="sha256-5pNOadBruKITE09MFGj5R4u3dV54bftg48WpF8UzWAU="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168027530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


        
        
        
        
    </body>
</html>
