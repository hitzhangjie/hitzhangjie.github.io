<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>closure on</title><link>/tags/closure/</link><description>Recent content in closure on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sat, 19 May 2018 19:55:15 +0800</lastBuildDate><atom:link href="/tags/closure/index.xml" rel="self" type="application/rss+xml"/><item><title>golang function-closure 实现机制</title><link>/blog/2018-05-19-golang-function-closure%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 19 May 2018 19:55:15 +0800</pubDate><guid>/blog/2018-05-19-golang-function-closure%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</guid><description>golang里面函数时first-class citizen，可以作为值进行参数传递，不管是普通函数“func abc()”，还是成员方法“func (x X) xxx()”，还是一个闭包“func () { return func(){&amp;hellip;.}}”……看上去很方便，不禁要问，golang里面funciton和closure是如何实现的呢？扒拉了下源码，这里简单总结下。
1 golang中函数内部表示是什么样子的？ # 看下golang cmd/compile/internal/types/type.go中对Func类型的定义：
// Func contains Type fields specific to func types. type Func struct { Receiver *Type // function receiver，接受者类型，每个函数定义都包括该字段，可以为nil或non-nil Results *Type // function results，返回值类型 Params *Type // function params，参数列表类型 Nname *Node // function name，函数名 // Argwid is the total width of the function receiver, params, and results. // It gets calculated via a temporary TFUNCARGS type. // Note that TFUNC's Width is Widthptr.</description></item></channel></rss>