<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unix on</title><link>/tags/unix/</link><description>Recent content in unix on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sun, 19 May 2024 09:10:25 +0800</lastBuildDate><atom:link href="/tags/unix/index.xml" rel="self" type="application/rss+xml"/><item><title>Bash常用命令</title><link>/blog/2016-01-07-bash%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 19 May 2024 09:10:25 +0800</pubDate><guid>/blog/2016-01-07-bash%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是一些日常高频使用的linux命令。
lp : submit files and print pwd : print current work directory match pattern in bash : ? * [] extension of '{}' : b{ed,olt,ar}s ls *.{c,h,o} i/o : cat : copy input to output grep: match lines from input sort: sort lines from input cut : extract columns from input how to set the delimiter to space? note: -d' ' only specify space as the delimiter,not including tab,so it's inconvenient when files contain both of space and tab.</description></item><item><title>Debian系使用笔记</title><link>/blog/2016-01-07-debian%E7%B3%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 07 Jan 2016 09:43:00 +0800</pubDate><guid>/blog/2016-01-07-debian%E7%B3%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是一些日常高频使用的linux命令。
1）linux 文件目录树与磁盘分区 一块硬盘最多有4个主分区，可以将其中的主分区设置为扩展分区，然后在扩展分区中再继续划分为多个逻辑分区，从而得道更多的分区。 linux中，磁盘分区的命名方式是hdcn（ide ata硬盘）或sdcn（scsi 硬盘/sata 硬盘/usb 硬盘等），其中的c表示编号，从a开始。比如hda和hdb分别代表ide0插口上的主盘和从盘，而n则是分区编号，1～4对应该磁盘的4个可能的主分区或者扩展分区，5之后的都是逻辑分区来。 比如我的电脑是划分来3个主分区，其中一个主分区被设置为扩展分区，它们的编号分别为sda1，sda2，sda3。sda3被设为扩展分区，然后将其划分成来6个逻辑分区，编号为sda5～sda10。 不管是linux还是windows系统，每个分区的文件系统都会组织成一个目录树，对于windows系统来讲，通常每棵目录树都是并列的，并且每一个分区都分配一个盘符，由此可以确定任意文件在整个系统中的确切位置。 而对于linux系统来说，所有分区都被组织在同一个目录树上，选取一个分区作为目录树的根，其余的分区上的文件系统都被挂载到这个根目录树上的某个节点上。 相比之下，可以看出linux系统这种组织方式的优点。windows系统中，如果盘符发生了变动，并且分区中如果有与系统盘中关联的程序，那么这些程序的运行将受到影响，因为他们的程序路径发生来变动，可能环境变量等等已经失效了。而在linux系统中，如果将改动了分区，那么只需要重新改动下对应分区在根分区上的挂载点就可以了。 2）内核/模块/基本库 概念 提到linux系统时，多半是指整个操作系统，但是实际上，linux仅仅是系统的内核部分。 linux不是微内核。 通常内核不直接与我们交互，他们工作在硬件和软件之间，主要完成两大类任务：帮助软件获取硬件资源的控制权，并操控硬件；协调各个软件，让他们和谐统一地工作。 内核得天独厚的优势是：拥有系统中的最高权限。 可以将程序运行状态分为：核心态和用户态。只有极少数的核心态程序才能操纵硬件。 作为核心态程序的内核提供给用户态程序的接口称为系统调用。 内核的具体工作包括内存管理/进程调度/文件系统管理/网络通信/进程间通信，这些工作都可一划分成多种工作方式，以适应不通的需求，此外还需要驱动大量的硬件工作，所以内核的工作量是非常大的。 对于内核的设计，采取如下策略，以减少内核工作量和错误发生率： 如果工作可以在用户空间完成，就不要放入内核中，这就是所谓的微内核技术，但是linux不是微内核，但是也在逐渐地将一些可以在用户空间中完成的任务放入用户空间中。 如果内核某项工作可以做成独立的模块，那么就允许将其设计为独立的模块，然后在需要该模块的时候，再将其加载运行。 3）文件与文件系统 文件在linux系统中，是个非常重要的概念，除了普通文件之外，对于所有的设备，linux也一并将其看作是文件，像对待文件一样对他们进行操作。 在linux系统中，除了一些普通文件之外，还有其他一些特殊类型的文件，这些文件在/dev目录下基本上都可以看到。 ls -l /dev： 根据开头的第一个字符判断文件类型： -:普通文件 d:文件目录 l:符号链接文件 c:字符设备文件，如键盘 b:块设备文件，如硬盘 f:fifo文件，队列 s:socket文件，linux中，socket既可以用来进行网络通信，也可以用于进程间通信 4）环境变量与shell 父进程的环境变量可以被子进程继承，子进程对环境变量的修改不会影响父进程。 5）网络与服务 这里主要理解daemon的意思吧，也就是daemon进程，守护进程的概念。 守护进程，就是一直处于运行状态，它监视某种事件的发生，比如有客户端请求，然后它就提供必要的服务，如果没有客户端请求，那么它就处于等待状态，等待客户端请求。 6）cat命令与tac命令 cat命令是“连接”一词的缩写形式，如果指定的参数为多个文件，它会将这几个文件衔接起来，如果通过重定向的形式将内容输出到一个新的文件，就可以实现将文件合并的功能。 tac命令，跟cat命令类似，但是它是反序的。 7）gzip与bizp2 gzip与bzip2这两个压缩程序，可以与tar实现无缝衔接，tar命令在使用的时候，常常使用选项-z或者-j，分别代表gzip和bzip2，当然对应的文件扩展名有所变化，分别为*.tar.gz和*.tar.bz2。 常用的选项-c表示compress，即压缩，-x表示解压。 -z表示使用gzip，-j表示使用bzip2。 -v表示输出压缩解压缩的文件列表。 -f表示对文件进行压缩解压。 apt-cache 强大的apt查询工具 9）dpkg apt的底层软件工具 dpkg一个比较实用的方法使用来备份系统已经安装的软件列表，以便重装系统之后，快速恢复系统中需要的软件，相当于对系统的一次克隆。 备份软件安装列表： dpkg --get-selections &amp;gt; installedApp 将安装列表中的软件安装到系统： dpkg --set-selections &amp;lt; installedApp sudo apt-get dselect-upgrade 也可以如下操作： dpkg --get-selections | grep -v deinstall &amp;gt; installedApp dpkg --set-selections &amp;lt; installedApp sudo dselect screen 可以实现在一个终端窗口中生成多个终端，方便实用，尤其是在非x-window工作状态下，screen的重要性就体现的更加明显。 ctrl+a,c to create a session ctrl+a,p go previous session ctrl+a,n go next session ctrl+a,N go to the session numbered 'N' ctrl+a,' go to the seesion named by 'ctrl+a,A' ctrl+a,&amp;quot; list all session and choose which to go ctrl+a,A rename current session ctrl+a,d detach current screen's display,leaving current session keeping on running mc 命令行下的文件管理器 除了对文件的相关操作之外，还可以登录ftp服务器。 12） w3m 命令行下的www浏览工具 使用上下左右箭头可以在网页中移动，当移到某个超链接上后，可以通过回车健进行跳转。如果是在页面中的输入框中输入信息，首先敲击回车键，然后就可以输入信息来。 13） wget与curl 命令行与后台下载工具 14） grub菜单举例 #default =0 # 0 is the default timeout =5 root (hda1,6) splashimage /boot/grub/debian-boot.</description></item><item><title>Linux桌面发行版CentOS</title><link>/blog/2015-01-14-linux%E6%A1%8C%E9%9D%A2%E5%8F%91%E8%A1%8C%E7%89%88centos/</link><pubDate>Wed, 14 Jan 2015 00:30:02 +0800</pubDate><guid>/blog/2015-01-14-linux%E6%A1%8C%E9%9D%A2%E5%8F%91%E8%A1%8C%E7%89%88centos/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Linux发行版使用过程中一些常用设置。
中文输入法 安装完centos之后，在输入法中默认是没有添加中文输入法的，这个时候，运行 ibus-setup添加上中文输入法，具体的方式是，首先选择语言为中文，然后找到展开中文 就可以看到下面的好几个输入法，选择简体中文。然后通过system settings-&amp;gt;input method selector选择输入法框架为ibus，登出后重新登陆即可。
经过安装测试，在fedora 21中进行了安装测试，配置过程是一样的。 但是测试后也发现，在fedora中的ibus-pinyin工作起来不如在centos下效果好，经 过一段时间的使用之后换成了fcitx，目前还在使用过程中，其实我想的是，如果 fcitx 中自带的输入法如果不好用的话，后面我就直接换成sogou输入法。
从本地安装源安装软件 我之前下载的是centos-everything.iso，大约有7个G，里面包含了很多软件，为了 减少下载软件花费的时间，我们可以将这个压缩包解压到指定目录，然后将其作为本地安 装源进行软件的安装。 在实际安装之前，我们需要首先在/etc/yum.repos.d/下面创建一个配置文件，该配 置文件告诉yum在搜索软件包的时候优先搜索本地软件源。该配置文件内容如下：
[Local] name=Local Repo baseurl=file:///media/cdrom gpgkey=file:///RPM-GPG-KEY-CentOS-7 gpgcheck=1 enabled=1
该配置文件中写明了软件源为目录/media/cdrom，所以我们将iso解压后的所有内容 应该放在/media/cdrom，也可以根据实际情况更改合适的路径名。
桌面环境 我安装了kde-plasma 4和gnome 3两种桌面环境，kde是我一直以来都比较喜欢的，至 于gnome3，在ubuntu下面的gnome3真心觉得很差劲，估计是centos将其优化了以下吧，感 觉还不错。
显示管理器 centos7默认使用的显示管理器是gdm，不过我还是比较喜欢kdm，但是发现现在已经 centos官方源中已经没有kdm这个软件了。甚至，在kde的相关配置界面中，也找不到kdm 相关的login登陆相关的设置了。 这让我想起了一件事。之前安装centos7时，安装了很多第三方软件包后，从第三方 软件库中安装了kdm，结果导致系统无法启动图形界面。估计可能是rhel官方修改了某些 重要文件，这个还得等到后面我再再行测试。
plymouth设置启动界面
安装epel软件源，并从中安装wine。 我是从epel上面安装的wine，但是这里安装的wine是64位的，而且epel官方也声明了 ，该wine包只支持64位windows程序。注意这一点，如果非要运行windows程序，那么就要 确保该程序是64位的。
正是因为这个原因，我新下载了foxit reader的64位版本。ubuntu上的wine既能够支 持64位，也能够支持32位。
安装软件源rpmforge rpmforge上面有大约5000多个软件包，……，我是要解压说rar文件的时候，发现没有 这个程序，google了下发现了第三方软件源rpmforge。
wget http://pkgs.</description></item><item><title>Linux内核文档索引</title><link>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</link><pubDate>Fri, 24 Oct 2014 00:10:00 +0800</pubDate><guid>/blog/2014-10-24-linux%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E7%B4%A2%E5%BC%95/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文是看内核源码时对文档的一个阅读、内容总结。
============================================================================= Fri Sep 18 12:23:06 CST 2014 # Documentation/
[1] zorro.txt zorro bus ii\iiioZorro II is the name of the general purpose expansion bus used by the Amiga 2000 computer. The bus is mainly a buffered extension of the Motorola 68000 bus, with support for bus mastering DMA. The expansion slots use a 100-pin connector and the card form factor is the same as the IBM PC. Zorro II cards implement the Autoconfig protocol for automatic address space assignment (designed before, yet similar to, Plug and Play on the PC).</description></item><item><title>Linux内联汇编基础</title><link>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</link><pubDate>Wed, 01 Oct 2014 00:16:34 +0800</pubDate><guid>/blog/2014-10-01-linux%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是阅读内核源码《Linux内核源码情景分析》时对内联汇编的一些总结。
1.full template __asm__(assembler template :output operands /* optional */ :input operands /* optional */ :list of clobbered registers /* optional */ ); 2.x86 registers eax,ebx,ecx,edx edi,esi ebp,esp eip eflags 3.linux代码中很多地方都使用了这种形式的汇编语言，嵌入汇编程序的格式如下： __asm__ __volatile__ ( asm statements : outputs : inputs : registers-modified ); asm statements是一组AT&amp;amp;T格式的汇编语言语句，每个语句一行，由\n分隔各行。所有的语句都被包裹在一对双引号内。其中使用的寄存器前面要加两个%%做前缀(%n表示参数,n:数字)；转移指令多是局部转移，因此多使用数字标号。 inputs指明程序的输入参数，每个输入参数都括在一对圆括号内，各参数用逗号分开。每个参数前加一个用双引号括起来的标志，告诉编译器把该参数装入到何处。 可用的标志有： “g”：让编译器决定如何装入它； “a”：装入到ax/eax； “b”：装入到bx/ebx； “c”：装入到cx/ecx； “d”：装入到dx/edx； “D”：装入到di/edi； “S”：装入到si/esi； “q”：a、b、c、d寄存器等； “r”：任一通用寄存器； “i”：整立即数； “I”：0-31 之间的立即数（用于32位移位指令）； “J”：0-63 之间的立即数（用于64 位移位指令）； “N”：0-255 ，之间的立即数（用于out 指令）； “n”：立即数，有些系统不支持除字以外的立即数，这些系统应该使用“n”而不是“i”； “p”：有效内存地址； “m”：内存变量； “o”：操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址； “V”：操作数为内存变量，但寻址方式不是偏移量类型； “,”：操作数为内存变量，但寻址方式为自动增量； “X”：操作数可以是任何类型； “f”：浮点数； “t”：第一个浮点寄存器； “u”：第二个浮点寄存器； “G”：标准的80387； % ：浮点常数,该操作数可以和下一个操作数交换位置； “=”：输出； “+”：既是输入又是输出； “&amp;amp;”：改变其值之前写,分配一个独立的寄存器,使得函数返回值和该变量不因为重复使用同一个寄存器,出现数据覆盖； “%”：与下一个操作数之间可互换； “#”：忽略其后的字符，直到逗号； “*”：当优先选择寄存器时，忽略下面的字符； “0”~“9”：指定一个操作数，它既做输入又做输出。通常用“g”； outputs指明程序的输出位置，通常是变量。每个输出变量都括在一对圆括号内，各个输出变量间用逗号隔开。每个输出变量前加一个标志，告诉编译器从何处输出。 可用的标志与输入参数用的标志相同，只是前面加“=”。如“=g”。输出操作数必须是左值，而且必须是只写的。如果一个操作数即做输出又做输 入，那么必须将它们分开：一个只写操作数，一个输入操作数。输入操作数前加一个数字限制（0~9），指出输出操作数的序号，告诉编译器它们必须在同一个物 理位置。两个操作数可以是同一个表达式，也可以是不同的表达式。 registers-modified告诉编译器程序中将要修改的寄存器。每个寄存器都用双引号括起来，并用逗号隔开。如“ax”。如果汇编程 序中引用了某个特定的硬件寄存器，就应该在此处列出这些寄存器，以告诉编译器这些寄存器的值被改变了。如果汇编程序中用某种不可预测的方式修改了内存，应 该在此处加上“memory”。这样以来，在整个汇编程序中，编译器就不会把它的值缓存在寄存器中了。 如: “cc”：你使用的指令会改变CPU的条件寄存器cc； “memory”：你使用的指令会修改内存； __volatile__是可选的，它防止编译器修改该段汇编语句（重排序、重组、删除等）。 输入参数和输出变量按顺序编号，先输出后输入，编号从0开始。程序中用编号代表输入参数和输出变量（加%做前缀）。 输入、输出、寄存器部分都可有可无。如有，顺序不能变；如无，应保留“：”，除非不引起二意性。 看一个在C语言中使用at&amp;amp;t的嵌入汇编程序的例子，c语言中的3个int变量，一般会是三个内存地址。每个操作数的长度则要根据操作系统和编译器来决定，一般32位操作系统为32位，则每个操作数占用4个字节： int i=0, j=1, k=0; __asm__ __volatile__(&amp;quot; pushl %%eax\n //asm statement movl %1, %%eax\n //asm statement addl %2, %%eax\n //asm statement movl %%eax, %0\n //.</description></item><item><title>C++核心知识点总结</title><link>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 07 Sep 2014 08:00:00 +0800</pubDate><guid>/blog/2014-09-13-cplusplus%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是C++编程里的一些知识要点。
============================================================================= Sun Sep 7 16:50:05 CST 2014 ============================================================================= 为了开启c++11的某些特性，需要在g++编译时添加参数：-std=c++0x。 c++语言里面，除了char类型被明确规定为占1个字节之外，其他的数据类型都没有指定其 具体的尺寸，这样做的原因是，在不同的编译器实现中，编译器会根据运行平台的特点， 自动为各个类型指定所占用的字节数，以使得编译后的程序能够尽可能适应运行平台。这 样做的好处是，使得编写的c++程序，不仅能够适应现在的机器结构，也能适应将来的机 器结构，实在是高明！ c++11标准中变量的初始化方式有3种，这3中初始化方式是等价的： type varname = varvalue; type varname (varvalue); type varname {varvalue}; auto varname = varvalue; 变量auto会根据初始化时初值varvalue的类新，自动指定varname的类型； decltype(varname)可以获取变量varname的类型，例如可以这样使用： newvar； 这样变量newvar与新变量oldvar是相同的类型，decltype主要是用于模板中根据模板参数 的类型创建其他相同变量。 c++中有专门的字符串类string，需要包含头文件string。 cout输出时追加endl的作用不仅仅是输出换行符，考虑一下缓冲机制就明白了，在终端中 ，缓冲一般是采用行缓冲，因此在cout中追加endl不仅输出了换行符，还进行了行缓冲， 从而确保信息被输出到cout上。 如果在通过cout输出某些信息时不在末尾追加endl，如果输出信息中没有换行符做结尾， 那么信息就不会输出到终端上，因为终端采用行缓冲，不碰到换行符或者待输出信息没有 超过缓冲区的长度，信息不会被输出到终端上。 std::cout，std是一个命名空间，c++标准库中的所有东西都包含在std这个命名空间中， cout指定了设备是输出设备，c++中常用的cin\cout\cerr就等效于c中的 stdin\stdout\stderr。 常量类型 整型常量，常用的包括十进制、八进制、十六进制，分别如123,0234,0xffff；整型常量 可以在末尾追加合适的字符表示该常量应该用什么类型进行存储： u/U表示unsigned； l/L表示long； ll/LL表示long long； 浮点常量，常用的包括float、double、long double，浮点常量的形式包括3.1415、 3.14e23，其中e表示10的多少次方，浮点常量默认是用一个double类型进行存储，也可以 在浮点常量的末尾追加字符表示使用什么类型进行存储，例如： f/F表示float类型； l/L表示long double类型； 什么都不加，即采用默认的double类型； 在c++ shell中的测试结果显示，double表示8字节，long double表示16字节，这个跟编 译器有关。 字符常量、字符串常量'x',&amp;quot;xxxxx&amp;quot;，注意一些特殊的转义字符，例如： \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \a alert (beep) \' single quote (') \&amp;quot; double quote (&amp;quot;) \?</description></item><item><title>Unix环境高级编程</title><link>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 11 Jun 2014 08:00:00 +0800</pubDate><guid>/blog/2014-06-01-unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是Unix环境高级编程里的一些知识要点。
# Advanced Programming in Unix Environment ############################################################################ Mon Jun 9 09:22:41 CST 2014 ############################################################################ M1 Unix基础知识 1. man man 1)user commands 2)system calls 3)c library functions 4)devices and special files 5)file formats and conventions 6)games 7)miscellanea 8)system admistration tools and daemons 2. c return values 1)return 0, 正常结束 2)return 1-255，表示错误代码 3. 工作目录 char *getcwd(char *buf, size_t size); int chdir(char *path); 4. libc与glibc的关系 libc是泛指c库，glibc是gnu组织对libc的一种实现，是unix、linux的根基，微软也有自 己对libc的实现，叫msvcrt。 5. read system call return 0, 表示到达了文件的结尾。 6.</description></item><item><title>Linux系统最佳实践 - 命令行技术</title><link>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</link><pubDate>Thu, 21 Jun 2012 08:00:00 +0800</pubDate><guid>/blog/2012-06-21-linux%E7%B3%BB%E7%BB%9F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%80%E6%9C%AF/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是《Linux系统最佳实践工具-命令行技术》里的一些知识要点。
# 《Linux系统最佳实践》学习笔记 &amp;gt; 参考书目： 《Linux 系统最佳实践工具 —— 命令行技术 》 &amp;gt; 本文撰写： 张 杰 &amp;gt; 截至日期： 2012-6-21 &amp;gt; 总结 ： &amp;gt; 这是我在学习linux过程中，对本书重点内容的一点总结。谈不上心得，只是一点总结，便于以后查阅。在理解/实践的基础上，回头看这些总结的内容会轻松许多。 &amp;gt; 如果你想从本文中获取到丁点帮助，恐怕你必须付出实践，必须肯花时间。 &amp;gt; 有句话叫做“纸上得来终觉浅，绝知此事要躬行”。如果想进步，想获得实质性的进步，必须付出实践。 &amp;gt; linux系统的强大之处不在于它的桌面环境，可能linux现在众多的发行版本中没有任何一款可以与微软抗衡。也许你觉得linux很酷，是的，它的确很酷。 &amp;gt; 它给予了你无穷尽的自由，从内核到桌面，每一个使用linux的人都从中尝到了甜头。但是说真的，linux的“酷”不是靠桌面打下的口碑，这是我们都深知的。 &amp;gt; 当你学习过linux的命令行之后，也许，你才会大彻大悟，linux真是非一般的强悍。而这是windows望尘莫及的。 &amp;gt; 如果你渴望自由，如果你渴望高效，如果…… &amp;gt; 欢迎你加入linux大家庭中来！ # 第一章 Linux简介 ## 1.查看内核版本 uname -r，主版本号/次版本号/修订次数/编译次数 # 第二章 Linux文件系统及其相关处理命令 ## 1.file system - /:文件系统根目录 - /bin:最小系统所需要的命令，其中的文件都是可执行的 - /boot:包含一些启动文件 - /dev:接口设备文件目录 - /etc:系统配置文件所在目录,Editable Text Configuration - /home:用户的主目录 - /lib:库文件目录，例如在执行/bin，/sbin目录下的二进制命令文件时可能会调用的库文件 - /mnt:各项装置的文件系统挂载点，如/mnt/cdrom是光驱的挂载点 - /opt:可以在这里安装自定义软件包（较大的且固定的） - /proc:系统运行时，进程信息以及内核信息（cpu/disk/memory等）都存放在这里。它是一个伪文件系统，存在于内存中，而非硬盘中，通过这个虚拟的文件系统可以在系统运行时调整内核参数，改变内核行为。不用重新启动查看cmos，即可查看系统信息。 - /root:管理员的主目录 - /sbin:目录sbin下的程序都是root权限才可以执行的 - /tmp:存放暂存盘的目录 - /usr:这是系统存放程序的目录，比如命令/配置文件等。当我们安装一个linux发行版提供提供的软件包时，大多安装在这里。这个目录下包含字体文件目录/usr/share/fonts,帮助目录/usr/share/man,/usr/share/doc，普通用户可执行目录/usr/bin,/usr/local/bin,/usr/X11R6/bin,超级用户可执行命令目录/usr/sbin,usr/X11R6/sbin,/usr/local/sbin等。还包含程序的头文件目录/usr/include。 ## 2.</description></item><item><title>Linux系统使用杂谈 - 经验技巧</title><link>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 01 Jan 2012 10:25:37 +0800</pubDate><guid>/blog/2013-07-01-linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%9D%82%E8%B0%88-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/</guid><description>迁移自 hitzhangjie/Study 项目下的内容，本文主要总结的是日常使用Linux发行版过程中遇到的问题及解决办法。
/* vim: set ft=text: */ ############################################################################## config codeblocks for wxwidgets if you want to compile and link wxwidgets project,do as following: compiler and debugger--&amp;gt;compiler settings--&amp;gt;other options: add `wx-config --cflags` compiler and debugger--&amp;gt;linker settings--&amp;gt;other options: add `wx-config --libs` note: if you want to build normal c/c++ project rather than wxwidgets projects, you must remove `wx-config --cflags` and `wx-config --libs`. a better choice is to set the target project's properties including compiler and linker options where you can set `wx-config --cflags` and `wx-config --libs`.</description></item></channel></rss>