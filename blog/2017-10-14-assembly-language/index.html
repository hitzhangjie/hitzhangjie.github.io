<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Web站点描述">
<title>
Assembly Language - 介绍
</title>




<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5f24f50fc2418c0012d52ac3&product=inline-share-buttons" async="async">
</script>

<style>
 
[alt~=sharing] {
    border: 0px;
    box-shadow: none;
}
div#st-1 {
    text-align: unset;
}

 
div#st-1 .st-btn {
    height: 24px;
    padding: 0 4px;
}

div#st-1 .st-btn > img {
    top: 4.2px;
}

div#st-2 .st-btn {
    height: 24px;
    padding: 0 4px;
}

div#st-2 .st-btn > img {
    top: 4.2px;
}
</style>







        <meta property="og:title" content="Assembly Language - 介绍" />
<meta property="og:type" content="website" />
<meta property="og:description" content="Web站点描述"/>
<meta property="og:url" content="https://hitzhangjie.pro/blog/2017-10-14-assembly-language/"/>
<meta property="og:site_name" content="介绍"/>




<meta property="og:image" content="https://hitzhangjie.pro/home/me.jpg"/>

<meta property="og:image" content="https://hitzhangjie.pro/home/profile.jpg"/>




        
<link rel="shortcut icon" href="/img/fav.ico">


        





<link rel="stylesheet" href="/css/main.min.daa833377fb1636f8cbfa65c601050bb5475623deb7aa6e6fdde94a064a6185d.css" integrity="sha256-2qgzN3&#43;xY2&#43;Mv6ZcYBBQu1R1Yj3reqbm/d6UoGSmGF0=" crossorigin="anonymous" media="screen">




    <link rel="stylesheet" href="/custom.css" integrity="" crossorigin="anonymous" media="screen">

        
        
        
        
    </head>
    <body>
        <section id="top" class="section">
            
            <div class="container hero  fade-in one ">
                

    <h1 class="bold-title is-1">博客</h1>


            </div>
            
            <div class="section  fade-in two ">
                
<div class="container">
    <hr>
    <nav class="navbar" role="navigation" aria-label="main navigation">
        
        <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
        <div class="navbar-menu " id="navMenu">
            
            
            
            
            <a class="navbar-item" href="/">主页</a>
            

            
            

            
                
            

            
                
            

            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.pro/projects/">
                  
                  项目
                  
                  </a>
                
                
            
            
            
            
            
                
                
                
                
                  <a class="navbar-item" href="https://hitzhangjie.pro/blog/">
                  
                  返回 博客
                  
                  </a>
                
                
            
            
            
            
            
            <a class="navbar-item" href="/#about">关于</a>
            
            
            
            
            
            <a class="navbar-item" href="/#thanks">致谢</a>
            
            
            
            

            
            
            <a class="navbar-item" href="/#contact">联系方式</a>
            
            

            
            
            
            
            <a class="navbar-item" href="https://hitzhangjie.pro/en/">English</a>
            
            

            
            
        </div>
    </nav>
    <hr>
</div>



                
    <div class="container">

        <h2 class="title is-1 top-pad strong-post-title">
            <a href="https://hitzhangjie.pro/blog/2017-10-14-assembly-language/">Assembly Language</a>
        </h2>
        <div class="post-data">
            发表时间：2017-10-14 <br> 
            阅读时长：18 分钟 (8700字)
        </div>

        
        <div>
            <div>
            
            
            <p>
                
                
                <a href="/tags/assembly">assembly</a>
                
            </p>
            
            </div>

            <div>
            <br>
            


<div style="display:flex;">
    <div>分享：</div>
    <div>
        <div class="sharethis-inline-share-buttons"></div>
    </div>
</div>


            </div>

        </div>

        
        

        
        <div> 
            
<aside>
    <hr/>
    <header>
    <b>《Assembly Language》目录：</b>
    <br/>
    </header>
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#11-pc硬件的基本特征">1.1 PC硬件的基本特征</a></li>
            <li><a href="#12-开发环境配置">1.2 开发环境配置</a></li>
            <li><a href="#13-基本语法">1.3 基本语法</a></li>
            <li><a href="#14-内存分段">1.4 内存分段</a></li>
            <li><a href="#15-寄存器">1.5 寄存器</a></li>
            <li><a href="#16-系统调用">1.6 系统调用</a></li>
            <li><a href="#17-寻址模式">1.7 寻址模式</a></li>
            <li><a href="#18-定义变量">1.8 定义变量</a></li>
            <li><a href="#19-定义常量">1.9 定义常量</a></li>
            <li><a href="#110-算术指令">1.10 算术指令</a></li>
            <li><a href="#111-逻辑指令">1.11 逻辑指令</a></li>
            <li><a href="#112-分支控制">1.12 分支控制</a></li>
            <li><a href="#113-循环控制">1.13 循环控制</a></li>
            <li><a href="#114-数字">1.14 数字</a></li>
            <li><a href="#115-字符串">1.15 字符串</a></li>
            <li><a href="#116-数组">1.16 数组</a></li>
            <li><a href="#117-函数">1.17 函数</a></li>
            <li><a href="#118-递归">1.18 递归</a></li>
            <li><a href="#119-宏">1.19 宏</a></li>
            <li><a href="#120-文件操作">1.20 文件操作</a></li>
            <li><a href="#121-内存管理">1.21 内存管理</a></li>
            <li><a href="#122-总结">1.22 总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    <hr/>
</aside>


        </div>
   
        
        <div class="container markdown top-pad">
            <p>处理器是算逻运算、控制操作的执行部件，它只能识别机器指令并执行动作。机器指令是一系列的0、1字符串，本质上对应了总线上的高低电平信号，所以机器语言都是特定于硬件的。</p>
<p>由于0、1字符串很难记忆，用机器语言开发是一个老大难的问题，汇编语言因此被开发出来用于代替机器语言。汇编指令只是机器指令中操作码的助记符，因此汇编语言仍然是机器强相关的，不同的处理器其对应的汇编指令也不同。</p>
<p><strong>学习汇编语言有助于理解：</strong></p>
<ul>
<li>程序是如何与操作系统、处理器、bios进行交互的；</li>
<li>数据如何在内存中以及外设中表示的；</li>
<li>处理器如何访问、执行指令；</li>
<li>指令如何访问、处理数据；</li>
<li>程序如何访问外设；</li>
</ul>
<p><strong>其他使用汇编语言的优势：</strong></p>
<ul>
<li>消耗更少的内存和处理器执行时间；</li>
<li>允许以更简单的方式来完成硬件特定的复杂作业；</li>
<li>适用于时间敏感的作业；</li>
<li>适用于编写中断服务程序和内存驻留程序；</li>
</ul>
<h3 id="11-pc硬件的基本特征">1.1 PC硬件的基本特征</h3>
<p>机器指令是0、1字符串，分别表示ON、OFF，对应数字信号的高低电平。机器中的最低存储单位是bit，通常8bit构成一个byte，为了对数据传输过程中传输数据的有效性进行检查，通常会在数据byte发送之后再追加一个奇偶校验bit。</p>
<ul>
<li>奇校验：保证8bit数据+1bit校验位中的1的个数为奇数；</li>
<li>偶校验：保证8bit数据+1bit校验位中的1的个数为偶数；</li>
</ul>
<p>发送方、接收方遵循相同的奇偶校验规则，如果接收方收到数据后发现奇偶校验不正确，则表示可能硬件出错，或者出现了电平扰动。</p>
<p><strong>处理器支持如下数据尺寸：</strong></p>
<p>|:&mdash;|:&mdash;&mdash;|
|Word|2 bytes|
|Doubleword|4 bytes|
|Quadword|8 bytes|
|Paragraph|16 bytes|
|Kilobyte|2^10 bytes|
|Megabyte|2^20 bytes|</p>
<p><strong>二进制 &amp; 十六进制系统：</strong></p>
<p>二进制天然适用于计算机计算领域，0、1刚好代表数字电路中的高低电平；而十六进制是用于对比较长的二进制数值进行更加优雅地简写，使我们表示起来更加清晰、简单。</p>
<p>二进制、十六进制的相关运算，特别是涉及到原码、反码、补码、移码的运算，需要重点了解下，建议参考《计算机组成原理》相关章节。</p>
<p><strong>访问内存中的数据：</strong></p>
<p>处理器控制指令执行的过程可以简化为”取指令-指令移码-指令执行“的循环体，一个”取指令-指令译码-指令执行“周期称之为一个机器周期。</p>
<ul>
<li>取指周期：根据CS、IP从内存指定位置取指令，并存储到指令寄存器IR；</li>
<li>译码周期：根据IR中的指令，分析出操作码OP、操作数或操作数地址；</li>
<li>执行周期：根据分析出的OP、操作数或操作地址信息执行相应的动作；</li>
</ul>
<p>Intel架构的处理器在内存中存储时是采用的小端字节序，意味着一个多字节数值的低字节部分将在低地址存储，高字节部分将在高地址存储，但是在处理器寄存器中存储时低字节部分就在低字节，高字节部分就在高字节，所以在处理器寄存器、内存之间存储、加载数据时需要做字节序方面的转换。</p>
<p>以处理器寄存器中数值0x1234为例，现在要将其存储到内存中，处理器先将0x34存储到内存低地址，然后再见0x12存储到内存高地址；假如内存中有数据0xabcd，现在要将其加载到处理器寄存器中，加载时也会做对应的处理，将0xab放在寄存器高位，将0xcd放在寄存器低位。</p>
<p>指令中的操作数地址，又有多种不同的寻址方式，立即数寻址、直接寻址、间接寻址、寄存器寻址等，这里后面会做相应的介绍。</p>
<h3 id="12-开发环境配置">1.2 开发环境配置</h3>
<p>汇编指令特定于处理器的，因此不同的处理器系列、型号对应的汇编指令可能也会有差异，这里使用的是Intel-32架构的处理器，使用汇编器NASM进行汇编操作，其他可选的汇编器还有MASM、TASM、GAS等。</p>
<h3 id="13-基本语法">1.3 基本语法</h3>
<p>汇编程序通常包括3个节，分别是data、bss、text节：</p>
<ul>
<li>data，用于声明初始化的变量和常量；</li>
<li>bss，用于声明未初始化的变量，这部分不会出现在编译后的程序中；</li>
<li>text，用于保存程序指令；</li>
</ul>
<p>text节中必须包括&rdquo;<strong>global ${entry}</strong>&ldquo;声明，${entry}是程序入口，通常定义未_start，见文生义嘛。</p>
<p>汇编程序中的注释均以&rdquo;;&ldquo;开头，直到所在行结束。</p>
<p>汇编语言程序包括3种不同类型的语句：</p>
<ul>
<li>可执行汇编指令；</li>
<li>传递给汇编器的指令或伪操作；</li>
<li>宏；</li>
</ul>
<p>汇编语言语句遵循如下结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#960050;background-color:#1e0010">[标识]</span> <span style="color:#960050;background-color:#1e0010">助记符</span> <span style="color:#960050;background-color:#1e0010">[操作数]</span> <span style="color:#960050;background-color:#1e0010">[</span><span style="color:#75715e">;注释]</span>
</code></pre></div><blockquote>
<p>[]内部的部分是可选的，尤其是标识和注释部分，根据汇编指令的不同，有无操作数、操作数个数、操作数类型等均有所不同。汇编指令中包括了操作码和操作数相关信息，这里的助记符其实就是操作码的符号表示。</p>
</blockquote>
<p>下面是应用了上述基本语法的示例程序：</p>
<p><em><strong>hello.asm</strong></em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start     <span style="color:#75715e">;must be declared for linker (ld)</span>
	
_start:	            <span style="color:#75715e">;tells linker entry point</span>
   <span style="color:#a6e22e">mov</span>	edx,len     <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>	ecx,msg     <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>       <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>       <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>        <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">1</span>       <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>        <span style="color:#75715e">;call kernel</span>

<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">msg</span> db <span style="color:#e6db74">&#39;Hello, world!&#39;</span>, <span style="color:#ae81ff">0xa</span>  <span style="color:#75715e">;string to be printed</span>
<span style="color:#66d9ef">len</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span> <span style="color:#f92672">-</span> msg     <span style="color:#75715e">;length of the string</span>
</code></pre></div><p>在Linux平台下由汇编文件构建可执行程序包括如下两个步骤：</p>
<ul>
<li>汇编，nasm -f elf -o hello.o hello.asm</li>
<li>连接，ld -m elf_i386 -e _start -o hello hello.o</li>
</ul>
<p>构建完成，即可在命令行执行./hello来进行测试。</p>
<h3 id="14-内存分段">1.4 内存分段</h3>
<p>前面一节介绍了汇编语言中的section（节），这些节也代表着各种各样的内存segment（段）。将前面示例代码hello.asm中的section关键字用segment代替，依然可以用相同的方法构建成功并得到相同的测试结果。</p>
<p>汇编语言中常见的segment（段）包括：</p>
<ul>
<li>data segment，数据段代表了data section和bss section。其中data section用于存储初始化后的全局变量和全局变量；bss section用于声明未初始化的全局变量和静态变量，在程序运行时会被初始化未0值。</li>
<li>code segment，代码段也就是text节，用于存储程序指令；</li>
<li>stack segment，堆栈段用于分配临时变量、调用函数时传递参数信息等；</li>
</ul>
<h3 id="15-寄存器">1.5 寄存器</h3>
<p>处理器主要是用来进行计算，计算所需要的数据来自于内存，但是处理器存取内存数据需要的时间比较长，为了ALU加速存取操作数，处理器里面内置了寄存器，将内存中的数据先加载到寄存器中，然后ALU对寄存器中的数据进行计算，最后再将计算结果搬回内存。</p>
<p>处理器中的寄存器主要包括如下几类：</p>
<ul>
<li>通用目的寄存器，包括数据寄存器（EAX、EBX、ECX、EDX）、指针寄存器（EIP、ESP、EBP）、索引寄存器（ESI、EDI）；</li>
</ul>
<blockquote>
<p>函数调用过程中会形成栈帧，ebp寄存器指向的是栈帧的栈底，esp指向的值栈帧的栈顶。通过ebp便于定位传递给函数的参数、返回地址信息，栈帧开始构建的时候，首先就会将caller的ebp压栈，然后将当前栈帧栈顶esp赋值给ebp作为新的栈帧的栈底，后面esp减去一个值N,[esp-N,ebp）就是新的栈空间。</p>
</blockquote>
<ul>
<li>段寄存器，包括ECS、ESS、EDS；</li>
</ul>
<blockquote>
<p>8086里面，CS包括代码段的起始地址，从80386进入保护模式开始，CS里面变成了段选择符，具体的代码段起始地址要到gdb里面去查。DS存储数据段的起始地址，SS存储堆栈段的起始地址。</p>
</blockquote>
<ul>
<li>控制寄存器，32位flags寄存器和32位指令指针寄存器共同称为控制寄存器。</li>
</ul>
<blockquote>
<p>常见的flag标志位包括：OF（溢出）、DF（字符串比较方向）、IF（是否允许中断）、TF（是否单步执行）、SF（符号位）、ZF（比较结果）、AF（辅助进位）、PF（1数量是否为奇数）、CF（是否进位）。</p>
</blockquote>
<p>下面是一个使用多个寄存器的示例程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start	 <span style="color:#75715e">;must be declared for linker (gcc)</span>
	
_start:	         <span style="color:#75715e">;tell linker entry point</span>
   <span style="color:#a6e22e">mov</span>	edx,len  <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>	ecx,msg  <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>    <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>    <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>     <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	edx,<span style="color:#ae81ff">9</span>    <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>	ecx,s2   <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>    <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>    <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>     <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">1</span>    <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>     <span style="color:#75715e">;call kernel</span>
	
<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">msg</span> db <span style="color:#e6db74">&#39;Displaying 9 stars&#39;</span>,<span style="color:#ae81ff">0xa</span> <span style="color:#75715e">;a message</span>
<span style="color:#66d9ef">len</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span> <span style="color:#f92672">-</span> msg  <span style="color:#75715e">;length of message</span>
<span style="color:#a6e22e">s2</span> times <span style="color:#ae81ff">9</span> db <span style="color:#e6db74">&#39;*&#39;</span>
</code></pre></div><h3 id="16-系统调用">1.6 系统调用</h3>
<p>系统调用是操作系统内核提供的用户态、内核态之间的接口，用户态通过系统调用访问内核服务。</p>
<p>如何通过在汇编程序里面使用系统调用呢？</p>
<ul>
<li>在EAX寄存器里面设置系统调用号；</li>
<li>在EBX、ECX、EDX、ESI、EDI、EBP中设置系统调用参数（如果参数数量超过6个，则需特殊处理）；</li>
<li>调用中断服务int 0x80（系统调用都是通过中断服务的形式实现，int指令使得处理器从ring3切换到ring0，iret使处理器从ring0切换回ring3）；</li>
<li>系统调用的返回值通常保存在EAX中；</li>
</ul>
<p>Linux下的系统调用定义在/usr/include/asm/unistd.h中，可以从中查看系统调用名称以及编号。下面是一个综合使用系统调用read、write、exit的例子，程序提示用户输入一个数字并读取用户输入，然后回显该数字。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span> .data                           <span style="color:#75715e">;Data segment</span>
   <span style="color:#a6e22e">userMsg</span> db <span style="color:#e6db74">&#39;Please enter a number: &#39;</span> <span style="color:#75715e">;Ask the user to enter a number</span>
   <span style="color:#66d9ef">lenUserMsg</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span>userMsg             <span style="color:#75715e">;The length of the message</span>
   <span style="color:#a6e22e">dispMsg</span> db <span style="color:#e6db74">&#39;You have entered: &#39;</span>
   <span style="color:#66d9ef">lenDispMsg</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span>dispMsg                 

<span style="color:#66d9ef">section</span> .bss           <span style="color:#75715e">;Uninitialized data</span>
   <span style="color:#a6e22e">num</span> resb <span style="color:#ae81ff">5</span>
	
<span style="color:#66d9ef">section</span> .text          <span style="color:#75715e">;Code Segment</span>
   <span style="color:#66d9ef">global</span> _start
	
_start:                <span style="color:#75715e">;User prompt</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ecx, userMsg
   <span style="color:#a6e22e">mov</span> edx, lenUserMsg
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">80h</span>

   <span style="color:#75715e">;Read and store the user input</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">3</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">2</span>
   <span style="color:#a6e22e">mov</span> ecx, num  
   <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">5</span>          <span style="color:#75715e">;5 bytes (numeric, 1 for sign) of that information</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">80h</span>
	
   <span style="color:#75715e">;Output the message &#39;The entered number is: &#39;</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ecx, dispMsg
   <span style="color:#a6e22e">mov</span> edx, lenDispMsg
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">80h</span>  

   <span style="color:#75715e">;Output the number entered</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ecx, num
   <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">5</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">80h</span>  
    
   <span style="color:#75715e">; Exit code</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">0</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">80h</span>
</code></pre></div><h3 id="17-寻址模式">1.7 寻址模式</h3>
<p>汇编语言中的寻址模式可以分为两类，一类是<strong>指令寻址</strong>，一类是<strong>数据寻址</strong>：</p>
<ul>
<li>指令寻址：处理器要执行的指令如何寻址，分为顺序寻址（顺序执行，pc+=1）、跳跃寻址（jmp）；</li>
<li>数据寻址：根据数据所在存储位置的不同（内存或寄存器），以及地址提供方式的不同，数据寻址方式多种多样。</li>
</ul>
<p>数据寻址方式虽然多样，但是都遵从如下指令格式：</p>
<p>|:&ndash;:|:&ndash;:|:&ndash;:|
|操作码OP|寻址特征|形式地址A|</p>
<p>根据寻址特征以及形式地址A，可以计算出操作数的有效地址EA，不同的寻址特征对形式地址A施加的计算规则也不一样。下面总结一下常见的数据寻址方式。</p>
<ul>
<li>立即寻址，A是立即数（常量），EA=A；</li>
<li>寄存器寻址，A是寄存器编号，EA=A=Ri；</li>
<li>直接内存寻址，A为数据在内存中的有效地址，即EA=A；</li>
<li>直接内存偏移量寻址，类似于基址寻址方式，EBX做基地址，A为offset；</li>
<li>间接内存寻址，(A)为数据在内存中的有效地址，即EA=(A),间接内存寻址可能还会涉及到多重间址；</li>
</ul>
<blockquote>
<p>计算机组成原理中可能提到的数据寻址方式更加偏重于理论，寻址方式也更加多样，实际的汇编语言实现中可能并没有逐一实现，或者区分不明显，我们这里从实践出发，更加侧重于实用而不是理论，因此在使用术语的选择上也更加偏重于业内人员的偏好。</p>
</blockquote>
<p>在汇编语言中，获取一个内存变量的有效地址的方式是：[varname]。</p>
<p>下面是一个综合使用了上述多种寻址方式的示例程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span>_start     <span style="color:#75715e">;must be declared for linker (ld)</span>
_start:             <span style="color:#75715e">;tell linker entry point</span>
	
   <span style="color:#75715e">;writing the name &#39;Zara Ali&#39;</span>
   <span style="color:#a6e22e">mov</span>	edx,<span style="color:#ae81ff">9</span>       <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>	ecx, name   <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>       <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>       <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>        <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	[name],  <span style="color:#66d9ef">dword</span> <span style="color:#e6db74">&#39;Nuha&#39;</span>    <span style="color:#75715e">; Changed the name to Nuha Ali</span>
	
   <span style="color:#75715e">;writing the name &#39;Nuha Ali&#39;</span>
   <span style="color:#a6e22e">mov</span>	edx,<span style="color:#ae81ff">8</span>       <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>	ecx,name    <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>       <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>       <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>        <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">1</span>       <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>        <span style="color:#75715e">;call kernel</span>

<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">name</span> db <span style="color:#e6db74">&#39;Zara Ali &#39;</span>
</code></pre></div><h3 id="18-定义变量">1.8 定义变量</h3>
<p>汇编语言中提供了多个汇编器指令用于定义变量、预留内存空间。</p>
<p><strong>section .data，为初始化的数据分配存储空间:</strong></p>
<pre><code>varname define-directive initial-value[,initial-value2]
</code></pre><p>常用的define-directive包括DB、DW、DD、DQ、DT，分别用于定义1byte、1word、1doubleword、1quadword、10bytesd并进行初始化操作。</p>
<p><strong>section .bss，为未初始化的数据分配存储空间：</strong></p>
<pre><code>[varname] reserve-directive quantity
</code></pre><p>常用的reserve-directie指令包括RESB、RESW、RESD、RESQ、REST，分别用于分配1byte、1word、1doubleword、1quadword、10bytes的存储空间，结合操作数quantity可以计算出需要分配多少空间。</p>
<p>.bss节每一个对应的define-directive语句都有一个对应的reserve-directive与之对应，reserve-directive也可以单独存在，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span> .bss
	<span style="color:#a6e22e">age</span> db
	<span style="color:#66d9ef">resb</span> <span style="color:#ae81ff">1</span>         <span style="color:#75715e">;只预留空间没关联变量</span>
	<span style="color:#a6e22e">num</span> resb <span style="color:#ae81ff">1</span>     <span style="color:#75715e">;预留空间并绑定变量</span>
</code></pre></div><p><strong>times directive允许多个变量初始化为相同的值：</strong></p>
<pre><code>varname times quantity define-directive [intiail-val]
</code></pre><p>注意times指令也可以用于.bss节，但是.bss节汇编的时候不会进行初始化，程序启动的时候才会进行0初始化。</p>
<ul>
<li>如果没有提供initial-val，会提示没有初始值不进行初始化；</li>
<li>如果提供了intiail-val，会提示.bss节忽略了初始值不进行初始化操作；</li>
</ul>
<h3 id="19-定义常量">1.9 定义常量</h3>
<p>汇编语言中定义常量的指令包括3个，分别是EQU、%assign、%define。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">const</span><span style="color:#f92672">-</span>name EQU value <span style="color:#75715e">;可以定义字符串或者数值常量</span>
<span style="color:#75715e">%assign const-name value </span><span style="color:#75715e">;只可以定义数值常量，可以重定义
</span><span style="color:#75715e"></span><span style="color:#75715e">%define const-name value </span><span style="color:#75715e">;可以定义字符串或者数值常量
</span></code></pre></div><p>前面曾多次使用EQU进行常量定义，这里就不再提供其他示例程序了。</p>
<h3 id="110-算术指令">1.10 算术指令</h3>
<p>汇编语言中的算术运算指令包括：</p>
<ul>
<li>INC、DEC，自增、自减一个寄存器或者内存变量的值，结果保存到当前操作数；</li>
<li>ADD、SUB，加、减一个寄存器或者内存变量的值，结果保存到第一个操作数；</li>
<li>MUL、IMUL，分别处理无符号、有符号数的乘法，保存存储遵循如下规则：
<ul>
<li>8位乘法，如：AL * 8bit_source = AH AL，结果高8位保存到AH、低8位保存到AL；</li>
<li>16位乘法，如：AX * 16bit_source = DX AX，结果高16位保存到DX，低16位保存到AX；</li>
<li>32位乘法，如：EAX * 32bit_source = EDX EAX，结果高32位保存到EDX，低32位保存到EAX；</li>
</ul>
</li>
<li>DIV、IDIV，分别处理无符号、有符号数的除法，结果存储遵循如下规则：
<ul>
<li>16位除法，如：AX / 8bit_source = AL&hellip;AH，商保存到AL，余数保存到AH；</li>
<li>32位除法，如：DX AX / 16bit_source = AX&hellip;DX，被除数高16位在DX、低16位在AX，结果商在AX、余数在DX；</li>
<li>64位除法，如：EDX EAX / 32bit_source = EAX&hellip;EDX，被除数高32位在EAX、低32位在EAX，结果商在EAX、余数在EDX；</li>
</ul>
</li>
</ul>
<h3 id="111-逻辑指令">1.11 逻辑指令</h3>
<p>汇编语言中的逻辑运算指令包括：</p>
<ul>
<li>AND，逻辑与运算，结果保存到第一个操作数；</li>
<li>OR，逻辑或运算，结果保存到第一个操作数；</li>
<li>NOT，对当前操作数求反，结果保存到当前操作数；</li>
<li>XOR，异或运算，结果保存到第一个操作数；</li>
<li>TEST，测试运算，不会改变操作数的值，但运算会影响ZF标识；</li>
</ul>
<h3 id="112-分支控制">1.12 分支控制</h3>
<p>通过某些循环、分支指令可以实现分支语句，这里对应的汇编指令主要都是基于处理器中的标识寄存器来实现的。</p>
<p><strong>常用指令包括：</strong></p>
<ul>
<li>比较指令<br>
CMP，比较两个操作数是否相同、谁大谁小，需结合其他条件转移指令使用；</li>
<li>无条件转移指令<br>
JMP，无条件跳转到制定的指令地址处执行；</li>
<li>条件转移指令
有符号数、无符号数通用的包括：JE/JZ，JNE/JNZ；
无符号数特有的包括：JG、JGE、JL、JLE等；
有符号数特有的包括：JA、JAE、JB、JBE等；
特殊用途的包括：JC、JNC、JO、JNO、JS、JNS等；</li>
</ul>
<p>这里涉及到的条件转移指令比较多，这里不一一进行描述了，有需要的话读者朋友可以参考<a href="https://www.tutorialspoint.com/assembly_programming/assembly_conditions.htm">”分支控制指令“</a>，或者可以参考intel指令集了解更多的细节。</p>
<h3 id="113-循环控制">1.13 循环控制</h3>
<p><strong>借助条件转移指令实现循环</strong></p>
<p>条件转移指令可以用于实现循环控制，循环控制次数可以存储在ECX寄存器中，循环体内动作每执行一次将ECX值减1，根据ECX值是否为0决定是否进行循环。下面就是一个根据这个简单思路实现的循环体：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">MOV</span>	CL, <span style="color:#ae81ff">10</span>
L1:
	<span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">LOOP</span><span style="color:#f92672">-</span>BODY<span style="color:#f92672">&gt;</span>
<span style="color:#a6e22e">DEC</span>	CL
<span style="color:#a6e22e">JNZ</span>	L1
</code></pre></div><p><strong>借助内置的loop指令实现循环</strong></p>
<p>汇编语言内部提供了指令loop来实现循环，起实现方式跟我们上面说的是一样的，loop指令会检查当前ECX寄存器的值是否为0，为0则退出循环，大于0则执行DEC ECX并继续执行循环体。</p>
<p>下面是一个借助loop指令实现的循环体版本，书写上也更加简练：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">MOV</span>	CL, <span style="color:#ae81ff">10</span>
L1:
	<span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">LOOP</span><span style="color:#f92672">-</span>BODY<span style="color:#f92672">&gt;</span>
<span style="color:#a6e22e">loop</span> L1
</code></pre></div><h3 id="114-数字">1.14 数字</h3>
<p>前面我们读入一个数位数值的时候需要将其减去'0&rsquo;之后得到其真实数值，运算结果写出之前也需要将数位数值加上'0&rsquo;再写出，为啥？这里涉及到ASCII码与数值之间的转换。</p>
<p>上述处理方式虽然比较直观，但是负载比较大，汇编语言中有更加高效的处理方式，即以二进制形式对其进行处理。</p>
<p>十进制数字有两种表示形式：</p>
<ul>
<li>ASCII码形式<br>
输入的十进制数字每个数位都用ASCII来表示，十进制数字1234的4个数位分别被编码为对应的ASCII码字符，各个字符对应的十进制值分别为：31 32 33 34，共占用了4个字节；</li>
<li>BCD码形式
<ul>
<li>如果是unpacked BCD编码形式，输入的十进制数字每个数位都用1字节的二进制形式来表示，十进制数字1234的4个数位分别被编码为：01 02 03 04，共占用4个字节。</li>
<li>如果是packed BCD编码形式，输入的十进制数字每个数位用4bit来表示，十进制数字1234的4个数位被编码为：12 34，共占用2个字节。</li>
</ul>
</li>
</ul>
<p>运算完成之后，可能会涉及到某些ASCII、BCD码之间的转换动作，可以借助于对应的汇编调整指令来实现。</p>
<h3 id="115-字符串">1.15 字符串</h3>
<p><strong>计算字符串长度</strong></p>
<p>前面我们指定一个字符串的长度的时候，可以通过变量来显示地指明，也可以通过**”$-msg“**来计算出来，使用后者的时候我们需要为msg字符串尾部添加一个哨兵字符，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">msg</span> db <span style="color:#e6db74">&#39;hello world&#39;</span>,<span style="color:#ae81ff">0xa</span>
<span style="color:#a6e22e">len</span> db <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span>msg
</code></pre></div><p>$代表的是当前的offset，offset-db正好是msg中字符的数量，不包括0xa，如果不添加0xa这个字符哨兵的话，len就应该定义成**&ldquo;$-msg+1&rdquo;**。</p>
<p><strong>字符串操作指令：</strong></p>
<ul>
<li>MOVS，移动一个字符串；</li>
<li>LODS，从内存中装载字符串；</li>
<li>STOS，存储字符串到内存；</li>
<li>CMPS，比较字符串；</li>
<li>SCAS，比较寄存器和内存中的字符串；</li>
<li>REP/REPZ/REPNZ，便利字符串并针对各个字符重复执行某个操作；</li>
</ul>
<h3 id="116-数组">1.16 数组</h3>
<p>定义数组，主要有如下几种方式，我们以定义一个byte数组为例分别说明。</p>
<p><strong>定义数组方式一：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">numbers</span> db <span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>
</code></pre></div><p><strong>定义数组方式二：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">numbers</span> db <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">4</span>
        <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">5</span>
</code></pre></div><p>这种方式应该比较少用，方式一其实是这种方式的简化版。</p>
<p><strong>定义数组方式三：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">numbers</span> times <span style="color:#ae81ff">6</span> db <span style="color:#ae81ff">0</span>
</code></pre></div><p>这种方式定义的6个byte都被初始化为相同的值0。</p>
<p>还是要根据自己的需要来选择合适的数组定义方式。</p>
<p>下面示例程序定义了一个数组byte数组x，然后以循环的形式遍历x中的元素并求和：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start   <span style="color:#75715e">;must be declared for linker (ld)</span>
	
_start:	 		
   <span style="color:#a6e22e">mov</span>  eax,<span style="color:#ae81ff">3</span>      <span style="color:#75715e">;number bytes to be summed </span>
   <span style="color:#a6e22e">mov</span>  ebx,<span style="color:#ae81ff">0</span>      <span style="color:#75715e">;EBX will store the sum</span>
   <span style="color:#a6e22e">mov</span>  ecx, x     <span style="color:#75715e">;ECX will point to the current element to be summed</span>

top:  <span style="color:#a6e22e">add</span>  ebx, [ecx]
   <span style="color:#a6e22e">add</span>  ecx,<span style="color:#ae81ff">1</span>      <span style="color:#75715e">;move pointer to next element</span>
   <span style="color:#a6e22e">dec</span>  eax        <span style="color:#75715e">;decrement counter</span>
   <span style="color:#a6e22e">jnz</span>  top        <span style="color:#75715e">;if counter not 0, then loop again</span>

done: 
   <span style="color:#a6e22e">add</span>   ebx, <span style="color:#e6db74">&#39;0&#39;</span>
   <span style="color:#a6e22e">mov</span>  [sum], ebx <span style="color:#75715e">;done, store result in &#34;sum&#34;</span>

display:
   <span style="color:#a6e22e">mov</span>  edx,<span style="color:#ae81ff">1</span>      <span style="color:#75715e">;message length</span>
   <span style="color:#a6e22e">mov</span>  ecx, sum   <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>  ebx, <span style="color:#ae81ff">1</span>     <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>  eax, <span style="color:#ae81ff">4</span>     <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>  <span style="color:#ae81ff">0x80</span>       <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>  eax, <span style="color:#ae81ff">1</span>     <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>  <span style="color:#ae81ff">0x80</span>       <span style="color:#75715e">;call kernel</span>

<span style="color:#66d9ef">section</span>	.data
<span style="color:#66d9ef">global</span> x
x:    
   <span style="color:#66d9ef">db</span>  <span style="color:#ae81ff">2</span>
   <span style="color:#66d9ef">db</span>  <span style="color:#ae81ff">4</span>
   <span style="color:#66d9ef">db</span>  <span style="color:#ae81ff">3</span>

sum: 
   <span style="color:#66d9ef">db</span>  <span style="color:#ae81ff">0</span>
</code></pre></div><h3 id="117-函数">1.17 函数</h3>
<p>汇编语言中函数是非常重要的一个组成部分，定义函数的语法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm">function_name:
	<span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">function_body</span><span style="color:#f92672">&gt;</span>
	<span style="color:#a6e22e">ret</span>
</code></pre></div><p>程序中调用一个函数的指令为call：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">call</span> <span style="color:#f92672">&lt;</span>function_name<span style="color:#f92672">&gt;</span>
</code></pre></div><p>下面示例代码总定义了一个求和函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start        <span style="color:#75715e">;must be declared for using gcc</span>
	
_start:	                <span style="color:#75715e">;tell linker entry point</span>
   <span style="color:#a6e22e">mov</span>	ecx,<span style="color:#e6db74">&#39;4&#39;</span>
   <span style="color:#a6e22e">sub</span>     ecx, <span style="color:#e6db74">&#39;0&#39;</span>
	
   <span style="color:#a6e22e">mov</span> 	edx, <span style="color:#e6db74">&#39;5&#39;</span>
   <span style="color:#a6e22e">sub</span>     edx, <span style="color:#e6db74">&#39;0&#39;</span>
	
   <span style="color:#a6e22e">call</span>    sum          <span style="color:#75715e">;call sum procedure</span>
   <span style="color:#a6e22e">mov</span> 	[res], eax
   <span style="color:#a6e22e">mov</span>	ecx, msg	
   <span style="color:#a6e22e">mov</span>	edx, len
   <span style="color:#a6e22e">mov</span>	ebx,<span style="color:#ae81ff">1</span>	        <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>	        <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>	        <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	ecx, res
   <span style="color:#a6e22e">mov</span>	edx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span>	ebx, <span style="color:#ae81ff">1</span>	        <span style="color:#75715e">;file descriptor (stdout)</span>
   <span style="color:#a6e22e">mov</span>	eax, <span style="color:#ae81ff">4</span>	        <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>	        <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">1</span>	        <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>	        <span style="color:#75715e">;call kernel</span>
sum:
   <span style="color:#a6e22e">mov</span>     eax, ecx
   <span style="color:#a6e22e">add</span>     eax, edx
   <span style="color:#a6e22e">add</span>     eax, <span style="color:#e6db74">&#39;0&#39;</span>
   <span style="color:#a6e22e">ret</span>
	
<span style="color:#66d9ef">section</span> .data
<span style="color:#a6e22e">msg</span> db <span style="color:#e6db74">&#34;The sum is:&#34;</span>, <span style="color:#ae81ff">0xA</span>,<span style="color:#ae81ff">0xD</span> 
<span style="color:#66d9ef">len</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span> msg   

<span style="color:#66d9ef">segment</span> .bss
<span style="color:#a6e22e">res</span> resb <span style="color:#ae81ff">1</span>
</code></pre></div><p>栈stack，是一种后进先出LIFO的数据结构，汇编语言提供了指令push、pop来进行入栈、出栈操作。</p>
<h3 id="118-递归">1.18 递归</h3>
<p>递归操作，指的是一个函数func在执行过程中会调用这个函数自身的情况。递归又可以细分为直接递归和间接递归。</p>
<ul>
<li>直接递归，函数func的函数体中会调用自身；</li>
<li>间接递归，函数func的函数体中调用了其他的函数，而这个被调用的函数中又调用了函数func；</li>
</ul>
<p>有些问题适合用递归算法来解决，递归比较容易理解，但是对栈空间消耗可能会超出系统允许的上限导致栈溢出问题，此时需要将递归算法转换为非递归算法。</p>
<h3 id="119-宏">1.19 宏</h3>
<p>汇编语言中可以将常用的、可能多次重复使用的指令序列以宏macro的形式进行封装，在程序中可以多次调用。</p>
<p><strong>定义宏的形式为：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#75715e">%macro macro_name params_quantity
</span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">macro_body</span><span style="color:#f92672">&gt;</span>
<span style="color:#75715e">%endmacro
</span></code></pre></div><p><strong>调用宏的形式为：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#a6e22e">macro_name</span> param1, param2
</code></pre></div><p>下面的示例程序中，将输出字符串的指令序列以宏的形式进行了封装：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#75715e">; A macro with two parameters</span>
<span style="color:#75715e">; Implements the write system call</span>
<span style="color:#75715e">   %macro write_string 2 
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">mov</span>   eax, <span style="color:#ae81ff">4</span>          <span style="color:#75715e">;sys_write</span>
      <span style="color:#a6e22e">mov</span>   ebx, <span style="color:#ae81ff">1</span>          <span style="color:#75715e">;stdout</span>
      <span style="color:#a6e22e">mov</span>   ecx, <span style="color:#f92672">%</span><span style="color:#ae81ff">1</span>         <span style="color:#75715e">;param1, buf</span>
      <span style="color:#a6e22e">mov</span>   edx, <span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>         <span style="color:#75715e">;param2, buf_len</span>
      <span style="color:#a6e22e">int</span>   <span style="color:#ae81ff">80h</span>             <span style="color:#75715e">;call kernel</span>
<span style="color:#75715e">   %endmacro
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start            <span style="color:#75715e">;must be declared for using gcc</span>
	
_start:                     <span style="color:#75715e">;tell linker entry point</span>
   <span style="color:#a6e22e">write_string</span> msg1, len1               
   <span style="color:#a6e22e">write_string</span> msg2, len2    
   <span style="color:#a6e22e">write_string</span> msg3, len3  
	
   <span style="color:#a6e22e">mov</span> eax,<span style="color:#ae81ff">1</span>                <span style="color:#75715e">;sys_exit</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>                 <span style="color:#75715e">;call kernel</span>

<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">msg1</span> db	<span style="color:#e6db74">&#39;Hello, programmers!&#39;</span>,<span style="color:#ae81ff">0xA</span>,<span style="color:#ae81ff">0xD</span> 	
<span style="color:#66d9ef">len1</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span> <span style="color:#f92672">-</span> msg1			

<span style="color:#a6e22e">msg2</span> db <span style="color:#e6db74">&#39;Welcome to the world of,&#39;</span>, <span style="color:#ae81ff">0xA</span>,<span style="color:#ae81ff">0xD</span> 
<span style="color:#66d9ef">len2</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span> msg2 

<span style="color:#a6e22e">msg3</span> db <span style="color:#e6db74">&#39;Linux assembly programming! &#39;</span>
<span style="color:#66d9ef">len3</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span> msg3
</code></pre></div><h3 id="120-文件操作">1.20 文件操作</h3>
<p>Linux内核提供了一系列文件操作的系统调用，常用的几个系统调用如下：</p>
<ul>
<li>sys_open</li>
<li>sys_close</li>
<li>sys_creat</li>
<li>sys_read</li>
<li>sys_write</li>
<li>sys_lseek</li>
</ul>
<blockquote>
<p>系统调用编号可以在/usr/include/asm/unistd.h中检查到，系统调用参数、返回值信息可以借助Linux man手册进行查询。</p>
</blockquote>
<p>汇编语言里面对于上述系统调用的调用与前面sys_read、sys_write示例程序中的使用方式是一致的，都按照如下几个步骤进行调用：</p>
<ul>
<li>将系统调用的编号设置到EAX；</li>
<li>将系统调用的参数依次设置到EBX、ECX、EDX、ESI、EDI、EBX；</li>
<li>触发内核中断int 80h；</li>
<li>检查EAX中保存的系统调用返回值；</li>
</ul>
<p>如下示例程序对文件相关的系统调用进行了组合使用，首先创建一个文件并写入数据，然后关闭，再重新打开文件并读取文件内容，最后在stdout上打印文件内容。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start         <span style="color:#75715e">;must be declared for using gcc</span>
	
_start:                  <span style="color:#75715e">;tell linker entry point</span>
   <span style="color:#75715e">;create the file</span>
   <span style="color:#a6e22e">mov</span>  eax, <span style="color:#ae81ff">8</span>
   <span style="color:#a6e22e">mov</span>  ebx, file_name
   <span style="color:#a6e22e">mov</span>  ecx, <span style="color:#ae81ff">0777</span>        <span style="color:#75715e">;read, write and execute by all</span>
   <span style="color:#a6e22e">int</span>  <span style="color:#ae81ff">0x80</span>             <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#a6e22e">mov</span> [fd_out], eax
    
   <span style="color:#75715e">; write into the file</span>
   <span style="color:#a6e22e">mov</span>	edx,len          <span style="color:#75715e">;number of bytes</span>
   <span style="color:#a6e22e">mov</span>	ecx, msg         <span style="color:#75715e">;message to write</span>
   <span style="color:#a6e22e">mov</span>	ebx, [fd_out]    <span style="color:#75715e">;file descriptor </span>
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">4</span>            <span style="color:#75715e">;system call number (sys_write)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>             <span style="color:#75715e">;call kernel</span>
	
   <span style="color:#75715e">; close the file</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">6</span>
   <span style="color:#a6e22e">mov</span> ebx, [fd_out]
    
   <span style="color:#75715e">; write the message indicating end of file write</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ecx, msg_done
   <span style="color:#a6e22e">mov</span> edx, len_done
   <span style="color:#a6e22e">int</span>  <span style="color:#ae81ff">0x80</span>
    
   <span style="color:#75715e">;open the file for reading</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">5</span>
   <span style="color:#a6e22e">mov</span> ebx, file_name
   <span style="color:#a6e22e">mov</span> ecx, <span style="color:#ae81ff">0</span>             <span style="color:#75715e">;for read only access</span>
   <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">0777</span>          <span style="color:#75715e">;read, write and execute by all</span>
   <span style="color:#a6e22e">int</span>  <span style="color:#ae81ff">0x80</span>
	
   <span style="color:#a6e22e">mov</span>  [fd_in], eax
    
   <span style="color:#75715e">;read from file</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">3</span>
   <span style="color:#a6e22e">mov</span> ebx, [fd_in]
   <span style="color:#a6e22e">mov</span> ecx, info
   <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">26</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
    
   <span style="color:#75715e">; close the file</span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">6</span>
   <span style="color:#a6e22e">mov</span> ebx, [fd_in]
    
   <span style="color:#75715e">; print the info </span>
   <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span> ecx, info
   <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">26</span>
   <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
       
   <span style="color:#a6e22e">mov</span>	eax,<span style="color:#ae81ff">1</span>             <span style="color:#75715e">;system call number (sys_exit)</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">0x80</span>              <span style="color:#75715e">;call kernel</span>

<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">file_name</span> db <span style="color:#e6db74">&#39;myfile.txt&#39;</span>
<span style="color:#a6e22e">msg</span> db <span style="color:#e6db74">&#39;Welcome to Tutorials Point&#39;</span>
<span style="color:#66d9ef">len</span><span style="color:#66d9ef"> equ</span>  <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span>msg

<span style="color:#a6e22e">msg_done</span> db <span style="color:#e6db74">&#39;Written to file&#39;</span>, <span style="color:#ae81ff">0xa</span>
<span style="color:#66d9ef">len_done</span><span style="color:#66d9ef"> equ</span> <span style="color:#66d9ef">$</span><span style="color:#f92672">-</span>msg_done

<span style="color:#66d9ef">section</span> .bss
<span style="color:#a6e22e">fd_out</span> resb <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">fd_in</span>  resb <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">info</span> resb  <span style="color:#ae81ff">26</span>
</code></pre></div><h3 id="121-内存管理">1.21 内存管理</h3>
<p>Linux内核提供了系统调用sys_brk来分配堆内存区域，sys_brk实际上是增加了进程最大可动态申请的内存地址的上限，brk分配的内存区域（堆）仅仅挨着.data节，系统调用sys_brk参数为0时会返回当前可申请内存的最大地址，参数不为0时会调整当前brk边界。</p>
<p>下面的示例程序通过系统调用sys_brk来动态分配了16KB的内存空间：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nasm" data-lang="nasm"><span style="color:#66d9ef">section</span>	.text
   <span style="color:#66d9ef">global</span> _start         <span style="color:#75715e">;must be declared for using gcc</span>
	
_start:	                 <span style="color:#75715e">;tell linker entry point</span>

   <span style="color:#a6e22e">mov</span>	eax, <span style="color:#ae81ff">45</span>		 <span style="color:#75715e">;sys_brk</span>
   <span style="color:#a6e22e">xor</span>	ebx, ebx
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">80h</span>

   <span style="color:#a6e22e">add</span>	eax, <span style="color:#ae81ff">16384</span>	 <span style="color:#75715e">;number of bytes to be reserved</span>
   <span style="color:#a6e22e">mov</span>	ebx, eax
   <span style="color:#a6e22e">mov</span>	eax, <span style="color:#ae81ff">45</span>		 <span style="color:#75715e">;sys_brk</span>
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">80h</span>
	
   <span style="color:#a6e22e">cmp</span>	eax, <span style="color:#ae81ff">0</span>
   <span style="color:#a6e22e">jl</span>	exit	<span style="color:#75715e">;exit, if error </span>
   <span style="color:#a6e22e">mov</span>	edi, eax	 <span style="color:#75715e">;EDI = highest available address</span>
   <span style="color:#a6e22e">sub</span>	edi, <span style="color:#ae81ff">4</span>		 <span style="color:#75715e">;pointing to the last DWORD  </span>
   <span style="color:#a6e22e">mov</span>	ecx, <span style="color:#ae81ff">4096</span>	 <span style="color:#75715e">;number of DWORDs allocated</span>
   <span style="color:#a6e22e">xor</span>	eax, eax	 <span style="color:#75715e">;clear eax</span>
   <span style="color:#a6e22e">std</span>			 <span style="color:#75715e">;backward</span>
   <span style="color:#a6e22e">rep</span>	stosd            <span style="color:#75715e">;repete for entire allocated area</span>
   <span style="color:#a6e22e">cld</span>			 <span style="color:#75715e">;put DF flag to normal state</span>
	
   <span style="color:#a6e22e">mov</span>	eax, <span style="color:#ae81ff">4</span>
   <span style="color:#a6e22e">mov</span>	ebx, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">mov</span>	ecx, msg
   <span style="color:#a6e22e">mov</span>	edx, len
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">80h</span>		 <span style="color:#75715e">;print a message</span>

exit:
   <span style="color:#a6e22e">mov</span>	eax, <span style="color:#ae81ff">1</span>
   <span style="color:#a6e22e">xor</span>	ebx, ebx
   <span style="color:#a6e22e">int</span>	<span style="color:#ae81ff">80h</span>
	
<span style="color:#66d9ef">section</span>	.data
<span style="color:#a6e22e">msg</span>    	db	<span style="color:#e6db74">&#34;Allocated 16 kb of memory!&#34;</span>, <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">len</span><span style="color:#66d9ef">     equ</span>	<span style="color:#66d9ef">$</span> <span style="color:#f92672">-</span> msg
</code></pre></div><h3 id="122-总结">1.22 总结</h3>
<p>这里结合tutorialspoint上的汇编语言教程对相关的知识点进行了简要回顾，也有所收获，这里也分享给需要的同学。</p>

        </div>
        

        
        <hr>
        <div style="float:right;">
        


<div style="display:flex;">
    <div>分享：</div>
    <div>
        <div class="sharethis-inline-share-buttons"></div>
    </div>
</div>


        </div>

        <br>
        <br>

    </div>

    
    
    <br>
    <br>
    <div style="height:auto;align:center;text-align:center;"> 
        <div>
            <img src="/common/xiaoqi.png" style="height:238px;margin-top:10px;margin-right:5px;"/>
            <img src="/common/qrcode.jpg" style="height:238px;margin-top:10px;"/>
            <img src="/common/yuanbao.png" style="height:238px;margin-top:10px;margin-left:5px;"/>
        </div>

        <div>
            <p>
                感谢打赏，小七🐶、元宝🐱可以改善伙食咯 😘
            </p>
        </div>


    </div>
    

    


                
                <div class="container">
    <hr>
</div>
<div class="container has-text-centered top-pad">
    <a href="#top">
        <i class="fa fa-arrow-up"></i>
    </a>
</div>

<div class="container">
    <hr>
</div>

                <div class="section" id="footer">
    <div class="container has-text-centered">
    
        <span class="footer-text">
            <a href="https://github.com/victoriadrake/hugo-theme-introduction/"><strong>Introduction</strong></a> 主题为 <a href="http://gohugo.io/">Hugo</a> 而设。由开源社群贡献者以 <a href="https://victoria.dev"><i class="fa fa-heart"></i> 和 <i class="fa fa-coffee"></i></a> 创造。
        </span>
    
    </div>
</div>

                
            </div>
        </section>
        
        





<script src="https://hitzhangjie.pro/js/bundle.23f18222425179f754965a36c9b211bd8cff5e5ab61ee23b52f026cef6699139.js" integrity="sha256-I/GCIkJRefdUllo2ybIRvYz/Xlq2HuI7UvAmzvZpkTk="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168027530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




        
        
        
        
    </body>
</html>
