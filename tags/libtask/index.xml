<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>libtask on</title><link>/tags/libtask/</link><description>Recent content in libtask on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 26 Apr 2017 16:23:49 +0800</lastBuildDate><atom:link href="/tags/libtask/index.xml" rel="self" type="application/rss+xml"/><item><title>Coroutine-Switching</title><link>/blog/2017-04-26-coroutine-switching/</link><pubDate>Wed, 26 Apr 2017 16:23:49 +0800</pubDate><guid>/blog/2017-04-26-coroutine-switching/</guid><description>1. 协程Coroutine # 本文提供了一个模拟协程上下文切换过程的测试程序，基本思路是每当希望创建一个coroutine时，就在堆里申请一块内存，然后对内存进行整理，在其中保存预设的硬件上下文等信息（重点设置rbp、rsp、rip（callback）、rdi（callback-arg））。启动协程并进行切换时，通过__SwitchCoroutine__(cur,next)来完成cur向next的切换，切换过程中保存当前上下文信息到cur对应的堆内存中，并提取next对应的堆内存信息还原上下文完成切换。 测试程序中创建了4个coroutine，第1个coroutine只是为了用来启动其他3个，其他3个没有继续调度第一个，原因是第一个coroutine中rip保存的是main.c中__SwitchCoroutine__之后的指令地址，如果让第一个coroutine参与context-switch的话会使得进程结束执行。
在看下面的程序之前，需要先了解栈帧的构成、栈帧创建之前caller的动作&amp;amp;创建之后callee的动作、函数返回之前callee的动作&amp;amp;函数返回之后caller的动作，之前看过一篇整理的很不错的文章以供参考C Function Call Conventions and the Stack。
ps: 实际上直接使用linux下的ucontext_t实现会更简单，在我的介绍libmill的电子书中有详细介绍。
1.1. 协程coroutine声明 # file: coroutine.h
#include &amp;lt;stdint.h&amp;gt; typedef int64_t (*EntryCallback)(void*); //硬件上下文信息 struct stRegister { uint64_t rax; uint64_t rbx; uint64_t rcx; uint64_t rdx; uint64_t rsi; uint64_t rdi; uint64_t r8; uint64_t r9; uint64_t r10; uint64_t r11; uint64_t r12; uint64_t r13; uint64_t r14; uint64_t r15; uint64_t rbp; uint64_t rsp; uint64_t rip; }; //协程上下文 struct stContext { struct stRegister cpu_register; void *arg; uint8_t *stack; }; typedef struct stContext Coroutine; //创建协程 Coroutine* CreateCoroutine(EntryCallback entry, void *arg); //删除协程 void DeleteCoroutine(Coroutine *ptr); //设置协程栈尺寸 void SetStackSize(uint32_t size); //协程切换 void __SwitchCoroutine__(Coroutine *cur, const Coroutine *next); 1.</description></item></channel></rss>