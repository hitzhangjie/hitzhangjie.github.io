<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jmp_buf on</title><link>/tags/jmp_buf/</link><description>Recent content in jmp_buf on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 27 Mar 2017 21:31:13 +0800</lastBuildDate><atom:link href="/tags/jmp_buf/index.xml" rel="self" type="application/rss+xml"/><item><title>jmp_buf &amp; setjmp &amp; longjmp</title><link>/blog/2017-03-27-jmp_bufsetjmplongjmp/</link><pubDate>Mon, 27 Mar 2017 21:31:13 +0800</pubDate><guid>/blog/2017-03-27-jmp_bufsetjmplongjmp/</guid><description>最近在看spp &amp;amp; libco源码，他们实现协程上下文切换的过程中，都或多或少借鉴了jmp_buf的设计，用以保存协程执行时的现场。协程切换的时候保存当前协程的现场，然后恢复待调度协程的现场。理解是很容易理解，但是总感觉还是有点浅尝辄止了，于是就抽点时间看了下jmp_buf、setjmp、longjmp相关的代码，大体理了下思路。
学习整理了一下关于jmp_buf &amp;amp; setjmp &amp;amp; longjmp的内容。
linux 4.0内核中jmp_buf这个结构体用于记录硬件上下文信息，可以用于函数内、函数外跳转，goto只能实现函数内跳转。先来看下这个结构体的定义吧，i386架构的处理器与x86_64架构的处理器，对应的jmp_buf结构体定义稍微有些不同，这个很容易理解，寄存器位宽、数量等都有些不同。
i386架构：
// 处理器架构：i386 // - Linux/arch/x86/um/shared/sysdep/archsetjmp_32.h struct __jmp_buf { unsigned int __ebx; // 通用数据寄存器之一 unsigned int __esp; // 栈指针寄存器(进程栈空间由高地址向低地址方向增长) unsigned int __ebp; // 基址指针寄存器(记录了当前栈帧的起始地址(进入一个函数后首先执行的便是push %ebp; mov %esp, %ebp)) unsigned int __esi; // 源变址寄存器 unsigned int __edi; // 目的编制寄存器 unsigned int __eip; // 指令指针寄存器(程序计数器PC=CS:IP,二者结合起来确定下一条待执行的机器指令地址) }; typedef struct __jmp_buf jmp_buf[1]; x86_64架构：
// 处理器架构：x86_64 // - Linux/arch/x86/um/shared/sysdep/archsetjmp_64.h struct __jmp_buf { unsigned long __rbx; // 通用数据寄存器之一 unsigned long __rsp; // 栈指针寄存器 unsigned long __rbp; // 基址指针寄存器 unsigned long __r12; unsigned long __r13; unsigned long __r14; unsigned long __r15; unsigned long __rip; }; typedef struct __jmp_buf jmp_buf[1]; 但是呢，glibc里面重新定义了这个类型，这里面还对信号掩码进行了考虑。</description></item></channel></rss>